<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1부터 N까지의 원소를 갖는 집합의 부분집합 구하기</title>
    <url>/2022/221007-archive/</url>
    <content><![CDATA[<h2 id="✏️-문제"><a href="#✏️-문제" class="headerlink" title="✏️  문제"></a>✏️  문제</h2><p>자연수 N이 주어지면 1부터 N까지의 원소를 갖는 집합의 부분집합을 모두 출력하는 프로그램을 작성하세요.</p>
<p>입력설명<br>첫 번째 줄에 자연수 N(1 ≤ N ≤ 10)이 주어집니다. </p>
<p>출력 설명<br>첫 번째 줄부터 각 줄에 하나씩 부분집합을 출력예제와 같은 순서로 출력한다.</p>
<p>입력 예제</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>출력 예제</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>


<h3 id="👉-부분-집합을-구하는-문제"><a href="#👉-부분-집합을-구하는-문제" class="headerlink" title="👉 부분 집합을 구하는 문제"></a>👉 부분 집합을 구하는 문제</h3><p>1을 방문을 할 지 안 할지 2가지 선택, 2를 방문을 할 지 안 할지 2가지 선택, 3을 방문을 할 지 안 할지 2가지 선택<br>➡️  총 8가지의 트리가 만들어진다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">상태트리</span><br><span class="line"></span><br><span class="line">부분집합의 개수 <span class="number">2</span> ^ x - <span class="number">1</span> (공집합 제외)</span><br><span class="line">집합에 원소가 들어갈지 안들어갈지 선택한다.</span><br><span class="line"></span><br><span class="line"><span class="title function_">D</span>(<span class="number">1</span>) -&gt; O -&gt; <span class="title function_">D</span>(<span class="number">2</span>) -&gt; o -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br><span class="line">                  -&gt; x -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br><span class="line">     -&gt; X -&gt; <span class="title function_">D</span>(<span class="number">2</span>) -&gt; o -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br><span class="line">                  -&gt; x -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br></pre></td></tr></table></figure>

<p>문제에서 1부터 N까지의 원소를 갖는 부분집합을 구하라고 했기 때문에, 1부터 N까지의 길이에 0을 담은 체크 배열을 만들어준다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> checkArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>이제 Head 노드에서부터 노드를 방문하면서, 해당 노드를 포함할 것인지 확인하고, 부분 집합을 찾아준다.</p>
<p>(내가 만든 부분 집합에 참여시키고 참여시키지않는 것을 확인 후 배열에 하나씩 담아주면 된다.)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DFS</span>(<span class="params">depth</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth === n + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 1로 들어온 것들만 출력하기</span></span><br><span class="line">        <span class="keyword">if</span> (checkArray[i] === <span class="number">1</span>) temp += i + <span class="string">&quot; &quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp.<span class="property">length</span> &gt;= <span class="number">1</span>) answer.<span class="title function_">push</span>(temp.<span class="title function_">trim</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 집합에 포함시킨다.</span></span><br><span class="line">      checkArray[depth] = <span class="number">1</span>;</span><br><span class="line">      <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 집합에 포함시키지 않는다.</span></span><br><span class="line">      checkArray[depth] = <span class="number">0</span>;</span><br><span class="line">      <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="👉-DFS-함수를-잘-살펴보자"><a href="#👉-DFS-함수를-잘-살펴보자" class="headerlink" title="👉  DFS 함수를 잘 살펴보자"></a>👉  DFS 함수를 잘 살펴보자</h3><ol>
<li>부분집합이 주어진 배열의 길이를 넘어갈 수는 없으므로, depth가 배열의 길이와 같다면 재귀를 멈추고, 1로 들어온 인덱스만 출력한다.</li>
<li>depth가 아직 배열의 길이에 도달하지 않으면, 자기 자식 노드를 선택하는 경우와 그렇지 않은 경우를 만들고, 자식을 호출하여 부분집합을 찾아간다.</li>
</ol>
<h3 id="✅-전체-코드"><a href="#✅-전체-코드" class="headerlink" title="✅ 전체 코드"></a>✅ 전체 코드</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = [];</span><br><span class="line">  <span class="keyword">let</span> checkArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">DFS</span>(<span class="params">depth</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth === n + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 1로 들어온 것들만 출력하기</span></span><br><span class="line">        <span class="keyword">if</span> (checkArray[i] === <span class="number">1</span>) temp += i + <span class="string">&quot; &quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp.<span class="property">length</span> &gt;= <span class="number">1</span>) answer.<span class="title function_">push</span>(temp.<span class="title function_">trim</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 집합에 포함시킨다.</span></span><br><span class="line">      checkArray[depth] = <span class="number">1</span>;</span><br><span class="line">      <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 집합에 포함시키지 않는다.</span></span><br><span class="line">      checkArray[depth] = <span class="number">0</span>;</span><br><span class="line">      <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">DFS</span>(<span class="number">1</span>); <span class="comment">// DFS는 1부터 시작한다.</span></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>DFS를 사용하려면 재귀함수가 기본적인 지식으로 깔려 있어야하는 것 같다. 재귀함수를 배웠다고 생각했는데 막상 그것도 아닌가보다. 😟 DFS가 실행되는 과정에 대해서 더 이해하는 과정이 필요할 것 같다. 부분집합을 구하라는 문제를 봤을 때, 어떻게 구해야하지 라고 생각하다가 가지치기 형식으로 그림을 그리다보니 이진트리 형태로 나오는 것을 보면서 이러면 이진트리로 접근해야겠다. 라는 생각이 들었던 것만으로도 오늘은 성공인것 같다!</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>실행 컨텍스트 - 실행 컨텍스트가 하는 역할이 무엇일까?</title>
    <url>/2022/221012-archive/</url>
    <content><![CDATA[<p>자바스크립트 Deep Dive를 공부하고 정리해보자 :)<br>실행 컨텍스트가 무슨 역할을 하는지에 대해서 알아보자.</p>
<h2 id="소스코드의-타입"><a href="#소스코드의-타입" class="headerlink" title="소스코드의 타입"></a>소스코드의 타입</h2><p>ECMAScript 사양은 소스코드를 4가지 타입으로 구분한다.</p>
<p>4가지 타입의 소스코드는 실행 컨텍스트를 생성한다.</p>
<table>
<thead>
<tr>
<th>소스코드의 타입</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>전역 코드</td>
<td>전역에 존재하는 소스코드를 말한다.</td>
</tr>
<tr>
<td>전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.</td>
<td></td>
</tr>
<tr>
<td>함수 코드</td>
<td>함수 내부에 존재하는 소스코드를 말한다.</td>
</tr>
<tr>
<td>함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.</td>
<td></td>
</tr>
<tr>
<td>eval 코드</td>
<td>빌트인 전역 함수인 [[eval 함수]]에 인수로 전달되어 실행되는 소스코드를 말한다.</td>
</tr>
<tr>
<td>모듈 코드</td>
<td>모듈 내부에 존재하는 소스코드를 말한다.</td>
</tr>
<tr>
<td>모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.</td>
<td></td>
</tr>
</tbody></table>
<h3 id="소스코드를-4가지-타입으로-구분하는-이유"><a href="#소스코드를-4가지-타입으로-구분하는-이유" class="headerlink" title="소스코드를 4가지 타입으로 구분하는 이유"></a><strong>소스코드를 4가지 타입으로 구분하는 이유</strong></h3><p>소스코드의 타입에 따라 실행 컨텍스트를 실행하는 과정과 관리 내용이 다르기 때문이다.</p>
<h3 id="전역-코드"><a href="#전역-코드" class="headerlink" title="전역 코드"></a><strong>전역 코드</strong></h3><ul>
<li>전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다.</li>
<li>그리고 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 한다. 👉 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.</li>
</ul>
<h3 id="함수-코드"><a href="#함수-코드" class="headerlink" title="함수 코드"></a><strong>함수 코드</strong></h3><ul>
<li>함수 코드는 지역 스코프를 생성</li>
<li>지역 변수, 매개변수, arguments 객체를 관리해야 한다.</li>
<li>그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체이의 일원으로 연결해야 한다.</li>
</ul>
<p>👉 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.</p>
<h3 id="eval-코드"><a href="#eval-코드" class="headerlink" title="eval 코드"></a>eval 코드</h3><ul>
<li>strict mode에서 자신만의 독자적인 스코프를 생성한다.</li>
</ul>
<p>👉 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다.</p>
<h3 id="모듈-코드"><a href="#모듈-코드" class="headerlink" title="모듈 코드"></a>모듈 코드</h3><ul>
<li>모듈 코드는 모듈별로 독자적인 모듈 스코프를 생성한다.</li>
</ul>
<p>👉 이를 위해 모듈 코드가 평가되면 함수 실행 컨텍스트가 생성된다.</p>
<h2 id="소스코드의-평가와-실행"><a href="#소스코드의-평가와-실행" class="headerlink" title="소스코드의 평가와 실행"></a>소스코드의 평가와 실행</h2><p>모든 소스코드는 실행에 앞서 <strong>평가 과정</strong>을 거치며 코드를 실행하기 위한 준비를 한다.</p>
<p>👉 <em>즉, 자바스크립트 엔진은 2개의 과정으로 나누어 처리한다.</em></p>
<h3 id="소스코드의-평가-과정"><a href="#소스코드의-평가-과정" class="headerlink" title="소스코드의 평가 과정"></a>소스코드의 평가 과정</h3><ul>
<li><p><strong>실행 컨텍스트</strong>를 생성</p>
</li>
<li><p>변수, 함수 등의 선언문만 먼저 실행</p>
<p>  👉 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다.</p>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ffbef7e69-646e-444f-86c6-86c6fe64c8df%2Fjavascript-context01.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ffbef7e69-646e-444f-86c6-86c6fe64c8df%2Fjavascript-context01.png"></p>
<h3 id="소스코드-평가-과정이-끝나면-소스코드가-순차적으로-실행되기-시작한다"><a href="#소스코드-평가-과정이-끝나면-소스코드가-순차적으로-실행되기-시작한다" class="headerlink" title="소스코드 평가 과정이 끝나면 소스코드가 순차적으로 실행되기 시작한다."></a>소스코드 평가 과정이 끝나면 소스코드가 순차적으로 실행되기 시작한다.</h3><p>👉 즉, 런타임이 시작된다.</p>
<ul>
<li>소스코드 실행에 필요한 정보<ul>
<li>변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다.</li>
</ul>
</li>
<li>변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.</li>
</ul>
<p>예를 들어, 다음과 같은 소스코드가 실행된다고 생각해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>🙌🏻 <strong>자바스크립트 엔진은 위 예제를 2개의 과정으로 나누어 처리한다.</strong></p>
<ol>
<li>소스코드 평가 과정에서 변수 선언문 <strong>var x</strong>를 먼저 실행한다.<ol>
<li>이때 생성된 변수 식별자 x는 실행 컨텍스트가 관리하는 <strong>스코프에 등록</strong></li>
<li>undefined로 초기화</li>
</ol>
</li>
<li>소스코드 평가 과정이 끝나면 소스코드 실행 과정이 시작된다.<ol>
<li>변수 할당문 x &#x3D; 1 만 실행한다.</li>
<li>이때 x 변수에 값을 할당하려면 먼저 x 변수가 선언된 변수인지 확인해야 한다.</li>
<li>이를 위해 실행 컨텍스트가 관리하는 스코프에 x 변수가 등록되어 있는지 확인한다.</li>
</ol>
</li>
</ol>
<h2 id="실행-컨텍스트의-역할"><a href="#실행-컨텍스트의-역할" class="headerlink" title="실행 컨텍스트의 역할"></a>실행 컨텍스트의 역할</h2><p>🙌🏻 전역 코드와 함수 코드로 구성되어 있는 예제를 살펴보면서 자바스크립트 엔진이 이 예제를 어떻게 평가하고 실행할지 생각해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 전역 변수 선언</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="comment">// 지역 변수 선언</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메서드 호출</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + x + y); <span class="comment">// 130</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메서드 호출</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x + y); <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-전역-코드-평가"><a href="#1-전역-코드-평가" class="headerlink" title="1. 전역 코드 평가"></a>1. 전역 코드 평가</h3><ul>
<li><p>전역 코드를 실행하기 앞서 평가 과정을 거치며 “전역 코드를 실행할 준비”를 한다.</p>
</li>
<li><p>소스코드 평가 과정에서는 선언문만 먼저 실행한다.</p>
</li>
<li><p>따라서 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행</p>
<p>  👉 <strong>생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프</strong>에 등록된다.</p>
</li>
<li><p>이때 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수</p>
<p>  👉 전역 객체의 프로퍼티와 메서드가 된다.</p>
</li>
</ul>
<h3 id="2-전역-코드-실행"><a href="#2-전역-코드-실행" class="headerlink" title="2. 전역 코드 실행"></a>2. 전역 코드 실행</h3><ul>
<li>평가 과정이 끝나면 런타임이 시작되어 전역 코드가 순차적으로 실행된다.</li>
<li>이때 전역 변수에 값이 할당되고 함수가 호출된다.</li>
<li>함수가 호출되면 전역 코드의 실행을 일시 중단하고 함수 내부로 진입한다.</li>
</ul>
<h3 id="3-함수-코드-평가"><a href="#3-함수-코드-평가" class="headerlink" title="3. 함수 코드 평가"></a>3. 함수 코드 평가</h3><ul>
<li><p>함수 내부로 진입하면 함수 내부의 문들을 실행하기 앞서 함수 코드 평가 과정을 거친다.</p>
<p>  👉 함수 코드를 실행하기 위한 준비</p>
</li>
<li><p>이때 매개변수와 지역 변수 선언문이 먼저 실행</p>
<p>  👉 <strong>생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프</strong>에 등록된다.</p>
</li>
<li><p>또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성</p>
<p>  👉 지역 스코프에 등록되고 this 바인딩도 결정된다.</p>
</li>
</ul>
<h3 id="4-함수-코드-실행"><a href="#4-함수-코드-실행" class="headerlink" title="4. 함수 코드 실행"></a>4. 함수 코드 실행</h3><ul>
<li><p>함수 코드 평가 과정이 끝나면 런타임이 시작되어 순차적으로 실행되기 시작</p>
</li>
<li><p>이때 매개변수와 지역 변수에 값이 할당되고, console.log 메서드가 호출된다.</p>
</li>
<li><p>console.log 메서드를 호출하기 위해서</p>
<ol>
<li><p>식별자인 console을 스코프 체인을 통해 검색<br>  : 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 하지만 console 식별자는 스코프 체인에 등록되어 있지 않고 <strong>전역 객체 프로퍼티</strong>로 존재한다.<br>  👉 전역 객체 프로퍼티가 마치 전역 변수처럼 전역 스코프를 통해 검색 가능하다는 것을 의미한다.</p>
</li>
<li><p>log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색</p>
<p> : 그 후 console.log 메서드에 인수로 전달된 표현식 a + x + y가 평가된다.</p>
</li>
</ol>
</li>
<li><p>console.log 메서드 실행이 종료되면 함수 코드 실행 과정이 종료</p>
</li>
<li><p>함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.</p>
</li>
</ul>
<p>코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값이 관리되어야 한다. 그리고 <strong>중첩 관계에 의해 스코프 체인을 형성</strong>하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다.</p>
<p>또한 함수 호출이 종료되면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다.</p>
<h3 id="✏️-코드가-실행되려면-다음과-같이-스코프-식별자-코드-실행-순서-등의-관리가-필요하다"><a href="#✏️-코드가-실행되려면-다음과-같이-스코프-식별자-코드-실행-순서-등의-관리가-필요하다" class="headerlink" title="✏️ 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다."></a>✏️ 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</h3><ol>
<li>선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고, 상태 변화를 지속적으로 관리할 수 있어야 한다.</li>
<li>스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다.<ol>
<li>즉, <strong>스코프 체인</strong>을 통해 상위 스코프로 이동하여 식별자를 검색할 수 있어야 한다.</li>
</ol>
</li>
<li>현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</li>
</ol>
<p>이 모든 것을 관리하는 것이 실행 컨텍스트다.</p>
<h3 id="✅-실행-컨텍스트"><a href="#✅-실행-컨텍스트" class="headerlink" title="✅ 실행 컨텍스트"></a>✅ 실행 컨텍스트</h3><p>: 소스코드를 <strong>실행하는 데 필요한 환경을 제공</strong>하고 코드의 실행 결과를 <strong>실제로 관리</strong>하는 영역</p>
<p>식별자(변수, 함수, 클래스 등의 이름)을 등록하고 관리하는 <strong>스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘</strong></p>
<p><strong>💡 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.</strong></p>
<ul>
<li>식별자와 스코프: 실행 컨텍스트의 <strong>렉시컬 환경</strong>으로 관리</li>
<li>코드 실행 순서: <strong>실행 컨텍스트 스택</strong>으로 관리</li>
</ul>
<hr>
<h2 id="😎-정리하면서-배운-점"><a href="#😎-정리하면서-배운-점" class="headerlink" title="😎 정리하면서 배운 점"></a>😎 정리하면서 배운 점</h2><p>실행 컨텍스트는 소스코드를 실행하고 관리하는 영역이라는 것에 대해서 알게되었다.<br>모든 코드는 실행 컨텍스트에 의해 실행되고 관리된다는 점을 잊지말자.</p>
<p>렉시컬 환경이 무엇이고, 실행 컨텍스트가 무엇인지 매번 들을 때마다 나중에 공부해야지 생각했는데 드디어 공부해야할 때가 온 것 같다.</p>
<p>렉시컬 스코프, 렉시컬 환경, 실행 컨텍스트 스택에 대해서는 다음 블로그에서 알아보자 :)</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>크레인 인형뽑기 [2019 카카오 개발자 겨울 인턴십]</title>
    <url>/2022/221013-archive/</url>
    <content><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.<br>죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.</p>
<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png"></p>
<p>게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다.</p>
<p>모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다.</p>
<p>다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.</p>
<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png"></p>
<p>만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.</p>
<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif"></p>
<p>크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동 시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)</p>
<p>게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.</p>
<h2 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h2><p>board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.</p>
<p>board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.</p>
<p>0은 빈 칸을 나타냅니다.</p>
<p>1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나<br>타냅니다.</p>
<p>moves 배열의 크기는 1 이상 1,000 이하입니다.</p>
<p>moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.</p>
<h2 id="예제입력"><a href="#예제입력" class="headerlink" title="예제입력"></a>예제입력</h2><p>▣ 입력예제 1</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>]] <span class="comment">//board 배열</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="comment">//moves 배열</span></span><br></pre></td></tr></table></figure>

<p>▣ 출력예제 1</p>
<p>4</p>
<hr>
<h3 id="🙌🏻-문제-이해하기"><a href="#🙌🏻-문제-이해하기" class="headerlink" title="🙌🏻 문제 이해하기"></a>🙌🏻 문제 이해하기</h3><p>문제를 해결하기 위해 어떤 방법을 사용해야하는지 생각해보자 :)</p>
<ol>
<li>인형을 스택이라는 바구니에 넣어야 한다. ➡️ 배열 생성</li>
<li>moves 배열을 하나씩 순회해야한다. ➡️ forEach 메서드</li>
<li>위치 1에 해당하는 board의 인덱스는 0이다.<ol>
<li>board 배열의 형태는 2차원 배열이며 위치 1에 해당하는 요소를 탐색하기 위해선</li>
<li>[0][1], [1][1], [2][1] 의 형태로 반복을 해야한다. ➡️ for문 [i][1]</li>
</ol>
</li>
<li>반복문으로 탐색을 하다가 값이 0이 아닌 요소를 만나면 인형을 꺼내야한다.</li>
<li>인형을 꺼냈다면 해당 위치의 배열 요소는 0으로 만들어줘야 한다.</li>
<li>꺼낸 인형을 스택에 push하자. 그 전에 체크를 해야하는데,<ol>
<li>만약 스택에 담겨있는 마지막 인형이 넣을 인형과 동일하다면? → push가 아니라 pop을 하면 된다. 그리고 answer +&#x3D; 2</li>
<li>동일하지 않다면? → 그 때 push하기</li>
</ol>
</li>
<li>터진 인형의 갯수를 구하는 문제이기 때문에 answer를 반환하면 된다.</li>
</ol>
<h3 id="✅-solution"><a href="#✅-solution" class="headerlink" title="✅ solution"></a>✅ solution</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">board, moves</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  moves.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; board.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 순회하는 요소가 0이 아닐때만 stack에 값을 push할 수 있다.</span></span><br><span class="line">      <span class="keyword">if</span> (board[i][item - <span class="number">1</span>] !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// stack에 넣을 값을 임시 저장해놓기 (인형 꺼내기)</span></span><br><span class="line">        <span class="keyword">let</span> tmp = board[i][item - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 값을 선택했으니, 배열의 원소는 0으로 설정해놓기</span></span><br><span class="line">        board[i][item - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// stack에 push 하기 전에 먼저 체크</span></span><br><span class="line">        <span class="comment">// 1. 만약 tmp가 stack의 가장 마지막 요소와 같으면 pop하고 answer += 2</span></span><br><span class="line">        <span class="comment">// 2. tmp가 stack의 가장 마지막 요소와 일치하지 않으면 stack.push(tmp)</span></span><br><span class="line">        <span class="keyword">if</span> (tmp === stack[stack.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">          stack.<span class="title function_">pop</span>();</span><br><span class="line">          answer += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> stack.<span class="title function_">push</span>(tmp);</span><br><span class="line">        <span class="comment">// 해당 포지션에선 작업을 끝냈기 때문에 for문에서 탈출</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title function_">solution</span>(</span><br><span class="line">    [</span><br><span class="line">      [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">      [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">      [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">      [<span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">      [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    ],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>stack을 구현하고 배열을 하는 부분까지는 이제 어렵지 않다. 하지만 어느 시점에서 어떻게 자료를 빼낼건지에 대해서는 계속 공부를 하면서 익숙해져야할 것 같다…😢</p>
<p>예전엔 건들지도 못했던 내 자신과 비교하면 그래도 많이 늘었다! 게속 열심히 공부해보즈앗</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>후위연산식(postfix)</title>
    <url>/2022/221014-archive/</url>
    <content><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>후위연산식이 주어지면 연산한 결과를 출력하는 프로그램을 작성하세요.</p>
<p>만약 3*(5+2)-9 을 후위연산식으로 표현하면 352+*9- 로 표현되며 그 결과는 12입니다.</p>
<h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫 줄에 후위연산식이 주어집니다. 연산식의 길이는 50을 넘지 않습니다. </p>
<p>식은 1~9의 숫자와 +, -, *, &#x2F; 연산자로만 이루어진다.</p>
<h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>연산한 결과를 출력합니다.</p>
<h3 id="예제입력"><a href="#예제입력" class="headerlink" title="예제입력"></a>예제입력</h3><p>▣ 입력예제 1 </p>
<p>352+*9-</p>
<p>▣ 출력예제 1 </p>
<p>12</p>
<hr>
<h2 id="🙌🏻-문제-이해하기"><a href="#🙌🏻-문제-이해하기" class="headerlink" title="🙌🏻 문제 이해하기"></a>🙌🏻 문제 이해하기</h2><p>문제를 해결하기 위해 어떤 방법을 사용해야하는지 생각해보자 :)</p>
<ol>
<li>문자열로 받은 argument를 하나씩 확인해야한다. ➡️ split 메서드 사용하여 배열로 만들기</li>
<li>반복문으로 순회를 하면서 숫자를 만나면 stack에 넣는다. </li>
<li>연산자를 만나면 stack에서 2개의 값을 꺼내 계산한다. </li>
<li>계산한 값을 다시 stack에 넣는다. </li>
<li>반복문이 종료되었을 때 계산된 값을 반환한다.</li>
</ol>
<h2 id="✅-solution"><a href="#✅-solution" class="headerlink" title="✅ solution"></a>✅ solution</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> array = s.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(item)) stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(item));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> right = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">let</span> left = stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (item) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left * right);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left + right);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left - right);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left / right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Number</span>(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solution</span>(<span class="string">&quot;352+*9-&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>이번 문제는 어떻게 풀지만 알고 있으면 쉽게 구현할 수 있는 문제인 것 같았다. </p>
<p>풀면서 오류를 범했던 것이 있다면 stack에 넣을 값을 숫자로 변환하지 않고 그대로 넣어서 결과값이 147이 나와 깜짝 놀랬다는 것… (앗차차 나의 실수😃)</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Alogrithm</tag>
      </tags>
  </entry>
  <entry>
    <title>스코프 - 스코프와 스코프의 종류</title>
    <url>/2022/221015-archive/</url>
    <content><![CDATA[<p>📚 스코프는 유효범위이다!<br>스코프에 대해서 알아보고 스코프의 종류에는 어떤 것들이 있는지 알아보자 ๑•‿•๑</p>
<h2 id="스코프란"><a href="#스코프란" class="headerlink" title="스코프란?"></a>스코프란?</h2><blockquote>
<p>스코프(scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다.<br>var 키워드로 선언한 변수와 let, const 키워드로 선언한 변수의 스코프는 다르게 동작한다. 스코프는 변수, 함수와 깊은 관련이 있다.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="comment">// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.</span></span><br><span class="line">  <span class="comment">// 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부다.</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); <span class="comment">// 2 5</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수는 코드의 가장 바깥 영역뿐 아니라 코드 블록이나 함수 몸체 내에서도 선언할 수 있다.<ul>
<li>이때 코드 블록이나 함수는 중첩될 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = <span class="number">1</span>; <span class="comment">// 코드의 가장 바깥 영역에서 선언한 변수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span>; <span class="comment">// 코드 블록 내에서 선언한 변수</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> var3 = <span class="number">3</span>; <span class="comment">// 중첩된 코드 블록 내에서 선언한 변수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> var4 = <span class="number">4</span>; <span class="comment">// 함수 내에서 선언한 변수</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> var5 = <span class="number">5</span>; <span class="comment">// 중첩된 함수 내에서 선언한 변수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var1); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var2); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var3); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var4); <span class="comment">// ReferenceError: var4 is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var5); <span class="comment">// ReferenceError: var5 is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수는 자신이 선언된 위치에 의해 자신이 <strong>유효한 범위 👉</strong> 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다.</li>
<li>모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다.</li>
</ul>
<h3 id="✅-스코프"><a href="#✅-스코프" class="headerlink" title="✅ 스코프"></a>✅ 스코프</h3><p>: 식별자가 유효한 범위, 식별자를 검색할 때 사용하는 규칙</p>
<p>🙌🏻 다음 에제가 어떻게 동작할지 생각해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>

<ul>
<li>코드의 가장 바깥 영역과 foo 함수 내부에 같은 이름을 갖는 x 변수를 선언</li>
<li>①과 ②에서 x 변수를 참조</li>
</ul>
<p>자바스크립트 엔진은 스코프를 통해 두 개의 변수 중에서 어떤 변수를 참조해야할 지를 결정해야 한다. 👉🏻 <strong>식별자 결정</strong></p>
<p>🖥 자바스크립트 엔진은 코드를 실행할 때 <strong>코드의 문맥</strong>을 고려한다. </p>
<ul>
<li><p><strong>코드가 어디서 실행되며 주변에 어떤 코드가 있는지</strong>에 다라 동일한 코드도 다른 결과를 만들어 낸다. <code>👉**렉시컬 환경**</code></p>
</li>
<li><p>즉, 코드의 문맥은 렉시컬 환경이 만들어 낸다.  👉🏻 이를 구현한 것이 <code>**실행 컨텍스트**</code></p>
</li>
<li><p>모든 코드는 실행 컨텍스트에서 평가되고 실행된다. (스코프는 실행 컨텍스트와 깊은 관련이 있다.)</p>
</li>
<li><p>위 예제에서 코드 가장 바깥 영역에 선언된 x변수는 어디서든 참조할 수 있다.</p>
<ul>
<li>하지만 foo 함수 내부에서 선언된 x 변수는 foo 함수 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없다.</li>
<li>이때 두 개의 x 변수는 식별자 이름이 동일하지만, <strong>스코프가 다른 별개의 변수이다.</strong></li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cn0zjT/btqZoydJdrc/vHquKk6Vb0mf4PaExIsZX1/img.png" alt="https://blog.kakaocdn.net/dn/cn0zjT/btqZoydJdrc/vHquKk6Vb0mf4PaExIsZX1/img.png"></p>
<ul>
<li>식별자는 어떤 값을 구별할 수 있어야하므로 유일해야 한다.<ul>
<li>따라서 하나의 값은 유일한 식별자에 연결되어야 한다.</li>
</ul>
</li>
</ul>
<p>🙌🏻 컴퓨터의 폴더로 예를 들어보자.</p>
<ul>
<li>파일 이름: 하나의 파일을 구별하여 식별할 수 있는 식별자, 파일 이름은 유일해야하 한다.</li>
<li>파일 이름을 중복해서 사용할 수 있는 이유: 폴더라는 개념이 있기 때문</li>
<li>만약 폴더가 없다면? → 파일 이름은 유일해야 하기 때문에 이름 만드는 것이 번거로워질 것</li>
</ul>
<p>이와 마찬가지로 프로그래밍 언어에서는 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다. 👉 스코프는 <strong>네임스페이스</strong>다. </p>
<hr>
<h2 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h2><ul>
<li>코드는 전역과 지역으로 구분 가능</li>
</ul>
<table>
<thead>
<tr>
<th>구분</th>
<th>설명</th>
<th>스코프</th>
<th>변수</th>
</tr>
</thead>
<tbody><tr>
<td>전역</td>
<td>코드의 가장 바깥 영역</td>
<td>전역 스코프</td>
<td>전역 변수</td>
</tr>
<tr>
<td>지역</td>
<td>함수 몸체 내부</td>
<td>지역 스코프</td>
<td>지역 변수</td>
</tr>
</tbody></table>
<ul>
<li><p>이때 변수는 자신이 선언된 위치(전역&#x2F; 지역)에 의해 스코프가 결정</p>
<p>  👉 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수</p>
</li>
</ul>
<h3 id="전역과-전역-스코프"><a href="#전역과-전역-스코프" class="headerlink" title="전역과 전역 스코프"></a>전역과 전역 스코프</h3><p><img src="https://velog.velcdn.com/images/starrypro/post/f1f22f08-afa8-4c97-ace9-1f02cf04880a/image.png" alt="https://velog.velcdn.com/images/starrypro/post/f1f22f08-afa8-4c97-ace9-1f02cf04880a/image.png"></p>
<ul>
<li>전역이란? 코드의 가장 바깥 영역</li>
<li>전역은 전역 스코프를 만든다.</li>
<li>전역에 변수를 선언하면? → 전역 스코프를 갖는 전역 변수가 된다.</li>
<li><strong>전역 변수는 어디서든지 참조할 수 있다.</strong></li>
<li>코드 가장 바깥 영역인 전역에서 선언된 x, y 변수 👉 전역 변수<ul>
<li>전역 변수는 어디서든 참조할 수 있으므로 함수 내부에서도 참조 가능</li>
</ul>
</li>
</ul>
<h3 id="지역과-지역-스코프"><a href="#지역과-지역-스코프" class="headerlink" title="지역과 지역 스코프"></a>지역과 지역 스코프</h3><ul>
<li><p>지역이란? 👉🏻 함수 몸체 내부</p>
</li>
<li><p>지역은 지역 스코프를 만든다.</p>
</li>
<li><p>지역에 변수를 선언하면? 👉🏻 지역 스코프를 갖는 지역 변수가 된다.</p>
</li>
<li><p>지역 변수는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조할 수 있다.</p>
<p>  ➡️ <strong>지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</strong></p>
</li>
</ul>
<p><strong>📃 outer 함수</strong></p>
<ul>
<li>outer 함수 내부에서 선언된 z 변수는? → 지역 변수</li>
<li>지역 변수 z를 참조할 수 있는 범위: 자신의 <strong>지역 스코프인 outer 함수</strong> 내부 + <strong>하위 지역 스코프인 inner 함수</strong> 내부</li>
<li>하지만 지역 변수 z를 전역에서 참조하면? → 참조에러</li>
</ul>
<p><strong>📃 inner 함수</strong> </p>
<ul>
<li>내부에서 선언된 x 변수 이외에 이름이 같은 전역 변수 x가 존재<ul>
<li>이때 내부에서 x 변수를 참조하면? → inner 함수 내부에 선언된 x 변수를 참조 (전역 변수 x)</li>
</ul>
</li>
</ul>
<p>👉 <strong>스코프 체인</strong>을 통해 참조할 변수를 검색했기 때문</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>레이저로 쇠막대기 자르기</title>
    <url>/2022/221017-archive/</url>
    <content><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.</p>
<ul>
<li>쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.<ul>
<li>각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.</li>
<li>레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다.</li>
</ul>
</li>
</ul>
<p>아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.</p>
<p><img src="https://s1.md5.ltd/image/949e163bd665c6f711dbab3329b755a2.png" alt="https://s1.md5.ltd/image/949e163bd665c6f711dbab3329b755a2.png"></p>
<p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.</p>
<ol>
<li>레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반 드시 레이저를 표현한다.</li>
<li>쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다.</li>
</ol>
<p>위 예의 괄호 표현은 그림 위에 주어져 있다.</p>
<p>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다.</p>
<p>쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.</p>
<h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다.</p>
<h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.</p>
<h3 id="예제입력"><a href="#예제입력" class="headerlink" title="예제입력"></a>예제입력</h3><p>▣ 입력예제 1</p>
<p>()(((()())(())()))(())</p>
<p>▣ 출력예제 1<br>17</p>
<p>▣ 입력예제 2<br>(((()(()()))(())()))(()())</p>
<p>▣ 출력예제 2<br>24</p>
<hr>
<h2 id="🙌🏻-문제-이해하기"><a href="#🙌🏻-문제-이해하기" class="headerlink" title="🙌🏻 문제 이해하기"></a>🙌🏻 문제 이해하기</h2><ul>
<li>문제는? 👉🏻쇠막대기와 레이저의 배치를 나타내는 괄호가 주어졌을 때, 레이져로 잘린 쇠막대기 조각의 총 개수를 출력해라</li>
<li><strong>괄호 문제가 나오면 stack으로 접근하기</strong></li>
<li>주어진 문자열을 하나씩 순회</li>
<li>여는 괄호를 만날 경우 👉🏻 모두 stack에 push</li>
<li>닫는 괄호를 만날 경우<ul>
<li>레이저인가? 👉🏻 바로 전 인덱스 요소가 여는 괄호였다면 레이저</li>
<li>막대기의 끝인가? 👉🏻 바로 전 인덱스 요소가 여는 괄호가 아니라면 막대기의 끝</li>
</ul>
</li>
<li>레이저라면 stack.pop (여는 괄호 빼기) ➡️ stack.length를 더해주기<ul>
<li>stack.length는 막대기의 잘려진 갯수</li>
</ul>
</li>
<li>막대기의 끝이면 answer +&#x3D; 1 (쇠 막대 한개가 완성되면, 레이져로 잘리고 남은 쇠조각 1개만 남기 때문에 +1을 해주는 것)</li>
<li>for문이 종료되면 answer 반환하기</li>
</ul>
<h2 id="✅-solution"><a href="#✅-solution" class="headerlink" title="✅ solution"></a>✅ solution</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">&quot;(&quot;</span>) stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === <span class="string">&quot;(&quot;</span>) answer += stack.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">else</span> answer += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solution</span>(<span class="string">&quot;()(((()())(())()))(())&quot;</span>));</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>변수 - 우리는 왜 변수를 사용할까?</title>
    <url>/2022/221018-archive/</url>
    <content><![CDATA[<h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><h2 id="변수란-무엇인가-왜-필요한가"><a href="#변수란-무엇인가-왜-필요한가" class="headerlink" title="변수란 무엇인가? 왜 필요한가?"></a>변수란 무엇인가? 왜 필요한가?</h2><p>10 + 20 이라는 코드를 실행하려면 10, 20, + 라는 기호의 의미를 알고 있어야 하며, 10 + 20이라는 식의 의미도 해석할 수 있어야 한다.</p>
<ul>
<li>자바스크립트 엔진이 10 + 20 이라는 코드를 계산하려면 → 평가</li>
<li>먼저 10, 20, +라는 기호의 의미를 알고 있어야 하며 → 리터럴과 연산자</li>
<li>10 + 20이라는 식의 의미도 해석할 수 있어야 한다. → 표현식, 파싱</li>
</ul>
<p>하지만 문제가 있다. CPU가 연산해서 만들어낸 숫자 값 30을 재사용할 수 없다는 것이다. 연산을 했다는 것은 연산 결과가 필요하고 이를 사용해 무언가를 하겠다는 의도가 있었을 것이다. 만약 연산 결과 30을 재사용하고 싶다면 메모리 주소를 통해 연산 결과 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.</p>
<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.</p>
<h3 id="✅-변수"><a href="#✅-변수" class="headerlink" title="✅ 변수"></a>✅ <strong>변수</strong></h3><p>: 하나의 값을 저장하기 위해 확보한 메모리 공간 또는 메모리 공간을 식별하기 위해 붙인 이름</p>
<ul>
<li>변수 이름: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름</li>
<li>변수 값: 변수에 저장된 값</li>
<li>할당: 변수에 값을 저장하는 것</li>
<li>참조: 변수에 저장된 값을 읽어 들이는 것</li>
</ul>
<h2 id="식별자"><a href="#식별자" class="headerlink" title="식별자"></a>식별자</h2><p><strong>변수 이름</strong>을 식별자라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.</p>
<p>🖥 <strong>값은 메모리 공간에 저장되어 있다.</strong></p>
<p>따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 한다.</p>
<p>👉🏻 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야 한다.</p>
<p><img src="https://velog.velcdn.com/images/arthur/post/dbb4d959-05c8-4df4-afac-e167366c0a13/image.png" alt="https://velog.velcdn.com/images/arthur/post/dbb4d959-05c8-4df4-afac-e167366c0a13/image.png"></p>
<p><img src="https://velog.velcdn.com/images/arthur/post/b379fc11-1ecc-40d2-aca2-56151f132742/image.png" alt="https://velog.velcdn.com/images/arthur/post/b379fc11-1ecc-40d2-aca2-56151f132742/image.png"></p>
<ul>
<li>식별자 result는 값 30을 식별할 수 있다.</li>
<li>이를 위해 식별자 result는 값 30이 저장되어 있는 <strong>메모리 주소 0x0669F913</strong>을 기억해야 한다.</li>
</ul>
<p>👉🏻 즉, 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 매핑 정보도 매모리에 저장되어야 한다.</p>
<p><strong>🖥 식별자는 값이 아니라 메모리 주소를 기억하고 있다.</strong></p>
<ul>
<li>식별자로 값을 구별해서 식별한다는 것 👉🏻 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미</li>
<li>식별자는 <strong>메모리 주소에 붙인 이름</strong>이라고 할 수 있다.</li>
</ul>
<p>💡 <strong>식별자라는 이름은 변수 이름에만 국한해서 사용하지 않는다.</strong></p>
<ul>
<li>변수, 함수, 클래스 등의 이름은 모두 식별자다.</li>
<li>즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자다 .</li>
<li>변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, <strong>선언</strong>에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.</li>
</ul>
<h2 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h2><h3 id="✅-변수-선언"><a href="#✅-변수-선언" class="headerlink" title="✅  변수 선언"></a>✅  변수 선언</h3><p>: 값을 저장하기 위한 <strong>메모리 공간을 확보</strong>하고 <strong>변수 이름과 확보된 메모리 공간의 주소를 연결</strong>해서 값을 저장할 수 있게 준비하는 것</p>
<ul>
<li>선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.</li>
</ul>
<p><strong>🔥 변수를 사용하려면 반드시 선언이 필요하다.</strong></p>
<ul>
<li>선언할 때는 <strong>var, let, const</strong> 키워드를 사용한다.</li>
<li>ES6에서 let, const 키워드가 도입되기 전까지는 var 키워드가 변수를 선언할 수 있는 유일한 키워드였다.</li>
</ul>
<p><strong>✨ 키워드</strong></p>
<p>키워드는 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 <strong>수행할 동작을 규정한 일종의 명령</strong>이다.</p>
<p>자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 예를 들어, var 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다.</p>
<p>🙌🏻 다음 코드를 살펴보자.</p>
<p>var 키워드는 뒤에오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 변수 선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/arthur/post/68947fa0-da3e-4f1f-97f2-b3bd791953dc/image.png" alt="https://velog.velcdn.com/images/arthur/post/68947fa0-da3e-4f1f-97f2-b3bd791953dc/image.png"></p>
<ul>
<li>변수를 선언한 이후, 아직 변수에 값을 할당하지 않았다.<ul>
<li>따라서, <strong>변수 선언에 의해 확보된 메모리 공간</strong>은 비어있을 것이라고 생각할 수 있으나, 확보된 메모리 공간에는 undefined라는 값이 암묵적으로 할당되어 초기화된다. 👉🏻 자바스크립트의 독특한 특징</li>
</ul>
</li>
</ul>
<p><strong>✨ undefined</strong></p>
<p>undefined는 자바스크립트에서 제공하는 원시 타입의 값이다.</p>
<p>💡 자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다.</p>
<ol>
<li>선언 단계: 변수 이름을 등록 👉🏻 자바스크립트 엔진에게 변수의 존재를 알린다.</li>
<li>초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined을 할당해 초기화한다.</li>
</ol>
<p><strong>✨ 변수 이름은 어디에 등록될까?</strong></p>
<p>변수 이름을 비롯한 모든 식별자는 <strong>실행 컨텍스트</strong>에 등록된다.</p>
<p><strong>실행 컨텍스트</strong> ➡️ 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</p>
<p>변수 이름과 변수 값은 실행 컨텍스트 내에 키, 값 형식인 객체로 등록되어 관리된다. 자바스크립트 엔진이 변수를 관리하는 매커니즘은 <code>👉실행 컨텍스트</code>에서 자세히 살펴보자.</p>
<ul>
<li>var 키워드를 사용한 변수 선언은 <strong>선언 단계</strong>와 <strong>초기화 단계</strong>가 동시에 진행된다.</li>
<li><code>var score;</code> 는 선언 단계를 통해 ➡️ 변수 이름 score를 등록</li>
<li>초기화 단계를 통해 ➡️ score 변수에 암묵적으로 undefined를 할당해 초기화</li>
</ul>
<p><strong>✅ 초기화(initialization)</strong></p>
<p>: 변수가 선언된 이후 최초로 값을 할당하는 것</p>
<ul>
<li><p>var 키워드로 선언한 변수는 undefined로, <strong>암묵적인 초기화</strong>가 자동 수행된다.</p>
<p>  👉🏻 따라서 var 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.</p>
</li>
<li><p>만약 초기화 단게를 거치지 않으면 어떻게 될까?</p>
<ul>
<li>선언만 하계 되면 공간을 확보한 상태에서 값을 할당해주지 않은 상태이다.</li>
<li>확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 👉🏻 쓰레기 값(garbage value)</li>
</ul>
</li>
</ul>
<p>➡️ 따라서 메모리 공간을 확보한 다음, 값을 할당하지’ 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있다. 자바스크립트 var 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다.</p>
<p><strong>🔥 변수를 사용하면 반드시 선언이 필요하다.</strong></p>
<p>변수 뿐만 아니라 모든 식별자는 선언이 필요하다.</p>
<p>만약 선언하지 않은 식별자에 접근하면? 👉🏻 ReferenceError 발생</p>
<p><strong>✅ ReferenceError</strong></p>
<p>: 식별자를 통해 값을 참조하려 했지만, 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때  발생하는 에러</p>
<p>✨ <strong>var 키워드로 선언한 변수의 문제점이 무엇일까?</strong></p>
<p>가장 대표적인 것은 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되는 경우가 발생한다. <code>👉 var 키워드로 선언한 변수의 문제점</code></p>
<h2 id="변수-선언의-실행-시점과-변수-호이스팅"><a href="#변수-선언의-실행-시점과-변수-호이스팅" class="headerlink" title="변수 선언의 실행 시점과 변수 호이스팅"></a>변수 선언의 실행 시점과 변수 호이스팅</h2><p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수 선언문보다 변수를 참조하는 코드가 앞에 있다.</li>
<li>자바스크립트 코드는? 👉🏻 인터프리터에 의해 한 줄씩 순차적으로 실행된다.<ul>
<li>console.log(score)가 가장 먼저 실행</li>
<li>순차적으로 다음 줄에 있는 코드를 실행</li>
<li>console.log(score)가 실행되는 시점 👉🏻 아직 score 변수 선언이 실행되지 않았으므로 에러가 발생할 것 같지만, undefined가 출력된다.</li>
</ul>
</li>
</ul>
<p><strong>🔥 왜 첫 번째 <code>console.log(foo)</code> 에서 undefined가 출력될까?</strong></p>
<p>그 이유는 변수 선언이 런타임 이전 단계에서 먼저 실행되기 때문이다.</p>
<ol>
<li>자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.</li>
<li>이때 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다.</li>
<li>그리고 소스코드 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.</li>
</ol>
<p><strong>👉🏻 즉, 변수 선언이 소스코드의 어디에 있는 상관없이 다른 코드보다 먼저 실행한다. 따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다.</strong></p>
<p>🙌🏻 위 예제를 다시 살펴보자.</p>
<ul>
<li><p>변수 선언문인  <code>var score;</code>보다 변수를 참조하는 코드인 <code>console.log(score);</code>가 앞에 있다.</p>
</li>
<li><p>만약 코드가 순차적으로실행되는 런타임에 변수 선언이 실행된다면 <code>console.log(score);</code> 가 실행되는 시점에는 아직 변수가 선언되기 이전이므로 참조 에러가 발생해야 한다. 하지만 undefined가 출력된다.</p>
<p>  👉🏻 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점 즉, 런타임이 아니라 그 이전 단계에서 먼저 실행된다는 증거</p>
</li>
</ul>
<h3 id="✅-변수-호이스팅"><a href="#✅-변수-호이스팅" class="headerlink" title="✅ 변수 호이스팅"></a>✅ 변수 호이스팅</h3><p>: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징</p>
<p>(변수 선언 뿐 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. <strong>모든 선언문은 런타임 이전 단계에서 실행되기 때문이다.</strong>)</p>
<h2 id="값의-할당"><a href="#값의-할당" class="headerlink" title="값의 할당"></a>값의 할당</h2><p>🖥 <strong>변수에 값을 할당할 때</strong>는 할당 연산자 &#x3D;를 사용한다.</p>
<ul>
<li>할당 연산자는 우변의 값을 좌변에 변수에 할당한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>변수 선언</strong>과 <strong>값의 할당</strong>을 다음과 같이 하나의 문으로 단축 표현할 수도 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>변수 선언과 값의 할당을 2개의 문으로 나누어 표현한 코드와 변수 선언과 값의 할당을 하나의 문으로 단축표현한 코드는 정확히 동일하게 동작한다.</li>
<li>즉, 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.</li>
</ul>
<p>📚 <strong>이때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다.</strong></p>
<p>변수 선언 👉🏻 소스코드가 실행되는 시점인 런타임 이전에 먼저 실행</p>
<p>값의 할당 👉🏻 소스코드가 순차적으로 실행되는 시점인 런타임에 실행</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score;  <span class="comment">// ① 변수 선언</span></span><br><span class="line">score = <span class="number">80</span>; <span class="comment">// ② 값의 할당</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>① 변수 선언 👉🏻 런타임 이전에 먼저 실행</li>
<li>② 값의 할당 👉🏻 런타임에 실행</li>
<li>따라서  score 변수에 값을 할당하는 시점(②)에는 이미 변수 선언이 완료된 상태이며, 이미 undefined로 초기화되어 있다.</li>
<li>따라서 변수에 undefined가 할당되어 초기화되는 것은 변함이 없다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/arthur/post/2e649c6b-9851-4940-a03f-b7bcdb52a1fc/image.png" alt="https://velog.velcdn.com/images/arthur/post/2e649c6b-9851-4940-a03f-b7bcdb52a1fc/image.png"></p>
<ul>
<li>변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고</li>
<li>그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 <strong>새로운 메모리 공간을 확보</strong>하고 <strong>그 곳에 할당 값 80을 저장</strong>한다.</li>
</ul>
<p>✨ <strong>변수가 어떻게 생성되며 호이스팅은 어떻게 이루어질까?</strong></p>
<ol>
<li>선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.</li>
<li>초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.</li>
<li>할당 단계: undefined로 초기화된 변수에 실제값을 할당한다.</li>
</ol>
<ul>
<li>var키워드로 선언된 변수는 선언 단계와 초기화 단계가 한 번에 이루어 진다.</li>
<li>즉 스코프에 변수가 등록되고 변수는 메모리 공간을 확보한 후 undefined로 초기화된다.</li>
<li>따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 👉🏻 이러한 현상을 <strong>변수 호이스팅</strong>이라고 한다.</li>
</ul>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bad11c1-9046-47e0-97c3-0316b7b1c99e/Untitled.png" alt="Untitled"></p>
<p>자바스크립트의 변수는 다른 C-family와는 달리 **블록 레벨 스코프(block-level scope)**를 가지지 않고 **함수 레벨 스코프(function-level scope)**를 갖는다.</p>
<p>단, ES6에서 도입된 let, const 키워드를 사용하면 블록 레벨 스코프를 사용할 수 있다.</p>
<p>✅ <strong>함수 레벨 스코프</strong></p>
<p>: 함수 내에서 선언된 변수는 함수 내에서만 유효하며 외부에서는 사용할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.</p>
<p>✅ <strong>블록 레벨 스코프</strong></p>
<p>: 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.</p>
<h2 id="값의-재할당"><a href="#값의-재할당" class="headerlink" title="값의 재할당"></a>값의 재할당</h2><p><strong>✅ 재할당</strong></p>
<p>: 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것</p>
<p>🙌🏻 score 변수에 새로운 값을 할당해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">score = <span class="number">80</span>; <span class="comment">// 값의 할당</span></span><br><span class="line"><span class="keyword">var</span> score;  <span class="comment">// 변수 선언</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>var 키워드로 선언한 변수는 값을 재할당할 수 있다.</strong></p>
<ul>
<li>재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다.</li>
<li>var 키워드로 선언한 변수는 <strong>선언과 동시에 undefined로 초기화</strong>되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.</li>
<li>재할당은 변수에 저장된 값을 다른 값으로 변경 👉🏻 그래서 변수인것</li>
<li>만약 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면? 👉🏻 <strong>상수(constant)</strong><ul>
<li>상수는 단 한 번만 할당할 수 있는 변수다.</li>
</ul>
</li>
</ul>
<p><strong>✨ const 키워드</strong></p>
<p>ES6에서 도입된 const 키워드를 사용해 선언한 변수는 재할당이 금지된다.</p>
<p>👉🏻 즉, const 키워드는 단 한 번만 할당할 수 있는 변수를 선언한다. 따라서 const 키워드를 사용하면 상수를 표현할 수 있다. 하지만 const 키워드는 반드시 상수만을 위해 사용하지 않는다.</p>
<ul>
<li>변수에 값을 할당하면 score 변수의 값은? 👉🏻 이전 값 80에서 재할당한 값 90으로 변경</li>
<li>처음 값을 할당했을 때와 마찬가지로 이전 값 80이 저장되어 메모리 공간을 지우고 그 메모리 공간에 재할당 값 90을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/arthur/post/d4c7e2a3-0e42-42bf-8efc-d58508e936cf/image.png" alt="https://velog.velcdn.com/images/arthur/post/d4c7e2a3-0e42-42bf-8efc-d58508e936cf/image.png"></p>
<ol>
<li>현재 변수의 값은? 👉🏻 90</li>
<li>score 변수의 이전 값인 undefined와 80은 어떤 변수도 값으로 갖고 있지 않다. 👉🏻 어떤 식별자와도 연결되어 있지 않다.</li>
<li><strong>undefined와 80이 더 이상 필요하지 않다는 것을 의미 👉🏻</strong> 이러한 불필요한 값들은 <strong>가비지 콜렉터</strong>에 의해 메모리에서 메모리에서 자동 해제된다. (단, 메모리에서 언제 해제될지는 예측할 수 없다.)</li>
</ol>
<p><strong>✨ 가비지 콜렉터(garbage collector)</strong></p>
<p><a href="https://fe-developers.kakaoent.com/2022/220519-garbage-collection/">자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식</a></p>
<p><strong>✨ 언매니지드 언어와 매니지드 언어</strong></p>
<p>프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지든 언어로 분류할 수 있다.</p>
<ul>
<li>언매니지드 언어<ul>
<li>개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc()과 free() 같은 저수준 메모리 제어 기능을 제공한다.</li>
<li>메모리 제어를 개발자가 주도할 수 있으므로 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만</li>
<li>치명적 오류를 생산할 가능성도 있다.</li>
</ul>
</li>
<li>매니지드 언어<ul>
<li>메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 집적적인 메모리 제어를 허용하지 않는다.</li>
<li>개발자가 명시적으로 메로리를 할당하고 해제할 수 없다.</li>
<li>더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행하며, 이 또한 개발자가 관여할 수 없다.</li>
<li>개발자의 역량에 의존한느 부분이 상대적으로 적어 어느정도 일정한 생산성을 확보할 수 있다.</li>
<li>성능 면에서 어느 정도의 손실은 감수할 수밖에 없다.</li>
</ul>
</li>
</ul>
<h2 id="식별자-네이밍-규칙"><a href="#식별자-네이밍-규칙" class="headerlink" title="식별자 네이밍 규칙"></a>식별자 네이밍 규칙</h2><p><strong>✅ 식별자</strong></p>
<p>: 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름</p>
<p>🔥 <strong>식별자는 네이밍 규칙을 준수해야한다.</strong></p>
<ul>
<li>식별자는 특수문자를 제외한 **문자, 숫자, 언더스코어(_), 달러 기호($)**를 포함할 수 있다.</li>
<li>단, 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러기호($)로 시작해야한다.</li>
<li>숫자로 시작하는 것은 허용하지 않는다.</li>
<li>예약어는 식별자로 사용할 수 없다.</li>
</ul>
<p><strong>🔥 변수 이름도 식별자이므로 네이밍 규칙을 따라야 한다.</strong></p>
<ul>
<li>변수는 쉼표(,)로 구분해 하나의 문에서 여러 개를 한 번에 선언할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person, $elem, _name, first_name, val1;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES5부터 식별자를 만들 때 유니코드 문자를 허용하므로 알파벳 외의 한글이나 일본어 식별자도 사용할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 이름, なまえ;</span><br></pre></td></tr></table></figure>

<ul>
<li>다음 식별자는 명명 규칙에 위배되므로 변수 이름으로 사용할 수 없다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first-name; <span class="comment">// SyntaxError: Unexpected token –</span></span><br><span class="line"><span class="keyword">var</span> 1st;        <span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">this</span>;       <span class="comment">// SyntaxError: Unexpected token this</span></span><br></pre></td></tr></table></figure>

<ul>
<li>자바스크립트는 <strong>대소문자를 구별</strong>하므로 다음 변수는 각각 별개의 변수다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstname;</span><br><span class="line"><span class="keyword">var</span> firstName;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">FIRSTNAME</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;       <span class="comment">// NG. x 변수가 의미하는 바를 알 수 없다.</span></span><br><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>; <span class="comment">// OK. score 변수는 점수를 의미한다.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 경과 시간. 단위는 날짜다</span></span><br><span class="line"><span class="keyword">var</span> d;                 <span class="comment">// NG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elapsedTimeInDays; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 네이밍 컨벤션</strong></p>
<p>: 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한 눈에 구문하기 위해 규정한 명명 규칙</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 카멜 케이스 (camelCase)</span></span><br><span class="line"><span class="keyword">var</span> firstName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스네이크 케이스 (snake_case)</span></span><br><span class="line"><span class="keyword">var</span> first_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파스칼 케이스 (PascalCase)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">FirstName</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 헝가리언 케이스 (typeHungarianCase)</span></span><br><span class="line"><span class="keyword">var</span> strFirstName; <span class="comment">// type + identifier</span></span><br><span class="line"><span class="keyword">var</span> $elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myId&#x27;</span>); <span class="comment">// DOM 노드</span></span><br><span class="line"><span class="keyword">var</span> observable$ = <span class="title function_">fromEvent</span>(<span class="variable language_">document</span>, <span class="string">&#x27;click&#x27;</span>); <span class="comment">// RxJS 옵저버블</span></span><br></pre></td></tr></table></figure>

<ul>
<li>자바스크립트에서 일반적으로 변수나 함수의 이름에는 👉🏻 카멜 케이스</li>
<li>생성자 함수, 클래스 이름에는 👉🏻 파스칼 케이스</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>표현식과 문</title>
    <url>/2022/221020-archive/</url>
    <content><![CDATA[<h2 id="값"><a href="#값" class="headerlink" title="값"></a>값</h2><h3 id="✅-값"><a href="#✅-값" class="headerlink" title="✅ 값"></a>✅ 값</h3><p>: <strong>표현식</strong>이 평가되어 생성된 결과</p>
<p>✅ <strong>평가</strong></p>
<p>: 식을 해석해서 값을 생성하거나 참조하는 것</p>
<p>🙌🏻 다음 예제의 식은 평가되어 숫자 값 30을 생성한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10 + 20은 평가되어 숫자 값 30을 생성한다.</span></span><br><span class="line"><span class="number">10</span> + <span class="number">20</span>; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p><strong>🖥 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다.</strong></p>
<ul>
<li><p>메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.</p>
</li>
<li><p>예를 들어, 메모리에 저장된 값 0100 0001을</p>
<ul>
<li>숫자로 해석하면? 👉🏻 65</li>
<li>문자로 해석하면? 👉🏻 ”A”</li>
</ul>
</li>
<li><p>변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름</p>
<p>  ➡️ 따라서 변수에 할당되는 것은 값이다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">10</span> + <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>위 예제의 sum 변수에 할당되는 것 👉🏻 10 + 20이 아니라 <strong>10 + 20이 평가된 결과인 숫자 값 30</strong></p>
<p>  ➡️즉, 변수 이름 sum이 기억하는 메모리 공간에 저장된 것은 값 30이다.</p>
</li>
</ul>
<p>🔥 <strong>값은 다양한 방법으로 생성할 수 있다.</strong></p>
<p>➡️ 식으로 생성할 수도 있지만, 가장 기본적인 방법은 <strong>리터럴</strong>을 사용하는 것이다.</p>
<h2 id="리터럴"><a href="#리터럴" class="headerlink" title="리터럴"></a>리터럴</h2><h3 id="✅-리터럴"><a href="#✅-리터럴" class="headerlink" title="✅ 리터럴"></a>✅ 리터럴</h3><p>: 사람이 이해할 수 있는 <strong>문자 또는 약속된 기호</strong>를 사용해 <strong>값을 생성</strong>하는 표기법</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 숫자 리터럴 3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3은 단순한 아라비아 숫자가 아니라 <strong>숫자 리터럴</strong>이다.</li>
<li>사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 코드에 기술하면 ➡️ 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성한다.</li>
</ul>
<p>🖥 <strong>리터럴을 사용하면 다양한 종류의 값을 생성할 수 있다.</strong></p>
<table>
<thead>
<tr>
<th>리터럴</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td>정수 리터럴</td>
<td>100</td>
</tr>
<tr>
<td>부동소수점 리터럴</td>
<td>10.5</td>
</tr>
<tr>
<td>2진수 리터럴</td>
<td>0b0100001</td>
</tr>
<tr>
<td>8진수 리터럴</td>
<td>0o101</td>
</tr>
<tr>
<td>16진수 리터럴</td>
<td>0x41</td>
</tr>
<tr>
<td>문자열 리터럴</td>
<td>“Hello”, “World”</td>
</tr>
<tr>
<td>불리언 리터럴</td>
<td>true, false</td>
</tr>
<tr>
<td>null 리터럴</td>
<td>null</td>
</tr>
<tr>
<td>undefined 리터럴</td>
<td>undefined</td>
</tr>
<tr>
<td>객체 리터럴</td>
<td>{ name: “Lee”, address: “Seoul” }</td>
</tr>
<tr>
<td>배열 리터럴</td>
<td>[1, 2, 3]</td>
</tr>
<tr>
<td>함수 리터럴</td>
<td>function(){}</td>
</tr>
<tr>
<td>정규 표현식 리터럴</td>
<td>&#x2F;[A-Z]+&#x2F;g</td>
</tr>
</tbody></table>
<h2 id="표현식"><a href="#표현식" class="headerlink" title="표현식"></a>표현식</h2><h3 id="✅-표현식"><a href="#✅-표현식" class="headerlink" title="✅ 표현식"></a>✅ 표현식</h3><p>: <strong>값으로 평가될 수 있는 문</strong>, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.</p>
<ul>
<li>표현식은 값으로 평가된다. 즉, 값으로 평가될 수 있는 문은 모두 표현식이다.</li>
<li>리터럴은? 👉🏻 값으로 평가된다. 따라서 리터럴도 표현식이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>위 예제의 100 👉🏻 리터럴</li>
<li>리터럴 100은? 👉🏻 자바스크립트 엔진에 의해 <strong>평가되어 값을 생성</strong>하므로 리터럴은 그 자체로 <strong>표현식</strong>이다.</li>
</ul>
<p>🙌🏻 다른 예제를 살펴보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">50</span> + <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>50 + 50은 👉🏻 <strong>리터럴</strong>과 <strong>연산자</strong>로 이루어져 있다.</li>
<li>하지만 50 + 50도 평가되어 <strong>숫자 값 100을 생성</strong>하므로 <strong>표현식</strong>이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">score;</span><br></pre></td></tr></table></figure>

<ul>
<li>변수 식별자를 참조하면 변수 값으로 평가된다.</li>
<li>식별자 참조 👉🏻 값을 생성하지는 않지만 <strong>값으로 평가</strong>되므로 <strong>표현식</strong>이다.</li>
</ul>
<p>🔥 <strong>표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.</strong></p>
<ul>
<li>다양한 표현식이 있지만 값으로 평가된다는 점에서 모두 동일하다.</li>
<li><strong>값으로 평가되는 문</strong>은 모두 표현식이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 리터럴 표현식</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 식별자 표현식(선언이 이미 존재한다고 가정)</span></span><br><span class="line">sum</span><br><span class="line">person.<span class="property">name</span></span><br><span class="line">arr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 표현식</span></span><br><span class="line"><span class="number">10</span> + <span class="number">20</span></span><br><span class="line">sum = <span class="number">10</span></span><br><span class="line">sum !== <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)</span></span><br><span class="line"><span class="title function_">square</span>()</span><br><span class="line">person.<span class="title function_">getName</span>()</span><br></pre></td></tr></table></figure>

<p><strong>💡 표현식은 값으로 평가된다.</strong></p>
<ul>
<li><p>이때 표현식과 표현식이 평가된 값은 동등한 관계다.</p>
<ul>
<li>예를 들어, 수학 수식 1 + 2 &#x3D; 3에서 1 + 2는 3과 동치다.</li>
<li>즉, 1 + 2는 3과 같다고 할 수 있다.</li>
</ul>
</li>
<li><p>자바스크립트의 표현식 1 + 2는 평가되어 값 3을 생성하므로 표현식 1 + 2와 3은 동치다.</p>
<p>  <strong>➡️ 따라서 표현식은 값처럼 사용할 수 있다.</strong></p>
</li>
</ul>
<p><strong>📚 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.</strong></p>
<ul>
<li>예를 들어, 산술 연산자 +의 좌항과 우항에는 숫자 값이 위치해야한다.</li>
<li>이때 <strong>숫자 값으로 평가될 수 있는 표현식</strong>이라면 👉🏻 숫자 값 대신 사용할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 식별자 표현식 x는 3으로 평가된다.</span></span><br><span class="line">x + <span class="number">3</span>; <span class="comment">// -&gt; 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 예제의 x + 3은? 👉🏻 표현식</li>
<li><ul>
<li>연산자는 좌항과 우항의 값을 산술 연산하는 연산자이므로 좌항과 우항에는 숫자 값이 위치해야 함<ul>
<li>이때 좌항 x는 식별자 표현식 👉🏻 x는 할당되어 있는 숫자 값 3으로 평가한다.</li>
</ul>
</li>
</ul>
</li>
<li>이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.</li>
</ul>
<h2 id="문"><a href="#문" class="headerlink" title="문"></a>문</h2><p>🔥 문과 표현식을 구별하고 해석하기</p>
<h3 id="✅-문"><a href="#✅-문" class="headerlink" title="✅ 문"></a>✅ 문</h3><p>: <strong>프로그램을 구성</strong>하는 <strong>기본 단위</strong>이자 <strong>최소실행 단위</strong></p>
<ul>
<li>문의 집합으로 이루어진 것 👉🏻 프로그램이며</li>
<li>문을 작성하고 순서에 맞게 나열하는 것 👉🏻 프로그래밍이다.</li>
</ul>
<p>문은 여러 <strong>토큰</strong>으로 구성된다.</p>
<p>✅ <strong>토큰</strong></p>
<p>: 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본요소</p>
<ul>
<li>키워드, 식별자, 연산자, 리터럴, 세미콜론이나 마침표 등의 특수기호는 기본 요소를 의미한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/kozel/post/7a45d92d-ecf6-45a6-b90c-cfb6835d3c5a/image.jpeg" alt="https://velog.velcdn.com/images/kozel/post/7a45d92d-ecf6-45a6-b90c-cfb6835d3c5a/image.jpeg"></p>
<p>💡 <strong>문은 컴퓨터에게 내리는 명령으로, 명령문이라고도 부른다.</strong></p>
<ul>
<li>문이 실행되면 ➡️ 명령이 실행되고 무슨일인가가 일어난다.</li>
</ul>
<p><strong>📚 문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.</strong></p>
<ul>
<li>변수 선언문을 실행하면 👉🏻 변수가 선언</li>
<li>할당문을 실행하면 👉🏻 값이 할당</li>
<li>조건문을 실행하면 👉🏻 지정한 조건에 따라 실행할 코드블록({…})이 결정되어 실행</li>
<li>반복문을 실행하면 👉🏻 특정 코드 블록이 반복 실행</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식 문(할당문)</span></span><br><span class="line">x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 조건문</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복문</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="세미콜론과-세미콜론-자동-삽입-기능"><a href="#세미콜론과-세미콜론-자동-삽입-기능" class="headerlink" title="세미콜론과 세미콜론 자동 삽입 기능"></a>세미콜론과 세미콜론 자동 삽입 기능</h2><p>💡 <strong>세미콜론(;)은 문의 종료를 나타낸다.</strong></p>
<ul>
<li>자바스크립트 엔진이 <strong>문의 종료 위치를 파악</strong>하고 순차적으로 하나씩 문을 실행하기 때문에 문을 끝낼 때는 세미콜론을 붙여야 한다.</li>
<li>단, 0개 이상의 문을 중괄호로 묶은 코드 블록({ … })은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문에 붙이지 않는다.</li>
</ul>
<blockquote>
<p>물론 필수는 아니다. 자바스크립트에서 문의 끝에 붙이는 세미콜론은 옵션이므로 생략 가능하다. 이는 자바스크립트 엔진이 소스코드를 해석 할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI) 이 암묵적으로 수행되기 때문이다.</p>
</blockquote>
<p>하지만 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 간혹 있고 다수의 주장이 세미콜론을 붙여야 한다고 주장하니, 붙이는 습관을 들이는 것을 추천한다.</p>
<h2 id="표현식인-문과-표현식이-아닌-문"><a href="#표현식인-문과-표현식이-아닌-문" class="headerlink" title="표현식인 문과 표현식이 아닌 문"></a>표현식인 문과 표현식이 아닌 문</h2><p><strong>🔥 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.</strong></p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="comment">// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.</span></span><br><span class="line"><span class="comment">// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.</span></span><br><span class="line">x = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>🖥 <strong>문에는 표현식인 문과 표현식이 아닌문이 있다.</strong></p>
<ul>
<li>표현식인 문 👉🏻 값으로 평가될 수 있는 문</li>
<li>표현식이 아닌 문 👉🏻 값으로 평가될 수 없는 문</li>
<li>변수 선언문은? ➡️ 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다.</li>
<li>할당문은? ➡️ 값으로 평가될 수 있다. 따라서 표현식인 문이다.</li>
</ul>
<p><strong>🖥 표현식과 문을 구별하는 방법 👉🏻 변수에 할당해 보는 것</strong></p>
<p>표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.</p>
<p>하지만 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다.</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표현식이 아닌 문은 값처럼 사용할 수 없다.</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">var</span> x; <span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>변수 선언문 👉🏻 표현식이 아닌 문</p>
<p>  ➡️ 값으로 평가될 수 없다. 따라서 변수 선언문은 값처럼 사용할 수 없다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문은 표현식이 아닌 문이다.</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.</span></span><br><span class="line">x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>할당문 x &#x3D; 100 👉🏻 그 자체가 표현식</p>
<p>  ➡️ 즉, 할당문은 표현식인 문이기 때문에 값처럼 사용할 수 있다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표현식인 문은 값처럼 사용할 수 있다</span></span><br><span class="line"><span class="keyword">var</span> foo = x = <span class="number">100</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>할당문을 값처럼 변수에 할당했다.</p>
</li>
<li><p>표현식인 문인 할당문 👉🏻 할당 값으로 평가된다.</p>
<p>  ➡️ 즉, x &#x3D; 100은 x 변수에 할당한 값 100으로 평가된다. 따라서 foo 변수에는 100이 할당된다.</p>
</li>
</ul>
<p><strong>✨ 완료 값(completion value)</strong></p>
<p>크롬 개발자 도구에서 <strong>표현식이 아닌 문을 실행</strong>하면 <strong>언제나 undefined를 반환</strong>한다. 👉🏻 <strong>완료 값</strong></p>
<p>완료 값은 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, World!</title>
    <url>/2022/hello-world-0/</url>
    <content><![CDATA[<h2 id="🙌-안녕-GitHub-블로그"><a href="#🙌-안녕-GitHub-블로그" class="headerlink" title="🙌 안녕, GitHub 블로그!"></a>🙌 안녕, GitHub 블로그!</h2><p>여태 Notion으로 공부한 내용을 정리하다가 github 블로그로 넘어오게되었다.<br>그 이유는.. 모두에게 공개되는 github에 글을 작성했을 때, 더 신중하게 작성할 수 &gt;있을 것이라는 생각에 바로 github으로 변경했다.</p>
<h3 id="📒-영어공부의-필요성을-느끼는-중입니다"><a href="#📒-영어공부의-필요성을-느끼는-중입니다" class="headerlink" title="📒 영어공부의 필요성을 느끼는 중입니다."></a>📒 영어공부의 필요성을 느끼는 중입니다.</h3><p>최근 공부를 하면서 모르는 개념이 생길 때마다 공식 문서를 찾아보는데 문서를 볼 때마다 제대로 된 이해를 하지 못하는 것 같은 느낌이 들었다. 개발 관련된 단어라도 알고 있으면 이해가 수월하지 않을까? 라는 생각이 드는 찰나에 meot님의 개발 용어 레포지토리를 찾았다! 이것부터 차근차근 열심히 영어공부를 해보자..!</p>
<h3 id="✨-공부한-내용-기록하기"><a href="#✨-공부한-내용-기록하기" class="headerlink" title="✨ 공부한 내용 기록하기"></a>✨ 공부한 내용 기록하기</h3><p>TIL 이외의 내용들은 모두 이 곳에 기록해두자.<br>아직 미완성된 블로그이지만 글도 많이 쌓이고 기능도 조금씩 고쳐나가면 좋은 블로그가 되지 않을까:)<br>~<br>~-</p>
]]></content>
      <tags>
        <tag>IT</tag>
        <tag>Web</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터 타입 - 자바스크립트는 동적 타입 언어다.</title>
    <url>/2022/221023-archive/</url>
    <content><![CDATA[<p>🔥 <strong>자바스크립트는 동적 타입 언어이다.</strong></p>
<p>변수의 타입 지정없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정된다.</p>
<p>데이터 타입은 프로그래밍 언어에서 사용할 수 있는 데이터의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. ES6는 7개의 데이터 타입을 제공한다.</p>
<p><img src="https://velog.velcdn.com/images/kozel/post/9890a85e-2e2e-478a-9bb7-c3ff43645b11/image.jpeg" alt="https://velog.velcdn.com/images/kozel/post/9890a85e-2e2e-478a-9bb7-c3ff43645b11/image.jpeg"></p>
<ul>
<li>숫자 타입의 값 1과 문자열 타입의 값 “1”은 비슷해보이지만 전혀 다른 값이다. ➡️ 생성한 목적과 용독가 다름<ul>
<li>숫자 타입의 값 👉🏻 산술 연산을 위해 생성</li>
<li>문자 타입의 값 👉🏻 주로 텍스트 화면에 출력하기 위해 생성</li>
</ul>
</li>
<li>확보해야 할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 해석하는 방식도 다르다.</li>
</ul>
<h2 id="숫자-타입"><a href="#숫자-타입" class="headerlink" title="숫자 타입"></a>숫자 타입</h2><p>ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다.</p>
<p>👉🏻 즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 모두 숫자 타입이다.</span></span><br><span class="line"><span class="keyword">var</span> integer = <span class="number">10</span>; <span class="comment">// 정수</span></span><br><span class="line"><span class="keyword">var</span> double = <span class="number">10.12</span>; <span class="comment">// 실수</span></span><br><span class="line"><span class="keyword">var</span> negative = -<span class="number">20</span>; <span class="comment">// 음의 정수</span></span><br></pre></td></tr></table></figure>

<ul>
<li>정수, 실수, 2진수, 8진수, 16진수 리터럴 👉🏻 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.</li>
<li>자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 값을 참조하면 10진수로 해석된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> binary = <span class="number">0b01000001</span>; <span class="comment">// 2진수</span></span><br><span class="line"><span class="keyword">var</span> octal = <span class="number">0o101</span>; <span class="comment">// 8진수</span></span><br><span class="line"><span class="keyword">var</span> hex = <span class="number">0x41</span>; <span class="comment">// 16진수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표기법만 다를 뿐 모두 같은 값이다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binary); <span class="comment">// 65</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(octal); <span class="comment">// 65</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hex); <span class="comment">// 65</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binary === octal); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(octal === hex); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>🖥 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다.</strong></p>
<p>➡️ 이는 정수로 표시된다 해도 사실은 실수라는 것을 의미한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 숫자 타입은 모두 실수로 처리된다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> === <span class="number">1.0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span> / <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> / <span class="number">2</span>); <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure>

<p>📚 <strong>추가적으로 3가지 특별한 값들도 표현할 수 있다.</strong></p>
<ul>
<li><code>Infinity</code> : 양의 무한대</li>
<li><code>Infinity</code> : 음의 무한대</li>
<li><code>NaN</code> : 산술 연산 불가(not-a-number)</li>
</ul>
<p>💡 <strong>자바스크립트는 대소문자를 구별하기 때문에 NAN, Nan, nan을 값이 아닌 식별자로 해석한다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 자바스크립트는 대소문자를 구별한다.</span></span><br><span class="line"><span class="keyword">var</span> x = nan; <span class="comment">// ReferenceError: nan is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><ul>
<li>문자열 타입은 텍스트 데이터를 나타내는 데 사용한다.</li>
<li>문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 타입</span></span><br><span class="line"><span class="keyword">var</span> string;</span><br><span class="line">string = <span class="string">&#x27;문자열&#x27;</span>; <span class="comment">// 작은따옴표</span></span><br><span class="line">string = <span class="string">&#x27;문자열&#x27;</span>; <span class="comment">// 큰따옴표</span></span><br><span class="line">string = <span class="string">`문자열`</span>; <span class="comment">// 백틱 (ES6)</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">&#x27;작은따옴표로 감싼 문자열 내의 &quot;큰따옴표&quot;는 문자열로 인식된다.&#x27;</span>;</span><br><span class="line">string = <span class="string">&quot;큰따옴표로 감싼 문자열 내의 &#x27;작은따옴표&#x27;는 문자열로 인식된다.&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유 ➡️ 키워드나 식별자와 같은 토큰과 구분하기 위해서</li>
<li>자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값이다.<br>👉🏻 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.</li>
</ul>
<p>✨ <strong>부동소수점이란?</strong></p>
<p>console.log(0.1 + 0.2)의 결과값이 무엇일까? 결과는 0.30000000004가 나온다.</p>
<p>그렇다면 console.log(0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3)의 결과는? 👉🏻 당연히 false가 나오게 된다.</p>
<p>원시 타입 중 숫자 타입의 정수, 실수, 2진수, 8진수, 16진수, 리터럴 등은 <strong>배정밀도 64비트 부동소수점 형식의 2진수</strong>로 저장된다.</p>
<p>✅ <strong>부동소수점(floating point)</strong></p>
<p>: 컴퓨터가 실수를 표현하는 방법(.이 부표처럼 앞뒤로 이동한다고 해서 부동이라는 이름이 붙었다.)</p>
<p>9.625가 이진법으로 표현하면 1001.101로 표현되는데 부동소수점은 1.001101의 형식으로 변환한다. 1001.101이 1.001101처럼 되려면 소수점이 왼쪽으로 세 칸 이동해야한다. 그래서 소숫점이 떠서 움직여야한다고 표현하는 것이다.</p>
<h2 id="문자열-타입-1"><a href="#문자열-타입-1" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><p>텍스트 데이터를 나타내는데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.</p>
<p>C와 같은 언어와는 다르게, 자바스크립트의 문자열은 원시 타입이며 변경 불가능(immutable)하다. 이것은 한 번 문자열이 생성되면, 그 문자열을 변경할 수 없다는 것을 의미한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>첫 번째 구문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 메모리에 생성된 문자열 ‘Hello’의 메모리 주소를 가리킨다.</p>
<p>그리고 두 번째 구문이 실행되면 이저에 생성된 문자열을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다.</p>
<p>변수 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경되었을 뿐이다.</p>
<p>문자열은 배열 처럼 인덱스를 통해 접근할 수 있다. 이와 같은 특성을 갖는 데이터를 <strong>유사 배열</strong>이라 한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="comment">// 문자열은 유사배열이다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 변경할 수 없다.</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p><code>str[0] = &#39;S&#39;</code>처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다(이때 에러가 발생하지 않는다). 한번 생성된 문자열은 read only로서 변경할 수 없다. 이것을 변경 불가능(immutable)이라 한다.</p>
<p>그러나 새로운 문자열을 재할당하는 것은 물론 가능하다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문이다. <code>👉문자열과 불변성</code></p>
<h2 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h2><ul>
<li>ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.<ul>
<li>멀티라인 문자열</li>
<li>표현식 삽입</li>
<li>태그드 템플릿</li>
</ul>
</li>
<li>템플릿 리터럴은 일반 문자열과 비슷해 보이지만 백틱을 사용해 표현한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello</span></span><br><span class="line"><span class="string">world.&#x27;</span>;</span><br><span class="line"><span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<h3 id="1-멀티라인-문자열"><a href="#1-멀티라인-문자열" class="headerlink" title="1. 멀티라인 문자열"></a>1. <strong>멀티라인 문자열</strong></h3><p>🔥 <strong>일반 문자열 내에서는 줄바꿈이 허용되지 않는다.</strong></p>
<p>➡️ 따라서 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 👉🏻 백슬래시로 시작하는 <strong>이스케이프 시퀀스</strong>를 사용해야 한다.</p>
<p><img src="https://velog.velcdn.com/images/kozel/post/cf106d59-c4cb-4e53-a3f6-ba7668ab1d78/image.jpeg" alt="https://velog.velcdn.com/images/kozel/post/cf106d59-c4cb-4e53-a3f6-ba7668ab1d78/image.jpeg"></p>
<p>✨ <strong>라인 피드와 캐리지 리턴</strong></p>
<p>과거 타자기에서 커서를 제어하는 방식에서 비롯되었다.</p>
<ul>
<li><p>라인 피드(\n): 커서를 정지한 상태에서 종이를 한 줄 올리는 것</p>
</li>
<li><p>캐리지 리턴(\r): 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것</p>
</li>
<li><p>자바스크립트에서는 라인 피드와 캐리지 리턴 모두 개행을 의미한다.</p>
</li>
<li><p>줄바꿈과 들여쓰기가 적용된 HTML 문자열은 다음과 같이 이스케이프 시퀀스를 사용해 작성한다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;&lt;ul&gt;**\n\t**&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;**\n**&lt;/ul&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(template);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(template);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-표현식-삽입"><a href="#2-표현식-삽입" class="headerlink" title="2. 표현식 삽입"></a>2. <strong>표현식 삽입</strong></h3><p>🖥 <strong>문자열은 문자열 연산자 +를 사용해 연결할 수 있다.</strong></p>
<ul>
<li>+연산자 👉🏻 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="string">&#x27;Ung-mo&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5: 문자열 연결</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My name is &#x27;</span> + first + <span class="string">&#x27; &#x27;</span> + last + <span class="string">&#x27;.&#x27;</span>); <span class="comment">// My name is Ung-mo Lee.</span></span><br></pre></td></tr></table></figure>

<p>📚 <strong>템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있다.</strong></p>
<ul>
<li>이를 통해 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="string">&#x27;Ung-mo&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6: 표현식 삽입</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span>); <span class="comment">// My name is Ung-mo Lee.</span></span><br></pre></td></tr></table></figure>

<p>💡 <strong>표현식을 삽입하려면 ${}으로 표현식을 감싼다.</strong></p>
<ul>
<li>이때 표현식의 <strong>평가 결과가 문자열이 아니더라도</strong> 문자열로 타입이 강제로 변환되어 삽입된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`1 + 2 = <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span>); <span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다.<ul>
<li>템플릿 리터럴이 아닌 일반 문자열에서의 표현식 삽입 👉🏻 문자열로 취급된다.<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1 + 2 = $&#123;1 + 2&#125;&#x27;</span>); <span class="comment">// 1 + 2 = $&#123;1 + 2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="불리언-타입"><a href="#불리언-타입" class="headerlink" title="불리언 타입"></a>불리언 타입</h2><p>불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 <code>true</code>와 <code>false</code> 뿐이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof 연산자는 타입을 나타내는 문자열을 반환한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar); <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<h2 id="undefined-타입"><a href="#undefined-타입" class="headerlink" title="undefined 타입"></a>undefined 타입</h2><p>💡 <strong>undefined의 값은 undefined가 유일하다.</strong></p>
<ul>
<li>var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다.<br>➡️ 다시 말해 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화된다.</li>
<li>이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.</li>
<li>개발자가 변수 값이 없다는 것을 명시하고 싶을 때는? 👉🏻 null을 할당한다.</li>
</ul>
<p><strong>✨ 선언과 정의</strong></p>
<p>undefined를 직역하면 “정의되지 않은”이다.</p>
<ul>
<li>일반적으로 정의란? 👉🏻 어떤 대상을 명확하게 규정하는 것을 의미한다.</li>
<li>자바스크립트의 undefined에서 말하는 정의란? 👉🏻 변수에 값을 할당하여 변수의 실체를 명확히 하는 것</li>
</ul>
<h2 id="null-타입"><a href="#null-타입" class="headerlink" title="null 타입"></a>null 타입</h2><p>💡 <strong>null 타입은 null이 유일하다.</strong></p>
<ul>
<li>값이 없다는 것을 의도적으로 명시할 때 사용한다.</li>
<li>null을 할당하는 것 👉🏻 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.</li>
<li>이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미한다. 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management">가비지 콜렉션</a>을 수행할 것이다.</li>
</ul>
<h2 id="심벌-타입"><a href="#심벌-타입" class="headerlink" title="심벌 타입"></a>심벌 타입</h2><p>심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다. 심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Symbol은 고유한 존재 이기 때문에 문자열이 같아도 영향을 미치지 않는다.</span></span><br></pre></td></tr></table></figure>

<p>✨ <strong>object.key로 사용</strong></p>
<p>객체에서 Symbol로도 객체의 property를 만들 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cy&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[id]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Symbol을 key를 사용하여 데이터에 접근할 수 있다. 그러면 string을 사용하면 되지 왜 굳이 Symbol을 사용할까? 만약 obj 객체에 무수히 많은 프로퍼티가 있다고 가정해보자.</li>
<li>협업을 하다가 한 팀원이 obj객체에 name 속성이 있는지 모르고 name 속성을 추가해서 덮어씌어버린다면? 오류가 발생할 것이다.</li>
<li>이 속성값은 건들지 말아줘!하고 싶을 경우 Symbol을 사용한다. 같은 속성이름으로 값을 추가하더라도 Symbol은 다른 존재로 인식 하기 때문에 오류가 없을 것이다.</li>
</ul>
<p>참고자료)</p>
<p><a href="https://chaeyoung2.tistory.com/40">https://chaeyoung2.tistory.com/40</a></p>
<h2 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h2><p>객체는 데이터와 그 데이터에 관련한 동작을 모두 포함한다.</p>
<ul>
<li>이름과 값을 가지는 데이터: 프로퍼티(property)</li>
<li>그 데이터에 관련한 동작: 메서드(method)</li>
</ul>
<p>🔥 <strong>자바스크립트는 객체 기반의 스크립트 언어로서 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다.</strong></p>
<p>원시 타입(Primitives)을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체이다. 또한 객체는 <strong><a href="https://poiemaweb.com/js-object#4-pass-by-reference">pass-by-reference(참조에 의한 전달)</a></strong> 방식으로 전달된다.</p>
<h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2><ol>
<li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>
</ol>
<h3 id="1-데이터-타입에-의한-메모리-공간-확보와-참조"><a href="#1-데이터-타입에-의한-메모리-공간-확보와-참조" class="headerlink" title="1. 데이터 타입에 의한 메모리 공간 확보와 참조"></a>1. <strong>데이터 타입에 의한 메모리 공간 확보와 참조</strong></h3><p>값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수를 알아야 한다.</p>
<p>🤔 <strong>그렇다면 컴퓨터는 한 번에 읽어 들여야 할 메모리 셀의 크기를 어떻게 알 수 있을까?</strong></p>
<p>➡️ 변수에 어떤 데이터 타입의 값이 할당되어 있는지 확인하고 메모리 공간을 확보한다.</p>
<p><img src="https://velog.velcdn.com/images/kozel/post/9d170f6a-db60-4bef-b5f5-282fadcd1d59/image.png" alt="https://velog.velcdn.com/images/kozel/post/9d170f6a-db60-4bef-b5f5-282fadcd1d59/image.png"></p>
<p>자바스크립트는 숫자 타입의 값을 생성할 때 배정밀도 64비트 부동소수점 형식을 사용한다. 따라서 실제로 메모리에 저장되는 2진수 값은 위 그림과 다르다.</p>
<p><strong>🔥 이번에는 참조의 경우를 생각해보자.</strong></p>
<ul>
<li>위의 예제에서 식별자 score를 통해 숫자 값 100이 저장되어 있는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있다.</li>
<li>이때 값을 참조하려면 한번에 읽어 들여야 할 메모리 셀의 개수(바이트 수)를 알아야한다.<ul>
<li>그러기 위해 자바스크립트 엔진은 score 변수의 값이 숫자 타입임을 인식하고 8바이트 단위로 메모리 공간에 저장된 값을 읽어 들인다.</li>
</ul>
</li>
</ul>
<h3 id="2-데이터-타입에-의한-값의-해석"><a href="#2-데이터-타입에-의한-값의-해석" class="headerlink" title="2. 데이터 타입에 의한 값의 해석"></a>2. <strong>데이터 타입에 의한 값의 해석</strong></h3><p>메모리에서 읽어들인 2진수를 어떻게 해석해야하는지에 대한 문제가 남아있다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.</p>
<ul>
<li>예를 들어 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 ‘A’다. 이렇게 같은 2진수여도 해석이 달라질 수 있다.</li>
<li>하지만 우리는 데이터 타입이 있고, 위의 예제에서 score 변수에 할당된 값은 숫자 타입의 값이므로 score 변수를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수를 숫자로 해석한다.</li>
</ul>
<p><strong>📚 데이터 타입이 필요한 이유는 다음과 같다.</strong></p>
<ul>
<li>값을 저장할 때 확보해야 하는 <strong>메모리 공간의 크기</strong>를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어 들여야 할 <strong>메모리 공간의 크기</strong>를 결정하기 위해</li>
<li>메모리에서 읽어 들인 <strong>2진수를 어떻게 해석</strong>할지 결정하기 위해</li>
</ul>
<h2 id="동적-타이핑"><a href="#동적-타이핑" class="headerlink" title="동적 타이핑"></a>동적 타이핑</h2><h3 id="1-동적-타입-언어와-정적-타입-언어"><a href="#1-동적-타입-언어와-정적-타입-언어" class="headerlink" title="1. 동적 타입 언어와 정적 타입 언어"></a>1. 동적 타입 언어와 정적 타입 언어</h3><p>✨ <strong>변수는 타입을 가질까?</strong></p>
<p>➡️ 결론부터 말하자면 변수는 타입을 갖지 않는다. <strong>하지만 값은 타입을 갖는다.</strong> 따라서 변수에 할당되어 있는 값에 의해 변수의 타입이 결정된다라고 표현하는 것이 적절하다.</p>
<p>🖥 <strong>정적 타입 언어</strong></p>
<p>변수를 선언할 때 변수에 할당할 수 있는 값의 종류를 사전에 선언해야 한다.(&#x3D; 명시적 타입 선언)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c 변수에는 1바이트 정수 타입의 값만 할당할 수 있다.</span></span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// num 변수에는 4바이트 정수 타입의 값만 할당할 수 있다.</span></span><br><span class="line">int num;</span><br></pre></td></tr></table></figure>

<p>변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적타입 언어는 컴파일 시점에 타입 체크를 수행한다. 만약 타입 체크를 통과하지 못했다면 에러를 발생시킨다.</p>
<p>🖥 <strong>동적 타입 언어</strong></p>
<p>자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3.14</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">&#x27;Hi&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트 변수에는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다.</p>
<ul>
<li>정적 타입 언어는 변수 선언 시점에 변수의 타입이 결정되고</li>
<li>자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정된다.</li>
</ul>
<p>➡️ 다시 말해, 자바스크립트의 변수는 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 <strong>동적 타이핑</strong>이라고 한다.</p>
<h3 id="2-동적-타입-언어와-변수"><a href="#2-동적-타입-언어와-변수" class="headerlink" title="2. 동적 타입 언어와 변수"></a>2. 동적 타입 언어와 변수</h3><p>동적 타입 언어는 변수에 대해 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.</p>
<p>👿 <strong>이러한 편리함 이면에는 위험이 있다.</strong></p>
<p>모든 소프트웨어 아키텍처에는 트레이드오프가 존재하며, 동적 타입 언어 또한 구조적인 단점이 있다.</p>
<ul>
<li>변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.</li>
<li>그뿐만 아니라 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.</li>
</ul>
<p><em>➡️ 따라서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.</em></p>
<p>🔥 <strong>변수를 사용할 때 주의할 사항은 다음과 같다.</strong></p>
<ul>
<li>변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.</li>
<li>변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.</li>
<li>전역 변수는 최대한 사용하지 않도록 한다.</li>
<li>변수보다는 상수를 사용해 값의 변경을 억제한다.</li>
<li>변수의 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>연산자</title>
    <url>/2022/221026-archive/</url>
    <content><![CDATA[<h3 id="✅-연산자"><a href="#✅-연산자" class="headerlink" title="✅ 연산자"></a>✅ 연산자</h3><p>: <strong>하나 이상의 표현식</strong>을 대상으로 산술, 할당, 비교, 논리, 차입, 지수 연산 등을 수행해 하나의 값을 만든다.</p>
<ul>
<li>이때 연산의 대상을 <strong>피연산자</strong>라 한다.</li>
<li>피연산자는 값으로 평가될 수 있는 표현식이어야 한다.</li>
</ul>
<p>➡️ 그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="number">5</span> * <span class="number">4</span>; <span class="comment">// -&gt; 20</span></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">&#x27;My name is &#x27;</span> + <span class="string">&#x27;Lee&#x27;</span>; <span class="comment">// -&gt; &#x27;My name is Lee&#x27;</span></span><br><span class="line"><span class="comment">// 할당 연산자</span></span><br><span class="line">color = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// -&gt; &#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// 비교 연산자</span></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 논리 연산자</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 타입 연산자</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;Hi&#x27;</span>; <span class="comment">// -&gt; string</span></span><br></pre></td></tr></table></figure>

<ul>
<li>피연산자 👉🏻 ”값”이라는 명사의 역할</li>
<li>연산자 👉🏻 ”피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할</li>
</ul>
<p>➡️ 다시 말해, 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다.</p>
<h2 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h2><h3 id="✅-산술-연산자"><a href="#✅-산술-연산자" class="headerlink" title="✅ 산술 연산자"></a>✅ 산술 연산자</h3><p>: 피연산자를 대항으로 <strong>수학적 계산</strong>을 수행해 새로운 숫자 값을 만든다.</p>
<ul>
<li>산술 연산이 불가능한 경우 👉🏻 NaN를 반환한다.</li>
</ul>
<h3 id="1-이항-산술-연산자"><a href="#1-이항-산술-연산자" class="headerlink" title="1. 이항 산술 연산자"></a>1. <strong>이항 산술 연산자</strong></h3><p>: <strong>2개의 피연산자</strong>를 산술 연산하여 숫자 값을 만든다.</p>
<ul>
<li>부수효과 👉🏻 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(Side effect)가 <strong>없다.</strong></li>
</ul>
<p>➡️ 다시 말해, 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 단지 <strong>새로운 값을 만들 뿐이다.</strong></p>
<table>
<thead>
<tr>
<th>이항 산술 연산자</th>
<th>의미</th>
<th>부수효과</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>덧셈</td>
<td>X</td>
</tr>
<tr>
<td>-</td>
<td>뺄셈</td>
<td>X</td>
</tr>
<tr>
<td>*</td>
<td>곱셈</td>
<td>X</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>나눗셈</td>
<td>X</td>
</tr>
<tr>
<td>%</td>
<td>나머지</td>
<td>X</td>
</tr>
</tbody></table>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> + <span class="number">2</span>; <span class="comment">// -&gt; 7</span></span><br><span class="line"><span class="number">5</span> - <span class="number">2</span>; <span class="comment">// -&gt; 3</span></span><br><span class="line"><span class="number">5</span> * <span class="number">2</span>; <span class="comment">// -&gt; 10</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>; <span class="comment">// -&gt; 2.5</span></span><br><span class="line"><span class="number">5</span> % <span class="number">2</span>; <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-단항-산술-연산자"><a href="#2-단항-산술-연산자" class="headerlink" title="2. 단항 산술 연산자"></a>2. <strong>단항 산술 연산자</strong></h3><p>: <strong>1개의 피연산자</strong>를 산술 연산하여 숫자 값을 만든다.</p>
<table>
<thead>
<tr>
<th>단항 산술 연산자</th>
<th>의미</th>
<th>부수 효과</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>증가</td>
<td>O</td>
</tr>
<tr>
<td>–</td>
<td>감소</td>
<td>O</td>
</tr>
<tr>
<td>+</td>
<td>어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.</td>
<td>X</td>
</tr>
<tr>
<td>-</td>
<td>양수를 음수로, 음수를 양수로 반전한 값을 반환한다.</td>
<td>X</td>
</tr>
</tbody></table>
<ul>
<li>부수효과 👉🏻 주의할 점은 이항 산술 연산자와는 달리 증가&#x2F;감소 연산자는 피연산자의 <strong>값을 변경하는 부수효과가 있다</strong>는 것이다.</li>
</ul>
<p>➡️ 다시 말해, 증가&#x2F;감소 연산을 하면 피연산자의 값을 변경하는 <strong>암묵적 할당</strong>이 이뤄진다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.</span></span><br><span class="line">x++; <span class="comment">// x = x + 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.</span></span><br><span class="line">x--; <span class="comment">// x = x - 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>증가·감소 연산자는 변수에만 쓸 수 있다. <code>5++</code>와 같이 값에 사용하려고 하면 에러가 발생한다.<ul>
<li><strong>증가 연산자</strong>: <code>++</code>는 변수를 1 증가시킴</li>
<li><strong>감소 연산자:</strong> <code>--</code>는 변수를 1 감소시킴</li>
</ul>
</li>
</ul>
<p>🔥 <strong>증가·감소 연산자는 위치에 의미가 있다.</strong></p>
<ul>
<li><code>counter++</code>와 같이 피연산자 뒤에 올 때는, **’후위형(postfix form)’**이라고 부른다.</li>
<li><code>++counter</code>와 같이 피연산자 앞에 올 때는, **’전위형(prefix form)’**이라고 부른다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>,</span><br><span class="line">  result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 선할당 후증가(postfix increment operator)</span></span><br><span class="line">result = x++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선증가 후할당(prefix increment operator)</span></span><br><span class="line">result = ++x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 7 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선할당 후감소(postfix decrement operator)</span></span><br><span class="line">result = x--;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 7 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선감소 후할당 (prefix decrement operator)</span></span><br><span class="line">result = --x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 5 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>후위형과 전위형은 피연산자인 <code>**counter</code>를 <code>1</code>만큼 증가시켜 준다는 점**에서 동일한 역할을 한다.</li>
<li>두 형의 차이는 <code>++/--</code>의 반환 값을 사용할 때 드러난다.<ul>
<li>전위형은 증가·감소 후의 새로운 값을 반환하는 반면,</li>
<li>후위형은 증가·감소 전의 기존 값을 반환한다.</li>
</ul>
</li>
</ul>
<p>🖥 <strong>+단항 연산자는 피연산자에 어떠한 효과도 없다.</strong></p>
<ul>
<li>양수를 음수로 반전하지도 않는다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 아무런 효과가 없다.</span></span><br><span class="line">+<span class="number">10</span>; <span class="comment">// -&gt; 10</span></span><br><span class="line">+-<span class="number">10</span>; <span class="comment">// -&gt; -10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>숫자 타입이 아닌 +단항 연산자를 사용하면 👉🏻 피연산자를 <strong>숫자타입으로 변환</strong>하여 반환</li>
</ul>
<p>➡️ 따라서 피연산자를 변경하는 것이 아니라 숫자 타입으로 변환한 값을 생성해서 반환한다. <strong>(부수효과 X)</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">x = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">x = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.</span></span><br><span class="line">x = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>🖥 -<strong>단항 연산자는 피연산자의 부호를 반전한 값을 반환한다.</strong></p>
<ul>
<li>+단항 연산자와 마찬가지로 <strong>숫자 타입이 아닌 피연산자</strong>에 사용하면? 👉🏻 피연산자를 숫자 타입으로 변환하여 반환한다.</li>
<li>이때 피연산자를 변경하는것이 아니고 부호를 생성해 반전한 값을 생성한다. ➡️ 부수효과X</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 부호를 반전한다.</span></span><br><span class="line">-(-<span class="number">10</span>); <span class="comment">// -&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환한다.</span></span><br><span class="line">-<span class="string">&#x27;10&#x27;</span>; <span class="comment">// -&gt; -10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">-<span class="literal">true</span>; <span class="comment">// -&gt; -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.</span></span><br><span class="line">-<span class="string">&#x27;Hello&#x27;</span>; <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="3-문자열-연결-연산자"><a href="#3-문자열-연결-연산자" class="headerlink" title="3. 문자열 연결 연산자"></a>3. 문자열 연결 연산자</h3><p>: +연산자는 피연산자 중 <strong>하나 이상이 문자열인 경우</strong> 문자열 연결 연산자로 동작한다.</p>
<p>그 외의 경우는 산술 연산자로 동작한다.</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">2</span>; <span class="comment">// -&gt; &#x27;12&#x27;</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;2&#x27;</span>; <span class="comment">// -&gt; &#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// -&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true는 1로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>; <span class="comment">// -&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false는 0으로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">false</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null은 0으로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined는 숫자로 타입 변환되지 않는다.</span></span><br><span class="line">+<span class="literal">undefined</span>; <span class="comment">// -&gt; NaN</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>; <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure>

<p>💡 <strong>주목할 것은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환 되기도 한다는 것이다.</strong></p>
<ul>
<li>위 예제에서 1 + true를 연산하면 👉🏻 자바스크립트 엔진은 암묵적으로 불리언 타입의 값이 true를 숫자 타입인 1로 변환 후 연산을 수행한다.</li>
</ul>
<p>➡️ <strong>암묵적 타입 변환(implicit coercion) &#x2F; 타입 강제 변환(type coercion)</strong></p>
<h2 id="할당-연산자"><a href="#할당-연산자" class="headerlink" title="할당 연산자"></a>할당 연산자</h2><h3 id="할당-연산자-1"><a href="#할당-연산자-1" class="headerlink" title="할당 연산자"></a>할당 연산자</h3><p>: 우항에 있는 피연산자의 평가 결과를 <strong>좌항의 변수</strong>에 할당한다.</p>
<ul>
<li>할당 연산자는 좌항의 변수 값을 할당하므로 변수 값이 변하는 <strong>부수 효과가 있다.</strong></li>
</ul>
<table>
<thead>
<tr>
<th>할당 연산자</th>
<th>사례</th>
<th>동일 표현</th>
<th>부수 효과</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>x &#x3D; y</td>
<td>x &#x3D; y</td>
<td>O</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>x +&#x3D; y</td>
<td>x &#x3D; x + y</td>
<td>O</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>x -&#x3D; y</td>
<td>x &#x3D; x - y</td>
<td>O</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>x *&#x3D; y</td>
<td>x &#x3D; x * y</td>
<td>O</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>x &#x2F;&#x3D; y</td>
<td>x &#x3D; x &#x2F; y</td>
<td>O</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>x %&#x3D; y</td>
<td>x &#x3D; x % y</td>
<td>O</td>
</tr>
</tbody></table>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x += <span class="number">5</span>; <span class="comment">// x = x + 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">x -= <span class="number">5</span>; <span class="comment">// x = x - 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x *= <span class="number">5</span>; <span class="comment">// x = x * 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">x /= <span class="number">5</span>; <span class="comment">// x = x / 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x %= <span class="number">5</span>; <span class="comment">// x = x % 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;My name is &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line">str += <span class="string">&#x27;Lee&#x27;</span>; <span class="comment">// str = str + &#x27;Lee&#x27;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// &#x27;My name is Lee&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 표현식</strong></p>
<p>: 값으로 평가될 수 있는 문</p>
<p><strong>✅ 문</strong></p>
<p>: 표현식이 문과 표현식이 아닌문</p>
<p><strong>🤔 그렇다면 할당문은 표현식인 문일까? 표현식이 아닌 문일까?</strong></p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문은 표현식인 문이다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((x = <span class="number">10</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>할당문 👉🏻 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다.</li>
<li><strong>하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.</strong></li>
<li>위 예제의 x&#x3D;10은 x에 할당된 숫자 값 10으로 평가된다.</li>
</ul>
<p>🔥 <strong>할당문을 다른 변수에 할당할 수도 있다. ➡️ 연쇄 할당</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.</span></span><br><span class="line"><span class="comment">// ① c = 0 : 0으로 평가된다</span></span><br><span class="line"><span class="comment">// ② b = 0 : 0으로 평가된다</span></span><br><span class="line"><span class="comment">// ③ a = 0 : 0으로 평가된다</span></span><br><span class="line">a = b = c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 0 0 0</span></span><br></pre></td></tr></table></figure>

<h2 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h2><h3 id="✅-비교-연산자"><a href="#✅-비교-연산자" class="headerlink" title="✅ 비교 연산자"></a>✅ 비교 연산자</h3><p>: 좌항과 우항의 피연산자를 비교한 다음 그 결과를 <strong>불리언 값</strong>으로 반환</p>
<ul>
<li>비교 연산자는 if문이나 for문과 같은 <strong>제어문의 조건식</strong>에서 주로 사용된다.</li>
</ul>
<h3 id="1-동등-x2F-일치-비교-연산자"><a href="#1-동등-x2F-일치-비교-연산자" class="headerlink" title="1. 동등&#x2F;일치 비교 연산자"></a>1. 동등&#x2F;일치 비교 연산자</h3><ul>
<li>동등 비교 연산자와 일치 비교 연산자 <strong>공통점</strong> 👉🏻 같은 값으로 평가되는지 비교하여 불리언 값을 반환한다.</li>
<li>동등 비교 연산자와 일치 비교 연산자 <strong>차이점</strong> 👉🏻 비교하는 엄격성의 정도가 다르다.</li>
</ul>
<table>
<thead>
<tr>
<th>비교 연산자</th>
<th>의미</th>
<th>사례</th>
<th>설명</th>
<th>부수 효과</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>동등 비교</td>
<td>x &#x3D;&#x3D; y</td>
<td>x와 y의 값이 같음</td>
<td>X</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>일치 비교</td>
<td>x &#x3D;&#x3D;&#x3D; y</td>
<td>x와 y의 값과 타입이 같음</td>
<td>X</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>부동등 비교</td>
<td>x !&#x3D; y</td>
<td>x와 y의 값이 다름</td>
<td>X</td>
</tr>
<tr>
<td>!&#x3D;&#x3D;</td>
<td>불일치 비교</td>
<td>x !&#x3D;&#x3D; y</td>
<td>x와 y의 값과 타입이 다름</td>
<td>X</td>
</tr>
</tbody></table>
<p>🖥 <strong>동등 비교 연산자</strong></p>
<p>: 좌항과 우항의 피연산자를 비교할 때 <strong>암묵적 타입 변환을 통해 타입을 일치시킨 후</strong> 같은 값인지 비교한다.</p>
<ul>
<li>동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 동등 비교</span></span><br><span class="line"><span class="number">5</span> == <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.</span></span><br><span class="line"><span class="number">5</span> == <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉽다.</li>
</ul>
<p>➡️ 동등 비교 연산자는 예측하기 어려운 결과를 만들어 낸다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 동등 비교. 결과를 예측하기 어렵다.</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="string">&#x27;&#x27;</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>일치 비교 연산자</strong></p>
<p>: 좌항과 우항의 피연산자가 <strong>타입도 같고 값도 같은 경우</strong> true를 반환한다.</p>
<ul>
<li>암묵적 타입을 변환하지 않고 값을 비교한다. 👉🏻 일치 비교 연산자는 예측하기 쉽다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 일치 비교</span></span><br><span class="line"><span class="number">5</span> === <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 타입 변환을 하지 않고 값을 비교한다.</span></span><br><span class="line"><span class="comment">// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.</span></span><br><span class="line"><span class="number">5</span> === <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>일치 비교 연산자에서 주의해야 할 것은 NaN이다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NaN은 자신과 일치하지 않는 유일한 값이다.</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>NaN은 자신과 일치하지 않는 유일한 값이다.</li>
<li>따라서 숫자가 NaN인지 확인하려면? 👉🏻 isNaN 빌트인 함수 사용</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number.isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 불리언 값으로 반환한다.</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">10</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>숫자 0도 주의하자</strong></p>
<ul>
<li>자바스크립트에는 양의 0과 음의 0이 있는데 비교하면 true를 반환한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 결과는 true이다.</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">0</span> == -<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p><strong>✨ Object.is 메서드</strong></p>
<p>동등 비교 연산자와 일치 비교 연산자는 +0과 -0을 동일한 값, NaN과 NaN를 다른 값이라고 평가한다.</p>
<p>예측 가능한 정확한 비교를 반환한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, +<span class="number">0</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>부동등 비교 연산자(!&#x3D;)와 불일치 비교 연산자(!&#x3D;&#x3D;)는 각각 동등 비교 연산자와 일치 비교 연산자의 반대 개념이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 부동등 비교</span></span><br><span class="line"><span class="number">5</span> != <span class="number">8</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> != <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> != <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불일치 비교</span></span><br><span class="line"><span class="number">5</span> !== <span class="number">8</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> !== <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> !== <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-대소-관계-비교-연산자"><a href="#2-대소-관계-비교-연산자" class="headerlink" title="2. 대소 관계 비교 연산자"></a>2. 대소 관계 비교 연산자</h3><p>: 대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>
<p><img src="https://velog.velcdn.com/images/indongcha/post/6d0537c5-ee15-4359-9e31-4a4b746d599e/image.png" alt="https://velog.velcdn.com/images/indongcha/post/6d0537c5-ee15-4359-9e31-4a4b746d599e/image.png"></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 대소 관계 비교</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> &lt;= <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h2 id="삼항-조건-연산자"><a href="#삼항-조건-연산자" class="headerlink" title="삼항 조건 연산자"></a>삼항 조건 연산자</h2><h3 id="✅-삼항-조건-연산자"><a href="#✅-삼항-조건-연산자" class="headerlink" title="✅ 삼항 조건 연산자"></a>✅ 삼항 조건 연산자</h3><p>: 조건 식의 평가 결과에 따라 반환할 값을 결정한다.</p>
<ul>
<li>자바스크립트의 유일한 삼항 연산자</li>
<li>부수 효과는 없다.</li>
</ul>
<p>🙌🏻 삼항 조건 연산자의 표현식은 다음과 같이 사용한다.</p>
<p><img src="https://velog.velcdn.com/images/indongcha/post/493e2d87-0390-4140-ac45-8108c34ebbc3/image.png" alt="https://velog.velcdn.com/images/indongcha/post/493e2d87-0390-4140-ac45-8108c34ebbc3/image.png"></p>
<ul>
<li>첫 번째 피연산자가 true로 반환되면? 👉🏻 두 번째 피연산자를 반환</li>
<li>첫 번째 피연산자가 false로 반환되면? 👉🏻 세 번째 피연산자를 반환<br>➡️ 즉, 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.</li>
<li>물음표 앞의 첫 번째 피연산자는? 👉🏻 조건식<ul>
<li>즉, 불리언 타입의 값으로 평가될 표현식</li>
<li>평가결과가 불리언 타입의 값이 아니면? ➡️ 불리언 값으로 암묵적 타입 변환된다.</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>🤔 <strong>삼항 조건 연산자는 조건식인가?</strong></p>
<p>삼항 조건 연산자의 첫 번째 피연산자는 조건식이므로 조건문이다.</p>
<p>따라서 if…else문을 사용해도 삼항 조건 연산자 표현식과 유사하게 처리할 수 있다.</p>
<p><strong>🔥 삼항 조건 연산자와 if…else문의 차이점</strong></p>
<p>: 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만 if…else문은 값처럼 사용할 수 없다.</p>
<p>➡️ if…else은 표현식이 아닌 문이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">if</span> (x % <span class="number">2</span>) &#123; result = <span class="string">&#x27;홀수&#x27;</span>; &#125; <span class="keyword">else</span> &#123; result = <span class="string">&#x27;짝수&#x27;</span>; &#125;;</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token if</span></span><br></pre></td></tr></table></figure>

<p>💡 <strong>삼항 조건 연산자는 표현식은 값으로 평가할 수 있는 표현식인 문이다.</strong></p>
<p>➡️ 따라서 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 삼항 조건 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<ul>
<li>조건에 따라 어떤 값을 결정해야 한다면? 👉🏻 삼항 조건 연산자 표현식을 사용하는 것이 유리하다.</li>
<li>조건에 따라 수행해야 할 문이 여러개라면? 👉🏻 if…else문을 사용</li>
</ul>
<h2 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h2><h3 id="논리-연산자-1"><a href="#논리-연산자-1" class="headerlink" title="논리 연산자"></a>논리 연산자</h3><p>: 우항과 좌항의 피연산자를 논리 연산한다. (부정 논리 연산자의 경우 우항의 피연산자)</p>
<p><img src="https://velog.velcdn.com/images/indongcha/post/e2cf5c14-c666-4aad-a598-aa8af2121c8b/image.png" alt="https://velog.velcdn.com/images/indongcha/post/e2cf5c14-c666-4aad-a598-aa8af2121c8b/image.png"></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리 부정(!) 연산자</span></span><br><span class="line">!<span class="literal">true</span>; <span class="comment">// -&gt; false</span></span><br><span class="line">!<span class="literal">false</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>논리 부정 연산자는 언제나 불리언 값을 반환한다.</strong></p>
<ul>
<li>단, 피연산자가 반드시 불리언 값일 필요는 없다.</li>
<li>만약 피연산자가 불리언 값이 아니라면? 👉🏻 불리언 타입으로 암묵적 타입 변환된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 암묵적 타입 변환</span></span><br><span class="line">!<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line">!<span class="string">&#x27;Hello&#x27;</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>논리합 또는 논리곱 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다.</strong></p>
<p>논리합 또는 논리곱 연산자는 언제나 2개의 피연산자 중 어느 한 쪽으로 평가된다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 단축 평가</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>; <span class="comment">// -&gt; &#x27;Dog&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="쉼표-연산자"><a href="#쉼표-연산자" class="headerlink" title="쉼표 연산자"></a>쉼표 연산자</h2><h3 id="✅-쉼표-연산자"><a href="#✅-쉼표-연산자" class="headerlink" title="✅ 쉼표 연산자"></a>✅ 쉼표 연산자</h3><p>: 왼쪽 피연산자부터 차례대로 연산자를 평가하고 마지막 피연산자의 평가가 끝나면 <strong>마지막 피연산자의 평가 결과를 반환</strong>한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y, z;</span><br><span class="line"></span><br><span class="line">(x = <span class="number">1</span>), (y = <span class="number">2</span>), (z = <span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="그룹-연산자"><a href="#그룹-연산자" class="headerlink" title="그룹 연산자"></a>그룹 연산자</h2><h3 id="✅-그룹-연산자"><a href="#✅-그룹-연산자" class="headerlink" title="✅ 그룹 연산자"></a>✅ 그룹 연산자</h3><p>: 소괄호로 피연산자를 감싸는 그룹 연산자는 <strong>자신의 피연산자인 표현식</strong>을 가장 먼저 평가한다.</p>
<p>그룹 연산자를 사용하면 <strong>연산자의 우선순위</strong>를 조절할 수 있다. 그룹 연산자는 우선순위가 가장 높다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> * <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// -&gt; 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 그룹 연산자를 사용하여 우선순위를 조절</span></span><br><span class="line"><span class="number">10</span> * (<span class="number">2</span> + <span class="number">3</span>); <span class="comment">// -&gt; 50</span></span><br></pre></td></tr></table></figure>

<ul>
<li>첫 번째 문에서는 10 * 2를 먼저 연산 ➡️ 그 다음 20 + 3을 연산<ul>
<li>곱셈 연산자가 덧셈 연산자보다 우선순위가 높기 때문에</li>
</ul>
</li>
<li>두번째 문에서는 그룹 연산자로 감싼 표현식을 먼저 연산 ➡️ 2 + 3 연산 ➡️ 그 다음 10 * 5 연산</li>
</ul>
<h2 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h2><h3 id="✅-typeof-연산자"><a href="#✅-typeof-연산자" class="headerlink" title="✅ typeof 연산자"></a>✅ typeof 연산자</h3><p>: 피연산자의 <strong>데이터 타입</strong>을 문자열로 변환</p>
<p>7가지 문자열(string, number, boolean, undefined, symbol, object, function) 중 하나를 반환</p>
<ul>
<li>null을 반환하는 경우는 없다.</li>
<li>함수의 경우 undefined를 반환한다.</li>
</ul>
<p>➡️ 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">// -&gt; &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// -&gt; &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span>; <span class="comment">// -&gt; &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// -&gt; &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// -&gt; &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(); <span class="comment">// -&gt; &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> /test/gi; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// -&gt; &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>null을 “null”이 아닌 “object”로 반환한다는데 주의하자</strong></p>
<p>이것은 자바스크립트의 첫 번째 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.</p>
<p>➡️ 따라서 <strong>null타입인지 확인할 때</strong>는 <strong>일치 연산자</strong>를 사용하자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> foo === <span class="literal">null</span>; <span class="comment">// -&gt; false</span></span><br><span class="line">foo === <span class="literal">null</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p><strong>🔥 선언하지 않은 식별자를 typeof연산자로 연산해보면 ReferenceError가 아닌 undefined를 반환한다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// undeclared 식별자를 선언한 적이 없다.</span></span><br><span class="line"><span class="keyword">typeof</span> undeclared; <span class="comment">// -&gt; undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h2><h3 id="✅-지수-연산자"><a href="#✅-지수-연산자" class="headerlink" title="✅ 지수 연산자"></a>✅ 지수 연산자</h3><p>: ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 거듭제곱하여 숫자 값을 반환한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>; <span class="comment">// -&gt; 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">2.5</span>; <span class="comment">// -&gt; 5.65685424949238</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">0</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="number">2</span> ** -<span class="number">2</span>; <span class="comment">// -&gt; 0.25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자가 도입되기 이전에는? 👉🏻 Math.pow 메서드를 사용</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// -&gt; 4</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2.5</span>); <span class="comment">// -&gt; 5.65685424949238</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">2</span>); <span class="comment">// -&gt; 0.25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자는 다음과 같은 경우 Math.pow 메서드보다 가독성이 좋다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 지수 연산자의 결합 순서는 우항에서 좌항이다. 즉, 우결합성을 갖는다.</span></span><br><span class="line"><span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// -&gt; 512</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// -&gt; 512</span></span><br></pre></td></tr></table></figure>

<ul>
<li>음수를 거듭제곱의 밑으로 사용해 계산하려면 다음과 같이 괄호로 묶어야 한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">-<span class="number">5</span> ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">// SyntaxError: Unary operator used immediately before exponentiation expression.</span></span><br><span class="line"><span class="comment">// Parenthesis must be used to disambiguate operator precedence</span></span><br><span class="line"></span><br><span class="line">(-<span class="number">5</span>) ** <span class="number">2</span>; <span class="comment">// -&gt; 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">5</span>;</span><br><span class="line">num **= <span class="number">2</span>; <span class="comment">// -&gt; 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.</li>
</ul>
<h2 id="그-외의-연산자"><a href="#그-외의-연산자" class="headerlink" title="그 외의 연산자"></a>그 외의 연산자</h2><p><img src="https://velog.velcdn.com/images/indongcha/post/87952395-013e-4fe9-892b-33e6d8226cb8/image.png" alt="옵셔널 체이닝 연산자, null 병합 연산자, 프로퍼티 삭제 연산자 등 "></p>
<p>옵셔널 체이닝 연산자, null 병합 연산자, 프로퍼티 삭제 연산자 등</p>
<h2 id="연산자의-부수-효과"><a href="#연산자의-부수-효과" class="headerlink" title="연산자의 부수 효과"></a>연산자의 부수 효과</h2><p>대부분의 연산자는 다른 코드에 영향을 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다.</p>
<p>💡 <strong>부수 효과가 있는 연산자</strong></p>
<ul>
<li>할당 연산자(&#x3D;)</li>
<li>증가&#x2F;감소 연산자 (++&#x2F;–)</li>
<li>delete 연산자</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 이는 x 변수를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 증가/감소 연산자(++/--)는 피연산자의 값을 변경하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 피연산자 x의 값이 재할당되어 변경된다. 이는 x 변수를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line">x++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 이는 o 객체를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">a</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h2><h3 id="✅-연산자-우선순위"><a href="#✅-연산자-우선순위" class="headerlink" title="✅ 연산자 우선순위"></a>✅ 연산자 우선순위</h3><p>: 여러 개의 연산자로 이뤄진 문이 실행될 때 <strong>연산자가 실행되는 순서</strong>를 의미한다.</p>
<p>우선 순위가 높을수록 먼저 실행된다.</p>
<p><img src="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F369f38d6-96d5-4aaa-9b44-58a8f0a68f43%2Fimage.png" alt="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F369f38d6-96d5-4aaa-9b44-58a8f0a68f43%2Fimage.png"></p>
<p>➡️ 우선순위가 가장 높은 <strong>그룹 연산자</strong>를 사용하여 우선 순위를 명시적으로 조절하는 것을 권장한다.</p>
<h2 id="연산자-결합-순서"><a href="#연산자-결합-순서" class="headerlink" title="연산자 결합 순서"></a>연산자 결합 순서</h2><h3 id="✅-연산자-결합-순서"><a href="#✅-연산자-결합-순서" class="headerlink" title="✅ 연산자 결합 순서"></a>✅ 연산자 결합 순서</h3><p>: 연산자의 어느쪽부터 평가를 수행할 것인지를 나타내는 순서</p>
<p><img src="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F84fa2eee-da12-43ca-81d1-5ba01a5683e5%2Fimage.png" alt="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F84fa2eee-da12-43ca-81d1-5ba01a5683e5%2Fimage.png"></p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>실행 컨텍스트 스택</title>
    <url>/2022/221014-1-archive/</url>
    <content><![CDATA[<p>📚 실행 컨텍스트 스택의 의미에 대해서 알아보고,<br>실행 컨텍스트 스택 안에서 실행 컨텍스트가 어떻게 실행되는지 공부해보자:)</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span> () &#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>전역 코드와 함수 코드로 이루어져 있다.</li>
<li>자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성</li>
<li>함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성</li>
</ul>
<p>생성된 실행 컨텍스트는 스택 자료구조로 관리된다. 👉 <strong>실행 컨텍스트 스택</strong></p>
<p>위 코드를 실행하면 아래와 같이 실행 컨텍스트 스택(Stack)이 생성하고 소멸한다.</p>
<p>현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련없는 코드(예를 들어 다른 함수)가 실행되면 새로운 컨텍스트가 생성된다. 이 컨텍스트는 스택에 쌓이게 되고 컨트롤(제어권)이 이동한다.</p>
<p><img src="https://poiemaweb.com/img/ec_1.png" alt="https://poiemaweb.com/img/ec_1.png"></p>
<h3 id="1-전역-코드-평가와-실행"><a href="#1-전역-코드-평가와-실행" class="headerlink" title="1. 전역 코드 평가와 실행"></a>1. 전역 코드 평가와 실행</h3><ul>
<li>자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시한다.</li>
<li>전역 변수 x와 전역 함수 foo는 전역 실행 컨텍스트에 등록됨</li>
<li>전역 코드가 실행되면 👉 전역 변수 x에 값이 할당되고 전역 함수 foo가 실행</li>
</ul>
<h3 id="2-foo-함수-코드의-평가와-실행"><a href="#2-foo-함수-코드의-평가와-실행" class="headerlink" title="2. foo 함수 코드의 평가와 실행"></a>2. foo 함수 코드의 평가와 실행</h3><ul>
<li>함수 foo가 호출되면 전역 코드의 실행은 일시 중단되고 <strong>코드의 제어권</strong>이 foo 함수 내부로 이동</li>
<li>자바스크립트 엔진은 foo 함수 내부의 함수 코드를 평가하여 foo 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시</li>
<li>이때 foo 함수의 지역 변수 y와 중첩 함수 bar가 foo 함수 실행 컨텍스트에 등록됨</li>
<li>이후 foo 함수 코드가 실행되면 👉 지역 변수 y에 값이 할당되고 중첩 함수 bar가 실행</li>
</ul>
<h3 id="3-bar-함수-코드의-평가와-실행"><a href="#3-bar-함수-코드의-평가와-실행" class="headerlink" title="3. bar 함수 코드의 평가와 실행"></a>3. bar 함수 코드의 평가와 실행</h3><ul>
<li>중첩 함수 bar가 호출되면 foo 함수 코드 실행은 중단되고 코드의 제어권이 bar 함수 내부로 이동</li>
<li>자바스크립트 엔진은 bar 함수 내부의 함수 코드를 평가하여 bar 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시</li>
<li>지역 변수 z와 bar가 bar 함수 실행 컨텍스트에 등록됨</li>
<li>bar 함수가 실행되면 👉 지역 변수 z에 값이 할당되고 console.log 메서드를 호출한 이후 bar 함수 종료</li>
</ul>
<h3 id="4-foo-함수-코드로-복귀"><a href="#4-foo-함수-코드로-복귀" class="headerlink" title="4. foo 함수 코드로 복귀"></a>4. foo 함수 코드로 복귀</h3><ul>
<li>bar 함수가 종료되면 코드의 제어권을 foo 함수로 이동</li>
<li>자바스크립트 엔진은 bar 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거</li>
<li>foo 함수는 더 이상 실행할 코드가 없으므로 종료</li>
</ul>
<h3 id="5-전역-코드로-복귀"><a href="#5-전역-코드로-복귀" class="headerlink" title="5. 전역 코드로 복귀"></a>5. 전역 코드로 복귀</h3><ul>
<li>foo 함수가 종료되면 코드의 제어권은 다시 전역 코드로 이동</li>
<li>자바스크립트 엔진은 foo 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거</li>
<li>더 이상 실행할 전역 코드가 남아 있지 않으므로 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 제거</li>
<li>실행 컨텍스트 스택에는 아무것도 남아있지 않음</li>
</ul>
<p><strong>👉 이처럼 실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.</strong></p>
<ul>
<li>소스코드가 평가되면 실행 컨텍스트가 생성 → 실행 컨텍스트 스택의 최상위에 쌓인다.</li>
<li>따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 <strong>실행 중인 실행 컨텍스트( running execution context)</strong> 라 부른다.</li>
</ul>
<h2 id="렉시컬-환경"><a href="#렉시컬-환경" class="headerlink" title="렉시컬 환경"></a>렉시컬 환경</h2><h3 id="✅-렉시컬-환경"><a href="#✅-렉시컬-환경" class="headerlink" title="✅ 렉시컬 환경"></a>✅ 렉시컬 환경</h3><p>: 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조, 실행 컨텍스트를 구성하는 컴포넌트</p>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8697dd5f-901c-4017-b0b2-d7e10c0c2888%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8697dd5f-901c-4017-b0b2-d7e10c0c2888%2Fimage.png"></p>
<ul>
<li>실행 컨텍스트 스택: <strong>코드의 실행순서를 관리</strong>한다면</li>
<li>렉시컬 환경: <strong>스코프와 식별자</strong>를 관리한다.</li>
<li>키와 값을 갖는 객체 형태의 스코프를 생성 (전역, 함수, 블록 스코프) 👉 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리</li>
</ul>
<p><strong>렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체</strong></p>
<h3 id="실행-컨텍스트의-구성"><a href="#실행-컨텍스트의-구성" class="headerlink" title="실행 컨텍스트의 구성"></a>실행 컨텍스트의 구성</h3><ul>
<li>LexicalEnvironment Component</li>
<li>VariableEnvironment Component</li>
</ul>
<p><strong>생성 초기</strong> 👉 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트는 하나의 동일한 렉시컬 환경을  참조</p>
<p><strong>이후 몇 가지 상황을 만나면 👉</strong> VariableEnvironment 컴포넌트를 위한 새로운 렉시컬 환경을 생성한다.</p>
<p>이때부터 VariableEnvironment 컴포넌트와 LexicalEnvironment 컴포넌트는 내용이 달라지는 경우도 있다.</p>
<h3 id="렉시컬-환경의-구성"><a href="#렉시컬-환경의-구성" class="headerlink" title="렉시컬 환경의 구성"></a>렉시컬 환경의 구성</h3><p>렉시컬 환경은 두 개의 컴포넌트로 구성된다.</p>
<ul>
<li>Environment Record (환경 레코드)</li>
<li>Outer Lexical Environment Reference (외부 렉시컬 환경에 대한 참조)</li>
</ul>
<p>✏️ <strong>환경 레코드</strong></p>
<ul>
<li>스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소</li>
<li>환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다.</li>
</ul>
<p>✏️ <strong>외부 렉시컬 환경에 대한 참조</strong></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다.</li>
<li>상위 스코프란 외부 렉시컬 환경 👉 즉, 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경</li>
<li>외부 렉시컬 환경에 대한 참조를 통해 <strong>단방향 링크드 리스트인 스코프 체인</strong>을 구현</li>
</ul>
<h2 id="실행-컨텍스트와-블록-레벨-스코프"><a href="#실행-컨텍스트와-블록-레벨-스코프" class="headerlink" title="실행 컨텍스트와 블록 레벨 스코프"></a>실행 컨텍스트와 블록 레벨 스코프</h2><p>🔥 어떻게 실행 컨텍스트가 생성되는가? (실행 컨텍스트 생성 과정)<br>🔥 어떻게 코드 실행 결과가 관리되는가?<br>🔥 어떻게 실행 컨테스트를 통해 식별자를 검색하는가?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (a) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span> (b) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>); <span class="comment">// 42</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-전역-객체-생성"><a href="#1-전역-객체-생성" class="headerlink" title="1. 전역 객체 생성"></a>1. 전역 객체 생성</h3><ul>
<li>전역 객체는 전역 코드가 평가되기 이전에 생성된다.</li>
<li>이때 전역 객체에 생성되는 것<ul>
<li>빌트인 전역 프로퍼티</li>
<li>빌트인 전역 함수</li>
<li>표준 빌트인 객체</li>
<li>동작 환경에 따라 클라이언트 사이드 Web API 또는 특정 환경을 위한 호스트 객체 포함</li>
</ul>
</li>
<li>전역 객체도 Object.portotype을 상속 받는다. 👉 전역 객체도 프로토타입 체인의 일원</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.prototype.toString</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">toString</span>(); <span class="comment">// -&gt; &quot;[object Window]&quot;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-전역-코드-평가"><a href="#2-전역-코드-평가" class="headerlink" title="2. 전역 코드 평가"></a>2. 전역 코드 평가</h3><ul>
<li>소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가</li>
<li>전역 코드 평가 순서<ol>
<li><strong>전역 실행 컨텍스트 생성</strong></li>
<li><strong>전역 렉시컬 환경 생성</strong><ol>
<li>전역 <strong>환경 레코드</strong> 생성<ol>
<li>객체 환경 레코드 생성</li>
<li>선언적 환경 레코드 생성</li>
</ol>
</li>
<li>this 바인딩</li>
<li><strong>외부 렉시컬 환경에 대한 참조</strong> 결정</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>🙌🏻 위 과정을 거쳐 생성된 전역 실행 컨텍스트와 렉시컬 환경은 아래 그림과 같다.</p>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F80500ef0-a74a-41f9-abfe-d5d9277a664f%2Fjavascript-context08.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F80500ef0-a74a-41f9-abfe-d5d9277a664f%2Fjavascript-context08.png"></p>
<p>📚 <strong>세부적인 생성 과정 살펴보기</strong></p>
<p><strong>1. 전역 실행 컨텍스트 생성</strong></p>
<ul>
<li>먼저 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 push</li>
<li>이때 전역 실행 컨텍스트는 running execution context가 된다.</li>
</ul>
<p><strong>2. 전역 렉시컬 환경 생성</strong></p>
<ul>
<li>전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 <strong>바인딩</strong>한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fbc8bca2e-04e7-4533-b8bd-e58b79f770e3%2Fjavascript-context06.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fbc8bca2e-04e7-4533-b8bd-e58b79f770e3%2Fjavascript-context06.png"></p>
<ul>
<li><p>렉시컬 환경은 2개의 컴포넌트, <strong>환경 레코드</strong>와 <strong>외부 렉시컬 환경에 대한 참조</strong>로 구성된다.</p>
<p>  <strong>2.1. 전역 환경 레코드 생성</strong></p>
<ul>
<li><p>전역 환경 레코드: 전역 렉시컬 환경을 구성하는 컴포넌트</p>
</li>
<li><p>전역 환경 레코드가 제공하는 것</p>
<ul>
<li>전역 변수를 관리하는 전역 스코프</li>
<li>전역 객체의 빌트인 전역 프로퍼티</li>
<li>빌트인 전역 함수</li>
<li>표준 빌트인 객체</li>
</ul>
</li>
<li><p>ES6 이전</p>
<ul>
<li>모든 전역 변수가 전역 객체의 프로퍼티</li>
<li>전역 객체가 전역 환경 레코드의 역할을 수행함</li>
</ul>
</li>
<li><p>ES6</p>
<ul>
<li><p>전역 환경 레코드 : let, const 키워드로 선언한 전역 변수를 구분하여 관리하기 위해 전역 스코프 역할을 한다.</p>
</li>
<li><p>전역 환경 레코드 구성요소</p>
<ol>
<li><strong>Object Environmnet Record (객체 환경 레코드)</strong> : var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 관리</li>
<li><strong>Declarative Environment Record (선언적 환경 레코드)</strong> : let, const 키워드로 선언한 전역 변수를 관리</li>
</ol>
<p>  👉 전역 환경 레코드의 객체 환경 레코드와 선언적 환경 레코드는 서로 협력하여 전역 스코프와 전역 객체(전역 변수의 전역 객체 프로퍼티화)를  관리한다.</p>
</li>
</ul>
<p>  ✏️ <strong>객체 환경 레코드 생성</strong></p>
<ul>
<li><p>전역 환경 레코드를 구성하는 컴포넌트인 객체 환경 레코드는 <code>BindingObject</code> 라고 부르는 객체와 연결된다.</p>
</li>
<li><p><strong>BindingObject: 전역 객체 생성에서 생성된 전역 객체</strong></p>
</li>
<li><p>전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수</p>
<ul>
<li>객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체 프로퍼티와 메서드가 된다.</li>
</ul>
</li>
<li><p>이때 등록된 식별자를 전역 환경 레코드의 객체 환경 레코드에서 검색하면 전역 객체의 프로퍼티를 검색하여 반환</p>
<p>  👉 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수가 전역 객체 프로퍼티와 메서드가 되고 전역 객체를 가리키는 식별자(window) 없이 전역 객체의 프로퍼티를 참조할 수 있는 매커니즘</p>
</li>
<li><p>위 예제의 전역 변수 x와 전역 함수 foo는 객체 환경 레코드를 통해 객체 환경 레코드의 BindingObject에 바인딩 되어있는 전역 객체의 프로퍼티와 메서드가 된다.</p>
</li>
</ul>
<p>  <img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8d77a5f4-2b7a-454d-a6aa-b5bda1943a6e%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8d77a5f4-2b7a-454d-a6aa-b5bda1943a6e%2Fimage.png"></p>
<ul>
<li><p>x 변수는 var 키워드로 선언한 변수</p>
<p>  👉 선언 단계와 초기화 단계가 동시에 진행</p>
</li>
<li><p>전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록한 다음 암묵적으로 undefined를 바인딩</p>
<p>  👉 var 키워드로 선언한 변수는 <strong>코드 실행 단계</strong>에서 변수 선언문 이전에 참조할 수 있다. (코드 평가 단계 x)</p>
</li>
<li><p>단, 변수 선언문 이전에 참조한 변수의 값은 언제나 undefined (var 키워드로 선언한 변수에 할당한 함수 표현식도 이와 동일하게 작용)</p>
<p>  👉 <strong>변수 호이스팅</strong>이 발생하는 원인</p>
</li>
<li><p>함수 선언문으로 정의한 함수가 평가되면 함수 이름과 동일한 이름의 식별자를 객체 환경 레코드에 바인딩된 <strong>BindingObject를 통해 전역 객체에 키로 등록하고 생성된 함수 객체를 즉시 할당</strong>한다.</p>
<p>  👉 함수 호이스팅과 변수 호이스팅의 차이 (함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.)</p>
</li>
</ul>
<p>  ✏️ <strong>선언적 환경 레코드 생성</strong></p>
<ul>
<li><p>let, const 키워드로 선언한 전역 변수(let, const 키워드로 선언한 변수에 할당한 함수 표현식 포함)</p>
</li>
<li><p>위 예제의 변수 y는 const 키워드로 선언한 변수이므로 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재</p>
<p>  👉 개념적인 블록이 바로 <strong>전역 환경 레코드의 선언적 환경 레코드</strong></p>
<ul>
<li>전역 변수 y는 let, const 키워드로 선언한 변수이므로 전역 객체의 프로퍼티가 아니다.</li>
<li>window.y와 같이 전역 객체의 프로퍼티로서 참조할 수 없다.</li>
<li>const 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.</li>
<li>따라서 초기화 단계 즉, 런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 <strong>일시적 사각지대</strong>에 빠지게 된다.</li>
</ul>
</li>
<li><p>y 변수에 바인딩 되어있는 uninitialized는 초기화 단계가 진행되지 않아 변수에 접근할 수 없음을 나타내기 위한 표현이며, 실제로 값이 바인딩된 것이 아니다.</p>
</li>
<li><p>let, const 키워드로 선언한 변수도 변수 호이스팅이 발생한 것은 변함이 없다.</p>
</li>
<li><p>단, let, const 키워드로 선언한 변수는 런타임에 컨트롤(제어권)이 변수 선언문에 도달하기 전까지 일시적 사각지대에 빠지기 때문에 참조할 수 없다.</p>
</li>
</ul>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// let, const 키워드로 선언한 변수가 호이스팅되지 않는다면 전역 변수를 참조해야 한다.</span></span><br><span class="line">  <span class="comment">// 하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다.</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError: Cannot access &#x27;foo&#x27; before initilization</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// 지역 변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  <strong>2.2. this 바인딩</strong></p>
<ul>
<li>전역 환경 레코드의 <code>[[GlobalThisValue]]</code> 내부 슬롯에 this가 바인딩</li>
<li>전역 코드에서 this는 → 전역 객체를 가리키므로 환경 레코드의 <code>[[GlobalThisValue]]</code> 내부 슬롯에는 전역 객체가 바인딩된다.</li>
<li>전역 코드에서 this를 참조하면? → 전역 환경 레코드의 <code>[[GlobalThisValue]]</code> 내부 슬롯에 바인딩 되어있는 객체가 반환</li>
</ul>
<p>  <img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F9323ab1f-8282-41aa-95c9-3a121d011221%2Fjavascript-context09.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F9323ab1f-8282-41aa-95c9-3a121d011221%2Fjavascript-context09.png"></p>
<ul>
<li>전역 환경 레코드를 구성하는 객체 환경 레코드와 선언전 환경 레코드에는 this 바인딩이 없다.<br>  👉 this 바인딩은 <strong>전역 환경 레코드</strong>와 <strong>함수 환경 레코드</strong>에만 존재</li>
</ul>
<p>  <strong>2.3. 외부 렉시컬 환경에 대한 참조 결정</strong></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경 👉 상위 스코프</li>
<li>현재 평가 중인 소스코드는? → 전역 코드</li>
<li>전역 코드를 포함하는 소스코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 null이 할당된다. 👉 전역 렉시컬 환경이 <strong>스코프 체인의 종점</strong>에 존재함을 의미</li>
</ul>
<p>  <img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2Fdb7710eb-6885-4f19-b25a-d5365494ccba%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2Fdb7710eb-6885-4f19-b25a-d5365494ccba%2Fimage.png"></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조를 통해 스코프 체인을 구현하는 메커니즘</li>
</ul>
</li>
</ul>
<h3 id="3-전역-코드-실행"><a href="#3-전역-코드-실행" class="headerlink" title="3. 전역 코드 실행"></a>3. 전역 코드 실행</h3><ul>
<li>이제 전역 코드가 순차적으로 <strong>실행</strong></li>
<li>변수 할당문이 실행되어 전역 변수 x, y에 값이 할당 그리고 foo 함수 호출</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F148a74ef-a9fd-411c-b61a-6ca895de14df%2Fjavascript-context11.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F148a74ef-a9fd-411c-b61a-6ca895de14df%2Fjavascript-context11.png"></p>
<ul>
<li>변수 할당문 또는 변수 호출문을 실행하려면? → 변수 또는 함수 이름이 선언된 식별자인지 확인</li>
<li>선언되지 않는 식별자는 참조할 수 없으므로 할당이나 호출이 불가</li>
<li>또한 식별자는 스코프가 다르면 같은 일므을 가질 수 있다. (동일한 이름의 식별자가 다른 스코프에 여러 개 존재할 수 있다.) 👉 어느 스코프의 식별자를 참조하면 되는지 결정할 필요가 있다. 이를 <strong>identifier resolution(식별자 결정)</strong> 이라고 한다.</li>
</ul>
<h3 id="✅-식별자-결정"><a href="#✅-식별자-결정" class="headerlink" title="✅ 식별자 결정"></a>✅ 식별자 결정</h3><p>: 어느 스코프의 식별자를 참조해야하는지 결정하는 것</p>
<ul>
<li>식별자 결정을 위해 식별자를 검색할 때는 <strong>실행 중인 실행 컨텍스트에서 식별자를 검색</strong>하기 시작<ul>
<li>선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 <strong>환경 레코드</strong>에 등록</li>
</ul>
</li>
<li>현재 실행 중인 컨텍스트는? 👉 전역 실행 컨텍스트이므로 전역 렉시컬 환경에서 식별자 x, y, foo를 검색하기 시작</li>
<li>만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면? → 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경 즉, 상위 스코프로 이동하여 식별자를 검색 👉 <strong>스코프 체인의 동작 원리</strong></li>
<li>전역 렉시컬 환경은 스코프 체인의 종점이므로 전역 렉시컬 환경에서 검색할 수 없는 참조 에러를 발생시킴</li>
</ul>
<blockquote>
<p>🔥 이처럼 실행 컨텍스트는 소스코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</p>
</blockquote>
<h3 id="4-foo-함수-코드-평가"><a href="#4-foo-함수-코드-평가" class="headerlink" title="4. foo 함수 코드 평가"></a>4. foo 함수 코드 평가</h3><p>현재 상태는? → 전역 코드 평가를 통해 전역 실행 컨텍스트가 생성되었고 전역 코드를 실행하고 있다.</p>
<p>(현재 상태 foo 함수를 호출하기 직전)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (a) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span> (b) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>); <span class="comment">// ← 호출 직전</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>foo 함수가 호출되면 전역 코드의 실행을 일시 중단 → foo 함수 내부로 코드의 제어권이 이동</li>
<li>함수 코드 평가 시작 (실행 순서)<ol>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ol>
<li>함수 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F9cee357b-0ed8-4375-9842-58b5fc3e3e8e%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F9cee357b-0ed8-4375-9842-58b5fc3e3e8e%2Fimage.png"></p>
<p><strong>📚 세부적인 생성 과정 살펴보기</strong></p>
<ol>
<li><strong>함수 실행 컨텍스트 생성</strong><ul>
<li>foo 함수 실행 컨텍스트르 생성 → 함수 렉시컬 환경이 완성된 다음 실행 컨텍스트 스택에 push<ul>
<li>이때 foo 함수 실행 컨텍스트는 실행 컨텍스트 스택의 최상위 &#x3D; 실행중인 실행 컨텍스트</li>
</ul>
</li>
</ul>
</li>
<li><strong>함수 렉시컬 환경 생성</strong></li>
</ol>
<ul>
<li>foo 함수 렉시컬 환경을 생성하고 foo 함수 실행 컨텍스트에 바인딩</li>
</ul>
<p><strong>2.1. 함수 환경 레코드 생성</strong></p>
<p>함수 렉시컬 환경을 구성하는 컴포넌트 중 하나인 함수 환경 레코드가 관리하는 것들</p>
<ul>
<li>매개변수</li>
<li>arguments 객체</li>
<li>함수 내부에서 선언한 지역 변수</li>
<li>함수 내부에서 선언한 중첩 함수</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ff6edb09d-44c5-4f97-b1c3-472713f17d41%2Fjavascript-context13.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ff6edb09d-44c5-4f97-b1c3-472713f17d41%2Fjavascript-context13.png"></p>
<p><strong>2.2. this 바인딩</strong></p>
<ul>
<li>함수 환경 레코드의 <code>[[ThisisValue]]</code> 내부 슬롯에 this 바인딩</li>
<li><code>[[ThisisValue]]</code> 내부 슬롯에 바인딩된 객체는 <strong>함수 호출 방식에 따라 결정</strong></li>
<li>foo 함수는 일반 함수로 호출 👉 this는 전역 객체를 가리킨다.</li>
<li></li>
<li>환경 함수 레코드의 <code>[[ThisisValue]]</code> 내부 슬롯에는 전역 객체가 바인딩</li>
<li>foo 함수 내부에서 this를 참조하면? → 함수 환경 레코드의 <code>[[ThisisValue]]</code> 내부 슬롯에 바인딩 되어있는 객체가 반환</li>
</ul>
<p><strong>2.3. 외부 렉시컬 환경에 대한 참조 결정</strong></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조에 <strong>foo 함수 정의가 평가된 시점</strong>에 실행 중인 컨텍스트의 렉시컬 환경에 대한 참조가 할당된다.</li>
<li>foo 함수가 평가된 시점은? → 전역 코드에 정의된 전역 함수<ul>
<li>foo 함수 정의는 전역 코드 평가 시점에 평가된다.</li>
</ul>
</li>
<li>이 시점의 실행 중인 컨텍스트는? → <strong>전역 실행 컨텍스트</strong></li>
<li>따라서 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경의 참조가 할당된다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F75bb6fb2-0c48-4c68-8f30-4c575cc1952c%2Fjavascript-context15.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F75bb6fb2-0c48-4c68-8f30-4c575cc1952c%2Fjavascript-context15.png"></p>
<blockquote>
<p>자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다. 👉 <code>렉시컬 스코프</code></p>
<p>함수 객체는 자신이 정의된 스코프, 상위 스코프를 기억한다.</p>
</blockquote>
<ul>
<li>자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 <strong>현재 실행 중인 실행 컨텍스트의 렉시컬 환경</strong> 즉, 함수의 <strong>상위 스코프</strong>를 함수 객체의 내부 슬롯 <code>[[Environment]]</code> 에 저장한다.</li>
<li>함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당하는 것 👉 상위 스코프를 가리키는 함수 객체의 내부 슬롯 <code>[[Environment]]</code> 에 저장된 렉시컬 환경의 참조</li>
<li><strong>즉, 함수 객체의 내부 슬롯 <code>[[Environment]]</code> 가 바로 렉시컬 스코프를 구현하는 매커니즘이다.</strong></li>
</ul>
<p>함수 객체의 내부 슬롯 [[Environment]] 와 렉시컬 스코프는 클로저를 이해할 수 있는 중요한 단서다. 👉 <code>클로저</code></p>
<h3 id="5-foo-함수-코드-실행"><a href="#5-foo-함수-코드-실행" class="headerlink" title="5. foo 함수 코드 실행"></a>5. <strong>foo 함수 코드 실행</strong></h3><ul>
<li>이제 런타임이 시작되어 foo 함수의 소스코드가 순차적으로 실행되기 시작한다.</li>
<li>매개변수에 인수가 할당 → 변수 할당문이 실행 → 지역 변수 x, y에 값이 할당 → 함수 bar 호출</li>
<li>이때 식별자 결정을 위해 실행 중인 컨텍스트의 렉시컬 환경에서 식별자를 검색</li>
<li>현재 실행 중인 컨텍스트는? → foo 함수 실행 컨텍스트</li>
<li>foo 함수 렉시컬 환경에서 식별자 x, y를 검색<ul>
<li>실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면? -&gt; 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자 검색</li>
<li>검색 후 검색된 식별자에 값을 바인딩</li>
</ul>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fd4d9f9d5-6788-4fd1-9d84-2e4ea4751169%2Fjavascript-context16.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fd4d9f9d5-6788-4fd1-9d84-2e4ea4751169%2Fjavascript-context16.png"></p>
<h3 id="6-bar-함수-코드-평가"><a href="#6-bar-함수-코드-평가" class="headerlink" title="6. bar 함수 코드 평가"></a>6. bar 함수 코드 평가</h3><ul>
<li>현재 상태? → foo 함수 코드 평가를 통해 foo 함수 실행 컨텍스트가 생성되었고 foo 함수 코드 실행 중 (bar 함수를 호출하기 직전)</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (a) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span> (b) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>); <span class="comment">// ← 호출 직전</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>bar 함수가 호출되면 bar 함수 내부로 코드의 제어권이 이동 → bar 함수 코드를 평가하기 시작</li>
<li>실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드 평가와 동일함<ol>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ol>
<li>함수 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F12c9ca7e-0d11-45a2-a51f-aa63b5d25089%2Fjavascript-context18.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F12c9ca7e-0d11-45a2-a51f-aa63b5d25089%2Fjavascript-context18.png"></p>
<h3 id="7-bar-함수-코드-실행"><a href="#7-bar-함수-코드-실행" class="headerlink" title="7. bar 함수 코드 실행"></a>7. bar 함수 코드 실행</h3><ul>
<li>이제 런타임이 시작되어 bar 함수 소스코드가 순차적으로 실행</li>
<li>매개변수에 인수 할당, 변수 할당문 실행 → 지역 변수 z에 값이 할당</li>
<li>console.log(a + b + x + y + z)가 실행</li>
</ul>
<p><strong>📃 <code>console.log(a + b + x + y + z)</code> 실행되는 순서</strong></p>
<ol>
<li><p><strong>console 식별자 검색</strong></p>
<ul>
<li>console 식별자를 스코프 체인에서 검색</li>
<li>식별자를 검색할 때는 언제나 현재 실행 중인 컨텍스트의 렉시컬 환경에서 시작</li>
</ul>
<blockquote>
<p>💡 스코프 체인</p>
<p>: 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작 👉 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속</p>
</blockquote>
<ul>
<li>현재 실행 중인 컨텍스트는? → bar 함수 실행 컨텍스트</li>
<li>bar 함수 실행 컨텍스트의 bar 함수 렉시컬 환경에서 console 식별자를 검색하기 시작</li>
<li>이곳에는 console 식별자가 없으므로 스코프 체인 상의 상위 스코프 즉, 외부 렉시컬 환경에 대한 참조가 가리키는 foo 함수 렉시컬 환경으로 이동하여 검색</li>
<li>foo 함수 실행 컨텍스트의 렉시컬 환경에도 없으므로 스코프 체인 상의 상위 스코프 → 전역 렉시컬 환경으로 이동하여 검색</li>
<li>전역 렉시컬 환경은 객체 환경 레코드, 선언적 환경 레코드로 구성되어 있음</li>
<li>console 식별자는 객체 환경 레코드 BindingObject를 통해 전역 객체에서 찾을 수 있다.</li>
</ul>
</li>
<li><p><strong>log 메서드 검색</strong></p>
<ul>
<li>console 식별자에 바이딩된 객체 즉, console 객체에서 log 메서드를 검색</li>
<li>이때 console 객체의 프로토타입 체인을 통해 메서드를 검색</li>
<li>log 메서드는 console 객체가 직접 소유하는 프로퍼티</li>
</ul>
 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;log&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>표현식 a + b + x + y + z의 평가</strong></p>
<ul>
<li>console.log 메서드에 전달한 인수 → a + b + x + y + z를 평가하기 위해 a, b, x, y, z 식별자를 검색</li>
<li>식별자는 실행 중인 실행 컨텍스트 렉시컬 환경에서 시작 👉 외부 렉시컬 환경에 대한 참조로 이어지는 <strong>렉시컬 환경의 연속</strong>에서 검색</li>
<li>a 식별자는? → foo 함수의 렉시컬 환경</li>
<li>b 식별자는? → bar 함수의 렉시컬 환경</li>
<li>x, y 식별자는? → foo 함수의 렉시컬 환경</li>
<li>z 식별자는? → bar 함수의 렉시컬 환경</li>
</ul>
</li>
<li><p><strong>console.log 메서드 호출</strong></p>
<ul>
<li>표현식 a + b + x + y + z가 평가되어 생성한 값 42를 console.log 메서드에 전달하여 호출</li>
</ul>
</li>
</ol>
<h3 id="8-bar-함수-코드-실행-종료"><a href="#8-bar-함수-코드-실행-종료" class="headerlink" title="8. bar 함수 코드 실행 종료"></a>8. bar 함수 코드 실행 종료</h3><ul>
<li>console.log 메서드가 호출되고 종료하면 더는 실행할 코드가 없으므로 bar 코드의 실행이 종료</li>
<li>이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop<ul>
<li>foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.</li>
</ul>
</li>
<li><strong>bar 함수 실행 컨텍스트가 제거되었다고 해서 bar 함수 렉시컬 환경까지 즉시 소멸되는 것은 아니다.</strong></li>
<li>렉시컬 환경은 실행 컨텍스트에 의해 참조되기는 하지만 <strong>독립적인 객체</strong>다.</li>
<li>객체를 포함한 모든 값은 참조되지 않을 때 가비지 컬렉터에 의해 메모리 공간의 확보가 해재되어 소멸한다.</li>
</ul>
<h3 id="9-foo-함수-코드-실행-종료"><a href="#9-foo-함수-코드-실행-종료" class="headerlink" title="9. foo 함수 코드 실행 종료"></a>9. foo 함수 코드 실행 종료</h3><ul>
<li>bar 함수가 호출되고 종료하면 더는 실행할 코드가 없으므로 foo 코드의 실행이 종료됨</li>
<li>이때 실행 컨텍스트 스택에서 foo 함수 실행 컨텍스트 pop<ul>
<li>전역 실행 컨텍스트가 실행 중인 컨텍스트</li>
</ul>
</li>
</ul>
<h3 id="10-전역-코드-실행-종료"><a href="#10-전역-코드-실행-종료" class="headerlink" title="10. 전역 코드 실행 종료"></a>10. 전역 코드 실행 종료</h3><ul>
<li>foo 함수가 종료되면 더는 실행할 전역 코드가 없으므로 코드 실행이 종료되고 전역 실행 컨텍스트도 실행 컨텍스트에서 제거되어 컨텍스트 스택에는 아무것도 남아있지 않게 된다.</li>
</ul>
<h2 id="실행-컨텍스트-생성과-식별자-검색-과정"><a href="#실행-컨텍스트-생성과-식별자-검색-과정" class="headerlink" title="실행 컨텍스트 생성과 식별자 검색 과정"></a>실행 컨텍스트 생성과 식별자 검색 과정</h2><p>let, const 키워드와 블록 레벨 스코프에서 살펴보았듯이 var 키워드로 선언한 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.</p>
<p>하지만 let, const 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>if문의 코드 블록 내에서 let 키워드로 변수가 선언<ul>
<li>if문의 코드 블록이 실행되면 if문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.</li>
<li>이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 렉시컬 환경을 교체한다.</li>
</ul>
</li>
<li>새롭게 생성된 if문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조 👉 if문이 실행되기 이전의 전역 렉시컬 환경</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F43e900bb-968f-40a8-bf5c-7f721ce5ca8d%2Fimage.png" alt="Global Execution Context의 화살표가 가리키는 방향을 살펴보자."></p>
<p>Global Execution Context의 화살표가 가리키는 방향을 살펴보자.</p>
<p>📃 <strong>if문 뿐만 아니라 블록 레벨 스코프를 생성하는 모든 블록문에 적용</strong></p>
<ul>
<li>for문의 변수 선언문에 let 키워드를 사용한 for문은 코드 블록이 반복해서 실행될 때마다 코드 블록을 위한 새로운 렉시컬 환경 생성</li>
<li>만약 for문의 코드 블록 내에서 정의된 함수가 있다면? 👉 함수의 상위 스코프는 for문의 코드블록이 생성한 렉시컬 환경</li>
<li>이때 함수의 상위 스코프는 for문의 코드 블록이 반복해서 실행될 때마다 식별자의 값을 유지해야 함<ul>
<li>식별자(for문의 변수 선언문 및 for문의 코드 블록 내에서 선언된 지역 변수 등)</li>
</ul>
</li>
</ul>
<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>내가 쓴 코드가 자바스크립트에서 어떻게 동작하는지에 대해서 알 수 있는 기회가 되었다.<br>결과값을 확인하기 위해 주구장창 써왔던 console.log도 어떤 방식으로 값을 출력하는지에 대해서 알게되니 공부를 하면서 하나의 지식을 쌓은 것 같아 기분이 좋다!</p>
<p>실행 컨텍스트를 공부하니 스코프에 대해서도 잘 알아놓으면 좋겠다라는 생각이 든다.다음 자바스크립트 Deep Dive 정리는 스코프 너로 정했다. (๑╹o╹)φ</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>왜 1byte는 8bit일까?</title>
    <url>/2022/221022-archive/</url>
    <content><![CDATA[<h3 id="이-질문에-대해서-생각해보기-전에-컴퓨터가-개발되던-시기로-돌아가보자"><a href="#이-질문에-대해서-생각해보기-전에-컴퓨터가-개발되던-시기로-돌아가보자" class="headerlink" title="이 질문에 대해서 생각해보기 전에 컴퓨터가 개발되던 시기로 돌아가보자."></a>이 질문에 대해서 생각해보기 전에 컴퓨터가 개발되던 시기로 돌아가보자.</h3><p>컴퓨터는 미국에서 발전한 기계인데, 처음 컴퓨터를 통해 문자를 나타내기 위한 규약인 ASCII(American Standard Code for Information Interchange)도 알파벳을 포함한 미국에서 사용하기 위한 문자들을 표현하기 위해 만든 것이었다.</p>
<p>ASCII는 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 그리고 일부 특수문자를 포함한다.</p>
<p>이때 ASCII의 총 문자수가 공백을 포함하여 128자였기 때문에 7bit 만으로 모든 문자를 표현하는 것이 가능했다.</p>
<p><img src="https://blog.kakaocdn.net/dn/qOPNt/btrAdcY26CF/Ksn1qKzUqEaCql1Cbk6GG0/img.png" alt="https://blog.kakaocdn.net/dn/qOPNt/btrAdcY26CF/Ksn1qKzUqEaCql1Cbk6GG0/img.png"></p>
<h3 id="🤔-그럼-7bit여야하는거-아닌가"><a href="#🤔-그럼-7bit여야하는거-아닌가" class="headerlink" title="🤔 그럼 7bit여야하는거 아닌가?"></a><strong>🤔 그럼 7bit여야하는거 아닌가?</strong></h3><p>싶지만 8비트 중 1비트는 패리티 비트라고 불리는 오류 검출을 위해 사용되기 때문에 1바이트가 8비트로 이루어져 있는 것이다.</p>
<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>1바이트는 8비트다라고 당연하게 생각하고 넘어갔던 것들에 대해서 궁금해하고 찾아보니 새로운 정보들을 찾아보게 되고 새롭게 알게 된 것들이 많아 보람차다.</p>
<p>이후에는 문자를 인코딩하는 방법에 대해서 알아보자 (๑・‿・๑)</p>
<p>참고자료)</p>
<ul>
<li><a href="https://devbull.xyz/1baiteuga-8biteuin-iyu-the-reason-why-1byte-equals-to-8bit/">https://devbull.xyz/1baiteuga-8biteuin-iyu-the-reason-why-1byte-equals-to-8bit/</a>   </li>
<li>혼자 공부하는 컴퓨터 구조 + 운영체제</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>IT</tag>
        <tag>Computer</tag>
      </tags>
  </entry>
</search>
