<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>실행 컨텍스트 스택</title>
    <url>/2022/221014-1-archive/</url>
    <content><![CDATA[<p>📚 실행 컨텍스트 스택의 의미에 대해서 알아보고,<br>실행 컨텍스트 스택 안에서 실행 컨텍스트가 어떻게 실행되는지 공부해보자:)</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>전역 코드와 함수 코드로 이루어져 있다.</li>
<li>자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성</li>
<li>함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성</li>
</ul>
<p>생성된 실행 컨텍스트는 스택 자료구조로 관리된다. 👉 <strong>실행 컨텍스트 스택</strong></p>
<p>위 코드를 실행하면 아래와 같이 실행 컨텍스트 스택(Stack)이 생성하고 소멸한다.</p>
<p>현재 실행 중인 컨텍스트에서 이 컨텍스트와 관련없는 코드(예를 들어 다른 함수)가 실행되면 새로운 컨텍스트가 생성된다. 이 컨텍스트는 스택에 쌓이게 되고 컨트롤(제어권)이 이동한다.</p>
<p><img src="https://poiemaweb.com/img/ec_1.png" alt="https://poiemaweb.com/img/ec_1.png"></p>
<h3 id="1-전역-코드-평가와-실행"><a href="#1-전역-코드-평가와-실행" class="headerlink" title="1. 전역 코드 평가와 실행"></a>1. 전역 코드 평가와 실행</h3><ul>
<li>자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시한다.</li>
<li>전역 변수 x와 전역 함수 foo는 전역 실행 컨텍스트에 등록됨</li>
<li>전역 코드가 실행되면 👉 전역 변수 x에 값이 할당되고 전역 함수 foo가 실행</li>
</ul>
<h3 id="2-foo-함수-코드의-평가와-실행"><a href="#2-foo-함수-코드의-평가와-실행" class="headerlink" title="2. foo 함수 코드의 평가와 실행"></a>2. foo 함수 코드의 평가와 실행</h3><ul>
<li>함수 foo가 호출되면 전역 코드의 실행은 일시 중단되고 <strong>코드의 제어권</strong>이 foo 함수 내부로 이동</li>
<li>자바스크립트 엔진은 foo 함수 내부의 함수 코드를 평가하여 foo 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시</li>
<li>이때 foo 함수의 지역 변수 y와 중첩 함수 bar가 foo 함수 실행 컨텍스트에 등록됨</li>
<li>이후 foo 함수 코드가 실행되면 👉 지역 변수 y에 값이 할당되고 중첩 함수 bar가 실행</li>
</ul>
<h3 id="3-bar-함수-코드의-평가와-실행"><a href="#3-bar-함수-코드의-평가와-실행" class="headerlink" title="3. bar 함수 코드의 평가와 실행"></a>3. bar 함수 코드의 평가와 실행</h3><ul>
<li>중첩 함수 bar가 호출되면 foo 함수 코드 실행은 중단되고 코드의 제어권이 bar 함수 내부로 이동</li>
<li>자바스크립트 엔진은 bar 함수 내부의 함수 코드를 평가하여 bar 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시</li>
<li>지역 변수 z와 bar가 bar 함수 실행 컨텍스트에 등록됨</li>
<li>bar 함수가 실행되면 👉 지역 변수 z에 값이 할당되고 console.log 메서드를 호출한 이후 bar 함수 종료</li>
</ul>
<h3 id="4-foo-함수-코드로-복귀"><a href="#4-foo-함수-코드로-복귀" class="headerlink" title="4. foo 함수 코드로 복귀"></a>4. foo 함수 코드로 복귀</h3><ul>
<li>bar 함수가 종료되면 코드의 제어권을 foo 함수로 이동</li>
<li>자바스크립트 엔진은 bar 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거</li>
<li>foo 함수는 더 이상 실행할 코드가 없으므로 종료</li>
</ul>
<h3 id="5-전역-코드로-복귀"><a href="#5-전역-코드로-복귀" class="headerlink" title="5. 전역 코드로 복귀"></a>5. 전역 코드로 복귀</h3><ul>
<li>foo 함수가 종료되면 코드의 제어권은 다시 전역 코드로 이동</li>
<li>자바스크립트 엔진은 foo 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거</li>
<li>더 이상 실행할 전역 코드가 남아 있지 않으므로 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 제거</li>
<li>실행 컨텍스트 스택에는 아무것도 남아있지 않음</li>
</ul>
<p><strong>👉 이처럼 실행 컨텍스트 스택은 코드의 실행 순서를 관리한다.</strong></p>
<ul>
<li>소스코드가 평가되면 실행 컨텍스트가 생성 → 실행 컨텍스트 스택의 최상위에 쌓인다.</li>
<li>따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 <strong>실행 중인 실행 컨텍스트( running execution context)</strong> 라 부른다.</li>
</ul>
<h2 id="렉시컬-환경"><a href="#렉시컬-환경" class="headerlink" title="렉시컬 환경"></a>렉시컬 환경</h2><h3 id="✅-렉시컬-환경"><a href="#✅-렉시컬-환경" class="headerlink" title="✅ 렉시컬 환경"></a>✅ 렉시컬 환경</h3><p>: 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조, 실행 컨텍스트를 구성하는 컴포넌트</p>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8697dd5f-901c-4017-b0b2-d7e10c0c2888%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8697dd5f-901c-4017-b0b2-d7e10c0c2888%2Fimage.png"></p>
<ul>
<li>실행 컨텍스트 스택: <strong>코드의 실행순서를 관리</strong>한다면</li>
<li>렉시컬 환경: <strong>스코프와 식별자</strong>를 관리한다.</li>
<li>키와 값을 갖는 객체 형태의 스코프를 생성 (전역, 함수, 블록 스코프) 👉 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리</li>
</ul>
<p><strong>렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체</strong></p>
<h3 id="실행-컨텍스트의-구성"><a href="#실행-컨텍스트의-구성" class="headerlink" title="실행 컨텍스트의 구성"></a>실행 컨텍스트의 구성</h3><ul>
<li>LexicalEnvironment Component</li>
<li>VariableEnvironment Component</li>
</ul>
<p><strong>생성 초기</strong> 👉 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트는 하나의 동일한 렉시컬 환경을  참조</p>
<p><strong>이후 몇 가지 상황을 만나면 👉</strong> VariableEnvironment 컴포넌트를 위한 새로운 렉시컬 환경을 생성한다.</p>
<p>이때부터 VariableEnvironment 컴포넌트와 LexicalEnvironment 컴포넌트는 내용이 달라지는 경우도 있다.</p>
<h3 id="렉시컬-환경의-구성"><a href="#렉시컬-환경의-구성" class="headerlink" title="렉시컬 환경의 구성"></a>렉시컬 환경의 구성</h3><p>렉시컬 환경은 두 개의 컴포넌트로 구성된다.</p>
<ul>
<li>Environment Record (환경 레코드)</li>
<li>Outer Lexical Environment Reference (외부 렉시컬 환경에 대한 참조)</li>
</ul>
<p>✏️ <strong>환경 레코드</strong></p>
<ul>
<li>스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소</li>
<li>환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다.</li>
</ul>
<p>✏️ <strong>외부 렉시컬 환경에 대한 참조</strong></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다.</li>
<li>상위 스코프란 외부 렉시컬 환경 👉 즉, 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경</li>
<li>외부 렉시컬 환경에 대한 참조를 통해 <strong>단방향 링크드 리스트인 스코프 체인</strong>을 구현</li>
</ul>
<h2 id="실행-컨텍스트와-블록-레벨-스코프"><a href="#실행-컨텍스트와-블록-레벨-스코프" class="headerlink" title="실행 컨텍스트와 블록 레벨 스코프"></a>실행 컨텍스트와 블록 레벨 스코프</h2><p>🔥 어떻게 실행 컨텍스트가 생성되는가? (실행 컨텍스트 생성 과정)<br>🔥 어떻게 코드 실행 결과가 관리되는가?<br>🔥 어떻게 실행 컨테스트를 통해 식별자를 검색하는가?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="1-전역-객체-생성"><a href="#1-전역-객체-생성" class="headerlink" title="1. 전역 객체 생성"></a>1. 전역 객체 생성</h3><ul>
<li>전역 객체는 전역 코드가 평가되기 이전에 생성된다.</li>
<li>이때 전역 객체에 생성되는 것<ul>
<li>빌트인 전역 프로퍼티</li>
<li>빌트인 전역 함수</li>
<li>표준 빌트인 객체</li>
<li>동작 환경에 따라 클라이언트 사이드 Web API 또는 특정 환경을 위한 호스트 객체 포함</li>
</ul>
</li>
<li>전역 객체도 Object.portotype을 상속 받는다. 👉 전역 객체도 프로토타입 체인의 일원</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.prototype.toString</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">toString</span>(); <span class="comment">// -&gt; &quot;[object Window]&quot;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-전역-코드-평가"><a href="#2-전역-코드-평가" class="headerlink" title="2. 전역 코드 평가"></a>2. 전역 코드 평가</h3><ul>
<li>소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가</li>
<li>전역 코드 평가 순서<ol>
<li><strong>전역 실행 컨텍스트 생성</strong></li>
<li><strong>전역 렉시컬 환경 생성</strong><ol>
<li>전역 <strong>환경 레코드</strong> 생성<ol>
<li>객체 환경 레코드 생성</li>
<li>선언적 환경 레코드 생성</li>
</ol>
</li>
<li>this 바인딩</li>
<li><strong>외부 렉시컬 환경에 대한 참조</strong> 결정</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>🙌🏻 위 과정을 거쳐 생성된 전역 실행 컨텍스트와 렉시컬 환경은 아래 그림과 같다.</p>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F80500ef0-a74a-41f9-abfe-d5d9277a664f%2Fjavascript-context08.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F80500ef0-a74a-41f9-abfe-d5d9277a664f%2Fjavascript-context08.png"></p>
<p>📚 <strong>세부적인 생성 과정 살펴보기</strong></p>
<p><strong>1. 전역 실행 컨텍스트 생성</strong></p>
<ul>
<li>먼저 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 push</li>
<li>이때 전역 실행 컨텍스트는 running execution context가 된다.</li>
</ul>
<p><strong>2. 전역 렉시컬 환경 생성</strong></p>
<ul>
<li>전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 <strong>바인딩</strong>한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fbc8bca2e-04e7-4533-b8bd-e58b79f770e3%2Fjavascript-context06.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fbc8bca2e-04e7-4533-b8bd-e58b79f770e3%2Fjavascript-context06.png"></p>
<ul>
<li><p>렉시컬 환경은 2개의 컴포넌트, <strong>환경 레코드</strong>와 <strong>외부 렉시컬 환경에 대한 참조</strong>로 구성된다.</p>
<p><strong>2.1. 전역 환경 레코드 생성</strong></p>
<ul>
<li><p>전역 환경 레코드: 전역 렉시컬 환경을 구성하는 컴포넌트</p>
</li>
<li><p>전역 환경 레코드가 제공하는 것</p>
<ul>
<li>전역 변수를 관리하는 전역 스코프</li>
<li>전역 객체의 빌트인 전역 프로퍼티</li>
<li>빌트인 전역 함수</li>
<li>표준 빌트인 객체</li>
</ul>
</li>
<li><p>ES6 이전</p>
<ul>
<li>모든 전역 변수가 전역 객체의 프로퍼티</li>
<li>전역 객체가 전역 환경 레코드의 역할을 수행함</li>
</ul>
</li>
<li><p>ES6</p>
<ul>
<li><p>전역 환경 레코드 : let, const 키워드로 선언한 전역 변수를 구분하여 관리하기 위해 전역 스코프 역할을 한다.</p>
</li>
<li><p>전역 환경 레코드 구성요소</p>
<ol>
<li><strong>Object Environmnet Record (객체 환경 레코드)</strong> : var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 관리</li>
<li><strong>Declarative Environment Record (선언적 환경 레코드)</strong> : let, const 키워드로 선언한 전역 변수를 관리</li>
</ol>
<p>👉 전역 환경 레코드의 객체 환경 레코드와 선언적 환경 레코드는 서로 협력하여 전역 스코프와 전역 객체(전역 변수의 전역 객체 프로퍼티화)를 관리한다.</p>
</li>
</ul>
<p>✏️ <strong>객체 환경 레코드 생성</strong></p>
<ul>
<li><p>전역 환경 레코드를 구성하는 컴포넌트인 객체 환경 레코드는 <code>BindingObject</code> 라고 부르는 객체와 연결된다.</p>
</li>
<li><p><strong>BindingObject: 전역 객체 생성에서 생성된 전역 객체</strong></p>
</li>
<li><p>전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수</p>
<ul>
<li>객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체 프로퍼티와 메서드가 된다.</li>
</ul>
</li>
<li><p>이때 등록된 식별자를 전역 환경 레코드의 객체 환경 레코드에서 검색하면 전역 객체의 프로퍼티를 검색하여 반환</p>
<p>👉 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수가 전역 객체 프로퍼티와 메서드가 되고 전역 객체를 가리키는 식별자(window) 없이 전역 객체의 프로퍼티를 참조할 수 있는 매커니즘</p>
</li>
<li><p>위 예제의 전역 변수 x와 전역 함수 foo는 객체 환경 레코드를 통해 객체 환경 레코드의 BindingObject에 바인딩 되어있는 전역 객체의 프로퍼티와 메서드가 된다.</p>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8d77a5f4-2b7a-454d-a6aa-b5bda1943a6e%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F8d77a5f4-2b7a-454d-a6aa-b5bda1943a6e%2Fimage.png"></p>
<ul>
<li><p>x 변수는 var 키워드로 선언한 변수</p>
<p>👉 선언 단계와 초기화 단계가 동시에 진행</p>
</li>
<li><p>전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록한 다음 암묵적으로 undefined를 바인딩</p>
<p>👉 var 키워드로 선언한 변수는 <strong>코드 실행 단계</strong>에서 변수 선언문 이전에 참조할 수 있다. (코드 평가 단계 x)</p>
</li>
<li><p>단, 변수 선언문 이전에 참조한 변수의 값은 언제나 undefined (var 키워드로 선언한 변수에 할당한 함수 표현식도 이와 동일하게 작용)</p>
<p>👉 <strong>변수 호이스팅</strong>이 발생하는 원인</p>
</li>
<li><p>함수 선언문으로 정의한 함수가 평가되면 함수 이름과 동일한 이름의 식별자를 객체 환경 레코드에 바인딩된 <strong>BindingObject를 통해 전역 객체에 키로 등록하고 생성된 함수 객체를 즉시 할당</strong>한다.</p>
<p>👉 함수 호이스팅과 변수 호이스팅의 차이 (함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.)</p>
</li>
</ul>
<p>✏️ <strong>선언적 환경 레코드 생성</strong></p>
<ul>
<li><p>let, const 키워드로 선언한 전역 변수(let, const 키워드로 선언한 변수에 할당한 함수 표현식 포함)</p>
</li>
<li><p>위 예제의 변수 y는 const 키워드로 선언한 변수이므로 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재</p>
<p>👉 개념적인 블록이 바로 <strong>전역 환경 레코드의 선언적 환경 레코드</strong></p>
<ul>
<li>전역 변수 y는 let, const 키워드로 선언한 변수이므로 전역 객체의 프로퍼티가 아니다.</li>
<li>window.y와 같이 전역 객체의 프로퍼티로서 참조할 수 없다.</li>
<li>const 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.</li>
<li>따라서 초기화 단계 즉, 런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 <strong>일시적 사각지대</strong>에 빠지게 된다.</li>
</ul>
</li>
<li><p>y 변수에 바인딩 되어있는 uninitialized는 초기화 단계가 진행되지 않아 변수에 접근할 수 없음을 나타내기 위한 표현이며, 실제로 값이 바인딩된 것이 아니다.</p>
</li>
<li><p>let, const 키워드로 선언한 변수도 변수 호이스팅이 발생한 것은 변함이 없다.</p>
</li>
<li><p>단, let, const 키워드로 선언한 변수는 런타임에 컨트롤(제어권)이 변수 선언문에 도달하기 전까지 일시적 사각지대에 빠지기 때문에 참조할 수 없다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// let, const 키워드로 선언한 변수가 호이스팅되지 않는다면 전역 변수를 참조해야 한다.</span></span><br><span class="line">  <span class="comment">// 하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다.</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError: Cannot access &#x27;foo&#x27; before initilization</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// 지역 변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2.2. this 바인딩</strong></p>
<ul>
<li>전역 환경 레코드의 <code>[[GlobalThisValue]]</code> 내부 슬롯에 this가 바인딩</li>
<li>전역 코드에서 this는 → 전역 객체를 가리키므로 환경 레코드의 <code>[[GlobalThisValue]]</code> 내부 슬롯에는 전역 객체가 바인딩된다.</li>
<li>전역 코드에서 this를 참조하면? → 전역 환경 레코드의 <code>[[GlobalThisValue]]</code> 내부 슬롯에 바인딩 되어있는 객체가 반환</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F9323ab1f-8282-41aa-95c9-3a121d011221%2Fjavascript-context09.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F9323ab1f-8282-41aa-95c9-3a121d011221%2Fjavascript-context09.png"></p>
<ul>
<li>전역 환경 레코드를 구성하는 객체 환경 레코드와 선언전 환경 레코드에는 this 바인딩이 없다.<br>👉 this 바인딩은 <strong>전역 환경 레코드</strong>와 <strong>함수 환경 레코드</strong>에만 존재</li>
</ul>
<p><strong>2.3. 외부 렉시컬 환경에 대한 참조 결정</strong></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경 👉 상위 스코프</li>
<li>현재 평가 중인 소스코드는? → 전역 코드</li>
<li>전역 코드를 포함하는 소스코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 null이 할당된다. 👉 전역 렉시컬 환경이 <strong>스코프 체인의 종점</strong>에 존재함을 의미</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2Fdb7710eb-6885-4f19-b25a-d5365494ccba%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2Fdb7710eb-6885-4f19-b25a-d5365494ccba%2Fimage.png"></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조를 통해 스코프 체인을 구현하는 메커니즘</li>
</ul>
</li>
</ul>
<h3 id="3-전역-코드-실행"><a href="#3-전역-코드-실행" class="headerlink" title="3. 전역 코드 실행"></a>3. 전역 코드 실행</h3><ul>
<li>이제 전역 코드가 순차적으로 <strong>실행</strong></li>
<li>변수 할당문이 실행되어 전역 변수 x, y에 값이 할당 그리고 foo 함수 호출</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F148a74ef-a9fd-411c-b61a-6ca895de14df%2Fjavascript-context11.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F148a74ef-a9fd-411c-b61a-6ca895de14df%2Fjavascript-context11.png"></p>
<ul>
<li>변수 할당문 또는 변수 호출문을 실행하려면? → 변수 또는 함수 이름이 선언된 식별자인지 확인</li>
<li>선언되지 않는 식별자는 참조할 수 없으므로 할당이나 호출이 불가</li>
<li>또한 식별자는 스코프가 다르면 같은 일므을 가질 수 있다. (동일한 이름의 식별자가 다른 스코프에 여러 개 존재할 수 있다.) 👉 어느 스코프의 식별자를 참조하면 되는지 결정할 필요가 있다. 이를 <strong>identifier resolution(식별자 결정)</strong> 이라고 한다.</li>
</ul>
<h3 id="✅-식별자-결정"><a href="#✅-식별자-결정" class="headerlink" title="✅ 식별자 결정"></a>✅ 식별자 결정</h3><p>: 어느 스코프의 식별자를 참조해야하는지 결정하는 것</p>
<ul>
<li>식별자 결정을 위해 식별자를 검색할 때는 <strong>실행 중인 실행 컨텍스트에서 식별자를 검색</strong>하기 시작<ul>
<li>선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 <strong>환경 레코드</strong>에 등록</li>
</ul>
</li>
<li>현재 실행 중인 컨텍스트는? 👉 전역 실행 컨텍스트이므로 전역 렉시컬 환경에서 식별자 x, y, foo를 검색하기 시작</li>
<li>만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면? → 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경 즉, 상위 스코프로 이동하여 식별자를 검색 👉 <strong>스코프 체인의 동작 원리</strong></li>
<li>전역 렉시컬 환경은 스코프 체인의 종점이므로 전역 렉시컬 환경에서 검색할 수 없는 참조 에러를 발생시킴</li>
</ul>
<blockquote>
<p>🔥 이처럼 실행 컨텍스트는 소스코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</p>
</blockquote>
<h3 id="4-foo-함수-코드-평가"><a href="#4-foo-함수-코드-평가" class="headerlink" title="4. foo 함수 코드 평가"></a>4. foo 함수 코드 평가</h3><p>현재 상태는? → 전역 코드 평가를 통해 전역 실행 컨텍스트가 생성되었고 전역 코드를 실행하고 있다.</p>
<p>(현재 상태 foo 함수를 호출하기 직전)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>); <span class="comment">// ← 호출 직전</span></span><br></pre></td></tr></table></figure>

<ul>
<li>foo 함수가 호출되면 전역 코드의 실행을 일시 중단 → foo 함수 내부로 코드의 제어권이 이동</li>
<li>함수 코드 평가 시작 (실행 순서)<ol>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ol>
<li>함수 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F9cee357b-0ed8-4375-9842-58b5fc3e3e8e%2Fimage.png" alt="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F9cee357b-0ed8-4375-9842-58b5fc3e3e8e%2Fimage.png"></p>
<p><strong>📚 세부적인 생성 과정 살펴보기</strong></p>
<ol>
<li><strong>함수 실행 컨텍스트 생성</strong><ul>
<li>foo 함수 실행 컨텍스트르 생성 → 함수 렉시컬 환경이 완성된 다음 실행 컨텍스트 스택에 push<ul>
<li>이때 foo 함수 실행 컨텍스트는 실행 컨텍스트 스택의 최상위 &#x3D; 실행중인 실행 컨텍스트</li>
</ul>
</li>
</ul>
</li>
<li><strong>함수 렉시컬 환경 생성</strong></li>
</ol>
<ul>
<li>foo 함수 렉시컬 환경을 생성하고 foo 함수 실행 컨텍스트에 바인딩</li>
</ul>
<p><strong>2.1. 함수 환경 레코드 생성</strong></p>
<p>함수 렉시컬 환경을 구성하는 컴포넌트 중 하나인 함수 환경 레코드가 관리하는 것들</p>
<ul>
<li>매개변수</li>
<li>arguments 객체</li>
<li>함수 내부에서 선언한 지역 변수</li>
<li>함수 내부에서 선언한 중첩 함수</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ff6edb09d-44c5-4f97-b1c3-472713f17d41%2Fjavascript-context13.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ff6edb09d-44c5-4f97-b1c3-472713f17d41%2Fjavascript-context13.png"></p>
<p><strong>2.2. this 바인딩</strong></p>
<ul>
<li>함수 환경 레코드의 <code>[[ThisisValue]]</code> 내부 슬롯에 this 바인딩</li>
<li><code>[[ThisisValue]]</code> 내부 슬롯에 바인딩된 객체는 <strong>함수 호출 방식에 따라 결정</strong></li>
<li>foo 함수는 일반 함수로 호출 👉 this는 전역 객체를 가리킨다.</li>
<li></li>
<li>환경 함수 레코드의 <code>[[ThisisValue]]</code> 내부 슬롯에는 전역 객체가 바인딩</li>
<li>foo 함수 내부에서 this를 참조하면? → 함수 환경 레코드의 <code>[[ThisisValue]]</code> 내부 슬롯에 바인딩 되어있는 객체가 반환</li>
</ul>
<p><strong>2.3. 외부 렉시컬 환경에 대한 참조 결정</strong></p>
<ul>
<li>외부 렉시컬 환경에 대한 참조에 <strong>foo 함수 정의가 평가된 시점</strong>에 실행 중인 컨텍스트의 렉시컬 환경에 대한 참조가 할당된다.</li>
<li>foo 함수가 평가된 시점은? → 전역 코드에 정의된 전역 함수<ul>
<li>foo 함수 정의는 전역 코드 평가 시점에 평가된다.</li>
</ul>
</li>
<li>이 시점의 실행 중인 컨텍스트는? → <strong>전역 실행 컨텍스트</strong></li>
<li>따라서 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경의 참조가 할당된다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F75bb6fb2-0c48-4c68-8f30-4c575cc1952c%2Fjavascript-context15.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F75bb6fb2-0c48-4c68-8f30-4c575cc1952c%2Fjavascript-context15.png"></p>
<blockquote>
<p>자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다. 👉 <code>렉시컬 스코프</code></p>
<p>함수 객체는 자신이 정의된 스코프, 상위 스코프를 기억한다.</p>
</blockquote>
<ul>
<li>자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 <strong>현재 실행 중인 실행 컨텍스트의 렉시컬 환경</strong> 즉, 함수의 <strong>상위 스코프</strong>를 함수 객체의 내부 슬롯 <code>[[Environment]]</code> 에 저장한다.</li>
<li>함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당하는 것 👉 상위 스코프를 가리키는 함수 객체의 내부 슬롯 <code>[[Environment]]</code> 에 저장된 렉시컬 환경의 참조</li>
<li><strong>즉, 함수 객체의 내부 슬롯 <code>[[Environment]]</code> 가 바로 렉시컬 스코프를 구현하는 매커니즘이다.</strong></li>
</ul>
<p>함수 객체의 내부 슬롯 [[Environment]] 와 렉시컬 스코프는 클로저를 이해할 수 있는 중요한 단서다. 👉 <code>클로저</code></p>
<h3 id="5-foo-함수-코드-실행"><a href="#5-foo-함수-코드-실행" class="headerlink" title="5. foo 함수 코드 실행"></a>5. <strong>foo 함수 코드 실행</strong></h3><ul>
<li>이제 런타임이 시작되어 foo 함수의 소스코드가 순차적으로 실행되기 시작한다.</li>
<li>매개변수에 인수가 할당 → 변수 할당문이 실행 → 지역 변수 x, y에 값이 할당 → 함수 bar 호출</li>
<li>이때 식별자 결정을 위해 실행 중인 컨텍스트의 렉시컬 환경에서 식별자를 검색</li>
<li>현재 실행 중인 컨텍스트는? → foo 함수 실행 컨텍스트</li>
<li>foo 함수 렉시컬 환경에서 식별자 x, y를 검색<ul>
<li>실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면? -&gt; 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자 검색</li>
<li>검색 후 검색된 식별자에 값을 바인딩</li>
</ul>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fd4d9f9d5-6788-4fd1-9d84-2e4ea4751169%2Fjavascript-context16.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Fd4d9f9d5-6788-4fd1-9d84-2e4ea4751169%2Fjavascript-context16.png"></p>
<h3 id="6-bar-함수-코드-평가"><a href="#6-bar-함수-코드-평가" class="headerlink" title="6. bar 함수 코드 평가"></a>6. bar 함수 코드 평가</h3><ul>
<li>현재 상태? → foo 함수 코드 평가를 통해 foo 함수 실행 컨텍스트가 생성되었고 foo 함수 코드 실행 중 (bar 함수를 호출하기 직전)</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>); <span class="comment">// ← 호출 직전</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>bar 함수가 호출되면 bar 함수 내부로 코드의 제어권이 이동 → bar 함수 코드를 평가하기 시작</li>
<li>실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드 평가와 동일함<ol>
<li>함수 실행 컨텍스트 생성</li>
<li>함수 렉시컬 환경 생성<ol>
<li>함수 환경 레코드 생성</li>
<li>this 바인딩</li>
<li>외부 렉시컬 환경에 대한 참조 결정</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F12c9ca7e-0d11-45a2-a51f-aa63b5d25089%2Fjavascript-context18.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2F12c9ca7e-0d11-45a2-a51f-aa63b5d25089%2Fjavascript-context18.png"></p>
<h3 id="7-bar-함수-코드-실행"><a href="#7-bar-함수-코드-실행" class="headerlink" title="7. bar 함수 코드 실행"></a>7. bar 함수 코드 실행</h3><ul>
<li>이제 런타임이 시작되어 bar 함수 소스코드가 순차적으로 실행</li>
<li>매개변수에 인수 할당, 변수 할당문 실행 → 지역 변수 z에 값이 할당</li>
<li>console.log(a + b + x + y + z)가 실행</li>
</ul>
<p><strong>📃 <code>console.log(a + b + x + y + z)</code> 실행되는 순서</strong></p>
<ol>
<li><p><strong>console 식별자 검색</strong></p>
<ul>
<li>console 식별자를 스코프 체인에서 검색</li>
<li>식별자를 검색할 때는 언제나 현재 실행 중인 컨텍스트의 렉시컬 환경에서 시작</li>
</ul>
<blockquote>
<p>💡 스코프 체인</p>
<p>: 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작 👉 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속</p>
</blockquote>
<ul>
<li>현재 실행 중인 컨텍스트는? → bar 함수 실행 컨텍스트</li>
<li>bar 함수 실행 컨텍스트의 bar 함수 렉시컬 환경에서 console 식별자를 검색하기 시작</li>
<li>이곳에는 console 식별자가 없으므로 스코프 체인 상의 상위 스코프 즉, 외부 렉시컬 환경에 대한 참조가 가리키는 foo 함수 렉시컬 환경으로 이동하여 검색</li>
<li>foo 함수 실행 컨텍스트의 렉시컬 환경에도 없으므로 스코프 체인 상의 상위 스코프 → 전역 렉시컬 환경으로 이동하여 검색</li>
<li>전역 렉시컬 환경은 객체 환경 레코드, 선언적 환경 레코드로 구성되어 있음</li>
<li>console 식별자는 객체 환경 레코드 BindingObject를 통해 전역 객체에서 찾을 수 있다.</li>
</ul>
</li>
<li><p><strong>log 메서드 검색</strong></p>
<ul>
<li>console 식별자에 바이딩된 객체 즉, console 객체에서 log 메서드를 검색</li>
<li>이때 console 객체의 프로토타입 체인을 통해 메서드를 검색</li>
<li>log 메서드는 console 객체가 직접 소유하는 프로퍼티</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;log&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>표현식 a + b + x + y + z의 평가</strong></p>
<ul>
<li>console.log 메서드에 전달한 인수 → a + b + x + y + z를 평가하기 위해 a, b, x, y, z 식별자를 검색</li>
<li>식별자는 실행 중인 실행 컨텍스트 렉시컬 환경에서 시작 👉 외부 렉시컬 환경에 대한 참조로 이어지는 <strong>렉시컬 환경의 연속</strong>에서 검색</li>
<li>a 식별자는? → foo 함수의 렉시컬 환경</li>
<li>b 식별자는? → bar 함수의 렉시컬 환경</li>
<li>x, y 식별자는? → foo 함수의 렉시컬 환경</li>
<li>z 식별자는? → bar 함수의 렉시컬 환경</li>
</ul>
</li>
<li><p><strong>console.log 메서드 호출</strong></p>
<ul>
<li>표현식 a + b + x + y + z가 평가되어 생성한 값 42를 console.log 메서드에 전달하여 호출</li>
</ul>
</li>
</ol>
<h3 id="8-bar-함수-코드-실행-종료"><a href="#8-bar-함수-코드-실행-종료" class="headerlink" title="8. bar 함수 코드 실행 종료"></a>8. bar 함수 코드 실행 종료</h3><ul>
<li>console.log 메서드가 호출되고 종료하면 더는 실행할 코드가 없으므로 bar 코드의 실행이 종료</li>
<li>이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop<ul>
<li>foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.</li>
</ul>
</li>
<li><strong>bar 함수 실행 컨텍스트가 제거되었다고 해서 bar 함수 렉시컬 환경까지 즉시 소멸되는 것은 아니다.</strong></li>
<li>렉시컬 환경은 실행 컨텍스트에 의해 참조되기는 하지만 <strong>독립적인 객체</strong>다.</li>
<li>객체를 포함한 모든 값은 참조되지 않을 때 가비지 컬렉터에 의해 메모리 공간의 확보가 해재되어 소멸한다.</li>
</ul>
<h3 id="9-foo-함수-코드-실행-종료"><a href="#9-foo-함수-코드-실행-종료" class="headerlink" title="9. foo 함수 코드 실행 종료"></a>9. foo 함수 코드 실행 종료</h3><ul>
<li>bar 함수가 호출되고 종료하면 더는 실행할 코드가 없으므로 foo 코드의 실행이 종료됨</li>
<li>이때 실행 컨텍스트 스택에서 foo 함수 실행 컨텍스트 pop<ul>
<li>전역 실행 컨텍스트가 실행 중인 컨텍스트</li>
</ul>
</li>
</ul>
<h3 id="10-전역-코드-실행-종료"><a href="#10-전역-코드-실행-종료" class="headerlink" title="10. 전역 코드 실행 종료"></a>10. 전역 코드 실행 종료</h3><ul>
<li>foo 함수가 종료되면 더는 실행할 전역 코드가 없으므로 코드 실행이 종료되고 전역 실행 컨텍스트도 실행 컨텍스트에서 제거되어 컨텍스트 스택에는 아무것도 남아있지 않게 된다.</li>
</ul>
<h2 id="실행-컨텍스트-생성과-식별자-검색-과정"><a href="#실행-컨텍스트-생성과-식별자-검색-과정" class="headerlink" title="실행 컨텍스트 생성과 식별자 검색 과정"></a>실행 컨텍스트 생성과 식별자 검색 과정</h2><p>let, const 키워드와 블록 레벨 스코프에서 살펴보았듯이 var 키워드로 선언한 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정하는 함수 레벨 스코프를 따른다.</p>
<p>하지만 let, const 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>if문의 코드 블록 내에서 let 키워드로 변수가 선언<ul>
<li>if문의 코드 블록이 실행되면 if문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.</li>
<li>이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 렉시컬 환경을 교체한다.</li>
</ul>
</li>
<li>새롭게 생성된 if문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조 👉 if문이 실행되기 이전의 전역 렉시컬 환경</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fgavri%2Fpost%2F43e900bb-968f-40a8-bf5c-7f721ce5ca8d%2Fimage.png" alt="Global Execution Context의 화살표가 가리키는 방향을 살펴보자."></p>
<p>Global Execution Context의 화살표가 가리키는 방향을 살펴보자.</p>
<p>📃 <strong>if문 뿐만 아니라 블록 레벨 스코프를 생성하는 모든 블록문에 적용</strong></p>
<ul>
<li>for문의 변수 선언문에 let 키워드를 사용한 for문은 코드 블록이 반복해서 실행될 때마다 코드 블록을 위한 새로운 렉시컬 환경 생성</li>
<li>만약 for문의 코드 블록 내에서 정의된 함수가 있다면? 👉 함수의 상위 스코프는 for문의 코드블록이 생성한 렉시컬 환경</li>
<li>이때 함수의 상위 스코프는 for문의 코드 블록이 반복해서 실행될 때마다 식별자의 값을 유지해야 함<ul>
<li>식별자(for문의 변수 선언문 및 for문의 코드 블록 내에서 선언된 지역 변수 등)</li>
</ul>
</li>
</ul>
<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>내가 쓴 코드가 자바스크립트에서 어떻게 동작하는지에 대해서 알 수 있는 기회가 되었다.<br>결과값을 확인하기 위해 주구장창 써왔던 console.log도 어떤 방식으로 값을 출력하는지에 대해서 알게되니 공부를 하면서 하나의 지식을 쌓은 것 같아 기분이 좋다!</p>
<p>실행 컨텍스트를 공부하니 스코프에 대해서도 잘 알아놓으면 좋겠다라는 생각이 든다.다음 자바스크립트 Deep Dive 정리는 스코프 너로 정했다. (๑╹o╹)φ</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>후위연산식(postfix)</title>
    <url>/2022/221014-archive/</url>
    <content><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>후위연산식이 주어지면 연산한 결과를 출력하는 프로그램을 작성하세요.</p>
<p>만약 3*(5+2)-9 을 후위연산식으로 표현하면 352+*9- 로 표현되며 그 결과는 12입니다.</p>
<h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫 줄에 후위연산식이 주어집니다. 연산식의 길이는 50을 넘지 않습니다.</p>
<p>식은 1~9의 숫자와 +, -, *, &#x2F; 연산자로만 이루어진다.</p>
<h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>연산한 결과를 출력합니다.</p>
<h3 id="예제입력"><a href="#예제입력" class="headerlink" title="예제입력"></a>예제입력</h3><p>▣ 입력예제 1</p>
<p>352+*9-</p>
<p>▣ 출력예제 1</p>
<p>12</p>
<hr>
<h2 id="🙌🏻-문제-이해하기"><a href="#🙌🏻-문제-이해하기" class="headerlink" title="🙌🏻 문제 이해하기"></a>🙌🏻 문제 이해하기</h2><p>문제를 해결하기 위해 어떤 방법을 사용해야하는지 생각해보자 :)</p>
<ol>
<li>문자열로 받은 argument를 하나씩 확인해야한다. ➡️ split 메서드 사용하여 배열로 만들기</li>
<li>반복문으로 순회를 하면서 숫자를 만나면 stack에 넣는다.</li>
<li>연산자를 만나면 stack에서 2개의 값을 꺼내 계산한다.</li>
<li>계산한 값을 다시 stack에 넣는다.</li>
<li>반복문이 종료되었을 때 계산된 값을 반환한다.</li>
</ol>
<h2 id="✅-solution"><a href="#✅-solution" class="headerlink" title="✅ solution"></a>✅ solution</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> array = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(item)) stack.<span class="title function_">push</span>(<span class="title class_">Number</span>(item));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> right = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">let</span> left = stack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (item) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left * right);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left + right);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left - right);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">          <span class="keyword">return</span> stack.<span class="title function_">push</span>(left / right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Number</span>(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solution</span>(<span class="string">&#x27;352+*9-&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>이번 문제는 어떻게 풀지만 알고 있으면 쉽게 구현할 수 있는 문제인 것 같았다.</p>
<p>풀면서 오류를 범했던 것이 있다면 stack에 넣을 값을 숫자로 변환하지 않고 그대로 넣어서 결과값이 147이 나와 깜짝 놀랬다는 것… (앗차차 나의 실수😃)</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>실행 컨텍스트 - 실행 컨텍스트가 하는 역할이 무엇일까?</title>
    <url>/2022/221012-archive/</url>
    <content><![CDATA[<p>자바스크립트 Deep Dive를 공부하고 정리해보자 :)<br>실행 컨텍스트가 무슨 역할을 하는지에 대해서 알아보자.</p>
<h2 id="소스코드의-타입"><a href="#소스코드의-타입" class="headerlink" title="소스코드의 타입"></a>소스코드의 타입</h2><p>ECMAScript 사양은 소스코드를 4가지 타입으로 구분한다.</p>
<p>4가지 타입의 소스코드는 실행 컨텍스트를 생성한다.</p>
<table>
<thead>
<tr>
<th>소스코드의 타입</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>전역 코드</td>
<td>전역에 존재하는 소스코드를 말한다.</td>
</tr>
<tr>
<td>전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.</td>
<td></td>
</tr>
<tr>
<td>함수 코드</td>
<td>함수 내부에 존재하는 소스코드를 말한다.</td>
</tr>
<tr>
<td>함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.</td>
<td></td>
</tr>
<tr>
<td>eval 코드</td>
<td>빌트인 전역 함수인 [[eval 함수]]에 인수로 전달되어 실행되는 소스코드를 말한다.</td>
</tr>
<tr>
<td>모듈 코드</td>
<td>모듈 내부에 존재하는 소스코드를 말한다.</td>
</tr>
<tr>
<td>모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.</td>
<td></td>
</tr>
</tbody></table>
<h3 id="소스코드를-4가지-타입으로-구분하는-이유"><a href="#소스코드를-4가지-타입으로-구분하는-이유" class="headerlink" title="소스코드를 4가지 타입으로 구분하는 이유"></a><strong>소스코드를 4가지 타입으로 구분하는 이유</strong></h3><p>소스코드의 타입에 따라 실행 컨텍스트를 실행하는 과정과 관리 내용이 다르기 때문이다.</p>
<h3 id="전역-코드"><a href="#전역-코드" class="headerlink" title="전역 코드"></a><strong>전역 코드</strong></h3><ul>
<li>전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다.</li>
<li>그리고 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 한다. 👉 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.</li>
</ul>
<h3 id="함수-코드"><a href="#함수-코드" class="headerlink" title="함수 코드"></a><strong>함수 코드</strong></h3><ul>
<li>함수 코드는 지역 스코프를 생성</li>
<li>지역 변수, 매개변수, arguments 객체를 관리해야 한다.</li>
<li>그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체이의 일원으로 연결해야 한다.</li>
</ul>
<p>👉 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.</p>
<h3 id="eval-코드"><a href="#eval-코드" class="headerlink" title="eval 코드"></a>eval 코드</h3><ul>
<li>strict mode에서 자신만의 독자적인 스코프를 생성한다.</li>
</ul>
<p>👉 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다.</p>
<h3 id="모듈-코드"><a href="#모듈-코드" class="headerlink" title="모듈 코드"></a>모듈 코드</h3><ul>
<li>모듈 코드는 모듈별로 독자적인 모듈 스코프를 생성한다.</li>
</ul>
<p>👉 이를 위해 모듈 코드가 평가되면 함수 실행 컨텍스트가 생성된다.</p>
<h2 id="소스코드의-평가와-실행"><a href="#소스코드의-평가와-실행" class="headerlink" title="소스코드의 평가와 실행"></a>소스코드의 평가와 실행</h2><p>모든 소스코드는 실행에 앞서 <strong>평가 과정</strong>을 거치며 코드를 실행하기 위한 준비를 한다.</p>
<p>👉 <em>즉, 자바스크립트 엔진은 2개의 과정으로 나누어 처리한다.</em></p>
<h3 id="소스코드의-평가-과정"><a href="#소스코드의-평가-과정" class="headerlink" title="소스코드의 평가 과정"></a>소스코드의 평가 과정</h3><ul>
<li><p><strong>실행 컨텍스트</strong>를 생성</p>
</li>
<li><p>변수, 함수 등의 선언문만 먼저 실행</p>
<p>👉 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다.</p>
</li>
</ul>
<p><img src="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ffbef7e69-646e-444f-86c6-86c6fe64c8df%2Fjavascript-context01.png" alt="https://velog.velcdn.com/images%2Fhangem422%2Fpost%2Ffbef7e69-646e-444f-86c6-86c6fe64c8df%2Fjavascript-context01.png"></p>
<h3 id="소스코드-평가-과정이-끝나면-소스코드가-순차적으로-실행되기-시작한다"><a href="#소스코드-평가-과정이-끝나면-소스코드가-순차적으로-실행되기-시작한다" class="headerlink" title="소스코드 평가 과정이 끝나면 소스코드가 순차적으로 실행되기 시작한다."></a>소스코드 평가 과정이 끝나면 소스코드가 순차적으로 실행되기 시작한다.</h3><p>👉 즉, 런타임이 시작된다.</p>
<ul>
<li>소스코드 실행에 필요한 정보<ul>
<li>변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다.</li>
</ul>
</li>
<li>변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.</li>
</ul>
<p>예를 들어, 다음과 같은 소스코드가 실행된다고 생각해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>🙌🏻 <strong>자바스크립트 엔진은 위 예제를 2개의 과정으로 나누어 처리한다.</strong></p>
<ol>
<li>소스코드 평가 과정에서 변수 선언문 <strong>var x</strong>를 먼저 실행한다.<ol>
<li>이때 생성된 변수 식별자 x는 실행 컨텍스트가 관리하는 <strong>스코프에 등록</strong></li>
<li>undefined로 초기화</li>
</ol>
</li>
<li>소스코드 평가 과정이 끝나면 소스코드 실행 과정이 시작된다.<ol>
<li>변수 할당문 x &#x3D; 1 만 실행한다.</li>
<li>이때 x 변수에 값을 할당하려면 먼저 x 변수가 선언된 변수인지 확인해야 한다.</li>
<li>이를 위해 실행 컨텍스트가 관리하는 스코프에 x 변수가 등록되어 있는지 확인한다.</li>
</ol>
</li>
</ol>
<h2 id="실행-컨텍스트의-역할"><a href="#실행-컨텍스트의-역할" class="headerlink" title="실행 컨텍스트의 역할"></a>실행 컨텍스트의 역할</h2><p>🙌🏻 전역 코드와 함수 코드로 구성되어 있는 예제를 살펴보면서 자바스크립트 엔진이 이 예제를 어떻게 평가하고 실행할지 생각해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 전역 변수 선언</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 정의</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="comment">// 지역 변수 선언</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 메서드 호출</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + x + y); <span class="comment">// 130</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 메서드 호출</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x + y); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="1-전역-코드-평가"><a href="#1-전역-코드-평가" class="headerlink" title="1. 전역 코드 평가"></a>1. 전역 코드 평가</h3><ul>
<li><p>전역 코드를 실행하기 앞서 평가 과정을 거치며 “전역 코드를 실행할 준비”를 한다.</p>
</li>
<li><p>소스코드 평가 과정에서는 선언문만 먼저 실행한다.</p>
</li>
<li><p>따라서 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행</p>
<p>👉 <strong>생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프</strong>에 등록된다.</p>
</li>
<li><p>이때 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수</p>
<p>👉 전역 객체의 프로퍼티와 메서드가 된다.</p>
</li>
</ul>
<h3 id="2-전역-코드-실행"><a href="#2-전역-코드-실행" class="headerlink" title="2. 전역 코드 실행"></a>2. 전역 코드 실행</h3><ul>
<li>평가 과정이 끝나면 런타임이 시작되어 전역 코드가 순차적으로 실행된다.</li>
<li>이때 전역 변수에 값이 할당되고 함수가 호출된다.</li>
<li>함수가 호출되면 전역 코드의 실행을 일시 중단하고 함수 내부로 진입한다.</li>
</ul>
<h3 id="3-함수-코드-평가"><a href="#3-함수-코드-평가" class="headerlink" title="3. 함수 코드 평가"></a>3. 함수 코드 평가</h3><ul>
<li><p>함수 내부로 진입하면 함수 내부의 문들을 실행하기 앞서 함수 코드 평가 과정을 거친다.</p>
<p>👉 함수 코드를 실행하기 위한 준비</p>
</li>
<li><p>이때 매개변수와 지역 변수 선언문이 먼저 실행</p>
<p>👉 <strong>생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프</strong>에 등록된다.</p>
</li>
<li><p>또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성</p>
<p>👉 지역 스코프에 등록되고 this 바인딩도 결정된다.</p>
</li>
</ul>
<h3 id="4-함수-코드-실행"><a href="#4-함수-코드-실행" class="headerlink" title="4. 함수 코드 실행"></a>4. 함수 코드 실행</h3><ul>
<li><p>함수 코드 평가 과정이 끝나면 런타임이 시작되어 순차적으로 실행되기 시작</p>
</li>
<li><p>이때 매개변수와 지역 변수에 값이 할당되고, console.log 메서드가 호출된다.</p>
</li>
<li><p>console.log 메서드를 호출하기 위해서</p>
<ol>
<li><dl><dt>식별자인 console을 스코프 체인을 통해 검색</dt><dd>이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 하지만 console 식별자는 스코프 체인에 등록되어 있지 않고 <strong>전역 객체 프로퍼티</strong>로 존재한다.<br>👉 전역 객체 프로퍼티가 마치 전역 변수처럼 전역 스코프를 통해 검색 가능하다는 것을 의미한다.</dd></dl></li>
<li><p>log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색</p>
<p>: 그 후 console.log 메서드에 인수로 전달된 표현식 a + x + y가 평가된다.</p>
</li>
</ol>
</li>
<li><p>console.log 메서드 실행이 종료되면 함수 코드 실행 과정이 종료</p>
</li>
<li><p>함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.</p>
</li>
</ul>
<p>코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값이 관리되어야 한다. 그리고 <strong>중첩 관계에 의해 스코프 체인을 형성</strong>하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다.</p>
<p>또한 함수 호출이 종료되면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다.</p>
<h3 id="✏️-코드가-실행되려면-다음과-같이-스코프-식별자-코드-실행-순서-등의-관리가-필요하다"><a href="#✏️-코드가-실행되려면-다음과-같이-스코프-식별자-코드-실행-순서-등의-관리가-필요하다" class="headerlink" title="✏️ 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다."></a>✏️ 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.</h3><ol>
<li>선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고, 상태 변화를 지속적으로 관리할 수 있어야 한다.</li>
<li>스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다.<ol>
<li>즉, <strong>스코프 체인</strong>을 통해 상위 스코프로 이동하여 식별자를 검색할 수 있어야 한다.</li>
</ol>
</li>
<li>현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.</li>
</ol>
<p>이 모든 것을 관리하는 것이 실행 컨텍스트다.</p>
<h3 id="✅-실행-컨텍스트"><a href="#✅-실행-컨텍스트" class="headerlink" title="✅ 실행 컨텍스트"></a>✅ 실행 컨텍스트</h3><p>: 소스코드를 <strong>실행하는 데 필요한 환경을 제공</strong>하고 코드의 실행 결과를 <strong>실제로 관리</strong>하는 영역</p>
<p>식별자(변수, 함수, 클래스 등의 이름)을 등록하고 관리하는 <strong>스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘</strong></p>
<p><strong>💡 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.</strong></p>
<ul>
<li>식별자와 스코프: 실행 컨텍스트의 <strong>렉시컬 환경</strong>으로 관리</li>
<li>코드 실행 순서: <strong>실행 컨텍스트 스택</strong>으로 관리</li>
</ul>
<hr>
<h2 id="😎-정리하면서-배운-점"><a href="#😎-정리하면서-배운-점" class="headerlink" title="😎 정리하면서 배운 점"></a>😎 정리하면서 배운 점</h2><p>실행 컨텍스트는 소스코드를 실행하고 관리하는 영역이라는 것에 대해서 알게되었다.<br>모든 코드는 실행 컨텍스트에 의해 실행되고 관리된다는 점을 잊지말자.</p>
<p>렉시컬 환경이 무엇이고, 실행 컨텍스트가 무엇인지 매번 들을 때마다 나중에 공부해야지 생각했는데 드디어 공부해야할 때가 온 것 같다.</p>
<p>렉시컬 스코프, 렉시컬 환경, 실행 컨텍스트 스택에 대해서는 다음 블로그에서 알아보자 :)</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>스코프 - 스코프와 스코프의 종류</title>
    <url>/2022/221015-archive/</url>
    <content><![CDATA[<p>📚 스코프는 유효범위이다!<br>스코프에 대해서 알아보고 스코프의 종류에는 어떤 것들이 있는지 알아보자 ๑•‿•๑</p>
<h2 id="스코프란"><a href="#스코프란" class="headerlink" title="스코프란?"></a>스코프란?</h2><blockquote>
<p>스코프(scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다.<br>var 키워드로 선언한 변수와 let, const 키워드로 선언한 변수의 스코프는 다르게 동작한다. 스코프는 변수, 함수와 깊은 관련이 있다.</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="comment">// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.</span></span><br><span class="line">  <span class="comment">// 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부다.</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); <span class="comment">// 2 5</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수는 코드의 가장 바깥 영역뿐 아니라 코드 블록이나 함수 몸체 내에서도 선언할 수 있다.<ul>
<li>이때 코드 블록이나 함수는 중첩될 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var1 = <span class="number">1</span>; <span class="comment">// 코드의 가장 바깥 영역에서 선언한 변수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span>; <span class="comment">// 코드 블록 내에서 선언한 변수</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> var3 = <span class="number">3</span>; <span class="comment">// 중첩된 코드 블록 내에서 선언한 변수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> var4 = <span class="number">4</span>; <span class="comment">// 함수 내에서 선언한 변수</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> var5 = <span class="number">5</span>; <span class="comment">// 중첩된 함수 내에서 선언한 변수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var1); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var2); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var3); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var4); <span class="comment">// ReferenceError: var4 is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(var5); <span class="comment">// ReferenceError: var5 is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수는 자신이 선언된 위치에 의해 자신이 <strong>유효한 범위 👉</strong> 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정된다.</li>
<li>모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다.</li>
</ul>
<h3 id="✅-스코프"><a href="#✅-스코프" class="headerlink" title="✅ 스코프"></a>✅ 스코프</h3><p>: 식별자가 유효한 범위, 식별자를 검색할 때 사용하는 규칙</p>
<p>🙌🏻 다음 에제가 어떻게 동작할지 생각해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// ①</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>

<ul>
<li>코드의 가장 바깥 영역과 foo 함수 내부에 같은 이름을 갖는 x 변수를 선언</li>
<li>①과 ②에서 x 변수를 참조</li>
</ul>
<p>자바스크립트 엔진은 스코프를 통해 두 개의 변수 중에서 어떤 변수를 참조해야할 지를 결정해야 한다. 👉🏻 <strong>식별자 결정</strong></p>
<p>🖥 자바스크립트 엔진은 코드를 실행할 때 <strong>코드의 문맥</strong>을 고려한다.</p>
<ul>
<li><p><strong>코드가 어디서 실행되며 주변에 어떤 코드가 있는지</strong>에 다라 동일한 코드도 다른 결과를 만들어 낸다. <code>👉**렉시컬 환경**</code></p>
</li>
<li><p>즉, 코드의 문맥은 렉시컬 환경이 만들어 낸다. 👉🏻 이를 구현한 것이 <code>**실행 컨텍스트**</code></p>
</li>
<li><p>모든 코드는 실행 컨텍스트에서 평가되고 실행된다. (스코프는 실행 컨텍스트와 깊은 관련이 있다.)</p>
</li>
<li><p>위 예제에서 코드 가장 바깥 영역에 선언된 x변수는 어디서든 참조할 수 있다.</p>
<ul>
<li>하지만 foo 함수 내부에서 선언된 x 변수는 foo 함수 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없다.</li>
<li>이때 두 개의 x 변수는 식별자 이름이 동일하지만, <strong>스코프가 다른 별개의 변수이다.</strong></li>
</ul>
</li>
</ul>
<p><img src="https://blog.kakaocdn.net/dn/cn0zjT/btqZoydJdrc/vHquKk6Vb0mf4PaExIsZX1/img.png" alt="https://blog.kakaocdn.net/dn/cn0zjT/btqZoydJdrc/vHquKk6Vb0mf4PaExIsZX1/img.png"></p>
<ul>
<li>식별자는 어떤 값을 구별할 수 있어야하므로 유일해야 한다.<ul>
<li>따라서 하나의 값은 유일한 식별자에 연결되어야 한다.</li>
</ul>
</li>
</ul>
<p>🙌🏻 컴퓨터의 폴더로 예를 들어보자.</p>
<ul>
<li>파일 이름: 하나의 파일을 구별하여 식별할 수 있는 식별자, 파일 이름은 유일해야하 한다.</li>
<li>파일 이름을 중복해서 사용할 수 있는 이유: 폴더라는 개념이 있기 때문</li>
<li>만약 폴더가 없다면? → 파일 이름은 유일해야 하기 때문에 이름 만드는 것이 번거로워질 것</li>
</ul>
<p>이와 마찬가지로 프로그래밍 언어에서는 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다. 👉 스코프는 <strong>네임스페이스</strong>다.</p>
<hr>
<h2 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h2><ul>
<li>코드는 전역과 지역으로 구분 가능</li>
</ul>
<table>
<thead>
<tr>
<th>구분</th>
<th>설명</th>
<th>스코프</th>
<th>변수</th>
</tr>
</thead>
<tbody><tr>
<td>전역</td>
<td>코드의 가장 바깥 영역</td>
<td>전역 스코프</td>
<td>전역 변수</td>
</tr>
<tr>
<td>지역</td>
<td>함수 몸체 내부</td>
<td>지역 스코프</td>
<td>지역 변수</td>
</tr>
</tbody></table>
<ul>
<li>이때 변수는 자신이 선언된 위치(전역&#x2F; 지역)에 의해 스코프가 결정<br>👉 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수</li>
</ul>
<h3 id="전역과-전역-스코프"><a href="#전역과-전역-스코프" class="headerlink" title="전역과 전역 스코프"></a>전역과 전역 스코프</h3><p><img src="https://velog.velcdn.com/images/starrypro/post/f1f22f08-afa8-4c97-ace9-1f02cf04880a/image.png" alt="https://velog.velcdn.com/images/starrypro/post/f1f22f08-afa8-4c97-ace9-1f02cf04880a/image.png"></p>
<ul>
<li>전역이란? 코드의 가장 바깥 영역</li>
<li>전역은 전역 스코프를 만든다.</li>
<li>전역에 변수를 선언하면? → 전역 스코프를 갖는 전역 변수가 된다.</li>
<li><strong>전역 변수는 어디서든지 참조할 수 있다.</strong></li>
<li>코드 가장 바깥 영역인 전역에서 선언된 x, y 변수 👉 전역 변수<ul>
<li>전역 변수는 어디서든 참조할 수 있으므로 함수 내부에서도 참조 가능</li>
</ul>
</li>
</ul>
<h3 id="지역과-지역-스코프"><a href="#지역과-지역-스코프" class="headerlink" title="지역과 지역 스코프"></a>지역과 지역 스코프</h3><ul>
<li>지역이란? 👉🏻 함수 몸체 내부</li>
<li>지역은 지역 스코프를 만든다.</li>
<li>지역에 변수를 선언하면? 👉🏻 지역 스코프를 갖는 지역 변수가 된다.</li>
<li>지역 변수는 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조할 수 있다.<br>➡️ <strong>지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.</strong></li>
</ul>
<p><strong>📃 outer 함수</strong></p>
<ul>
<li>outer 함수 내부에서 선언된 z 변수는? → 지역 변수</li>
<li>지역 변수 z를 참조할 수 있는 범위: 자신의 <strong>지역 스코프인 outer 함수</strong> 내부 + <strong>하위 지역 스코프인 inner 함수</strong> 내부</li>
<li>하지만 지역 변수 z를 전역에서 참조하면? → 참조에러</li>
</ul>
<p><strong>📃 inner 함수</strong></p>
<ul>
<li>내부에서 선언된 x 변수 이외에 이름이 같은 전역 변수 x가 존재<ul>
<li>이때 내부에서 x 변수를 참조하면? → inner 함수 내부에 선언된 x 변수를 참조 (전역 변수 x)</li>
</ul>
</li>
</ul>
<p>👉 <strong>스코프 체인</strong>을 통해 참조할 변수를 검색했기 때문</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>1부터 N까지의 원소를 갖는 집합의 부분집합 구하기</title>
    <url>/2022/221007-archive/</url>
    <content><![CDATA[<h2 id="✏️-문제"><a href="#✏️-문제" class="headerlink" title="✏️ 문제"></a>✏️ 문제</h2><p>자연수 N이 주어지면 1부터 N까지의 원소를 갖는 집합의 부분집합을 모두 출력하는 프로그램을 작성하세요.</p>
<p>입력설명<br>첫 번째 줄에 자연수 N(1 ≤ N ≤ 10)이 주어집니다.</p>
<p>출력 설명<br>첫 번째 줄부터 각 줄에 하나씩 부분집합을 출력예제와 같은 순서로 출력한다.</p>
<p>입력 예제</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>출력 예제</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="👉-부분-집합을-구하는-문제"><a href="#👉-부분-집합을-구하는-문제" class="headerlink" title="👉 부분 집합을 구하는 문제"></a>👉 부분 집합을 구하는 문제</h3><p>1을 방문을 할 지 안 할지 2가지 선택, 2를 방문을 할 지 안 할지 2가지 선택, 3을 방문을 할 지 안 할지 2가지 선택<br>➡️ 총 8가지의 트리가 만들어진다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">상태트리</span><br><span class="line"></span><br><span class="line">부분집합의 개수 <span class="number">2</span> ^ x - <span class="number">1</span> (공집합 제외)</span><br><span class="line">집합에 원소가 들어갈지 안들어갈지 선택한다.</span><br><span class="line"></span><br><span class="line"><span class="title function_">D</span>(<span class="number">1</span>) -&gt; O -&gt; <span class="title function_">D</span>(<span class="number">2</span>) -&gt; o -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br><span class="line">                  -&gt; x -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br><span class="line">     -&gt; X -&gt; <span class="title function_">D</span>(<span class="number">2</span>) -&gt; o -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br><span class="line">                  -&gt; x -&gt; <span class="title function_">D</span>(<span class="number">3</span>) -&gt; o</span><br><span class="line">                               -&gt; x</span><br></pre></td></tr></table></figure>

<p>문제에서 1부터 N까지의 원소를 갖는 부분집합을 구하라고 했기 때문에, 1부터 N까지의 길이에 0을 담은 체크 배열을 만들어준다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> checkArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>이제 Head 노드에서부터 노드를 방문하면서, 해당 노드를 포함할 것인지 확인하고, 부분 집합을 찾아준다.</p>
<p>(내가 만든 부분 집합에 참여시키고 참여시키지않는 것을 확인 후 배열에 하나씩 담아주면 된다.)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DFS</span>(<span class="params">depth</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth === n + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">// 1로 들어온 것들만 출력하기</span></span><br><span class="line">      <span class="keyword">if</span> (checkArray[i] === <span class="number">1</span>) temp += i + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp.<span class="property">length</span> &gt;= <span class="number">1</span>) answer.<span class="title function_">push</span>(temp.<span class="title function_">trim</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 집합에 포함시킨다.</span></span><br><span class="line">    checkArray[depth] = <span class="number">1</span>;</span><br><span class="line">    <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 집합에 포함시키지 않는다.</span></span><br><span class="line">    checkArray[depth] = <span class="number">0</span>;</span><br><span class="line">    <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="👉-DFS-함수를-잘-살펴보자"><a href="#👉-DFS-함수를-잘-살펴보자" class="headerlink" title="👉  DFS 함수를 잘 살펴보자"></a>👉  DFS 함수를 잘 살펴보자</h3><ol>
<li>부분집합이 주어진 배열의 길이를 넘어갈 수는 없으므로, depth가 배열의 길이와 같다면 재귀를 멈추고, 1로 들어온 인덱스만 출력한다.</li>
<li>depth가 아직 배열의 길이에 도달하지 않으면, 자기 자식 노드를 선택하는 경우와 그렇지 않은 경우를 만들고, 자식을 호출하여 부분집합을 찾아간다.</li>
</ol>
<h3 id="✅-전체-코드"><a href="#✅-전체-코드" class="headerlink" title="✅ 전체 코드"></a>✅ 전체 코드</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = [];</span><br><span class="line">  <span class="keyword">let</span> checkArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">DFS</span>(<span class="params">depth</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth === n + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 1로 들어온 것들만 출력하기</span></span><br><span class="line">        <span class="keyword">if</span> (checkArray[i] === <span class="number">1</span>) temp += i + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp.<span class="property">length</span> &gt;= <span class="number">1</span>) answer.<span class="title function_">push</span>(temp.<span class="title function_">trim</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 집합에 포함시킨다.</span></span><br><span class="line">      checkArray[depth] = <span class="number">1</span>;</span><br><span class="line">      <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 집합에 포함시키지 않는다.</span></span><br><span class="line">      checkArray[depth] = <span class="number">0</span>;</span><br><span class="line">      <span class="title function_">DFS</span>(depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">DFS</span>(<span class="number">1</span>); <span class="comment">// DFS는 1부터 시작한다.</span></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>DFS를 사용하려면 재귀함수가 기본적인 지식으로 깔려 있어야하는 것 같다. 재귀함수를 배웠다고 생각했는데 막상 그것도 아닌가보다. 😟 DFS가 실행되는 과정에 대해서 더 이해하는 과정이 필요할 것 같다. 부분집합을 구하라는 문제를 봤을 때, 어떻게 구해야하지 라고 생각하다가 가지치기 형식으로 그림을 그리다보니 이진트리 형태로 나오는 것을 보면서 이러면 이진트리로 접근해야겠다. 라는 생각이 들었던 것만으로도 오늘은 성공인것 같다!</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>변수 - 우리는 왜 변수를 사용할까?</title>
    <url>/2022/221018-archive/</url>
    <content><![CDATA[<h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><h2 id="변수란-무엇인가-왜-필요한가"><a href="#변수란-무엇인가-왜-필요한가" class="headerlink" title="변수란 무엇인가? 왜 필요한가?"></a>변수란 무엇인가? 왜 필요한가?</h2><p>10 + 20 이라는 코드를 실행하려면 10, 20, + 라는 기호의 의미를 알고 있어야 하며, 10 + 20이라는 식의 의미도 해석할 수 있어야 한다.</p>
<ul>
<li>자바스크립트 엔진이 10 + 20 이라는 코드를 계산하려면 → 평가</li>
<li>먼저 10, 20, +라는 기호의 의미를 알고 있어야 하며 → 리터럴과 연산자</li>
<li>10 + 20이라는 식의 의미도 해석할 수 있어야 한다. → 표현식, 파싱</li>
</ul>
<p>하지만 문제가 있다. CPU가 연산해서 만들어낸 숫자 값 30을 재사용할 수 없다는 것이다. 연산을 했다는 것은 연산 결과가 필요하고 이를 사용해 무언가를 하겠다는 의도가 있었을 것이다. 만약 연산 결과 30을 재사용하고 싶다면 메모리 주소를 통해 연산 결과 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.</p>
<p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공한다.</p>
<h3 id="✅-변수"><a href="#✅-변수" class="headerlink" title="✅ 변수"></a>✅ <strong>변수</strong></h3><p>: 하나의 값을 저장하기 위해 확보한 메모리 공간 또는 메모리 공간을 식별하기 위해 붙인 이름</p>
<ul>
<li>변수 이름: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름</li>
<li>변수 값: 변수에 저장된 값</li>
<li>할당: 변수에 값을 저장하는 것</li>
<li>참조: 변수에 저장된 값을 읽어 들이는 것</li>
</ul>
<h2 id="식별자"><a href="#식별자" class="headerlink" title="식별자"></a>식별자</h2><p><strong>변수 이름</strong>을 식별자라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.</p>
<p>🖥 <strong>값은 메모리 공간에 저장되어 있다.</strong></p>
<p>따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 한다.</p>
<p>👉🏻 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야 한다.</p>
<p><img src="https://velog.velcdn.com/images/arthur/post/dbb4d959-05c8-4df4-afac-e167366c0a13/image.png" alt="https://velog.velcdn.com/images/arthur/post/dbb4d959-05c8-4df4-afac-e167366c0a13/image.png"></p>
<p><img src="https://velog.velcdn.com/images/arthur/post/b379fc11-1ecc-40d2-aca2-56151f132742/image.png" alt="https://velog.velcdn.com/images/arthur/post/b379fc11-1ecc-40d2-aca2-56151f132742/image.png"></p>
<ul>
<li>식별자 result는 값 30을 식별할 수 있다.</li>
<li>이를 위해 식별자 result는 값 30이 저장되어 있는 <strong>메모리 주소 0x0669F913</strong>을 기억해야 한다.</li>
</ul>
<p>👉🏻 즉, 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 매핑 정보도 매모리에 저장되어야 한다.</p>
<p><strong>🖥 식별자는 값이 아니라 메모리 주소를 기억하고 있다.</strong></p>
<ul>
<li>식별자로 값을 구별해서 식별한다는 것 👉🏻 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미</li>
<li>식별자는 <strong>메모리 주소에 붙인 이름</strong>이라고 할 수 있다.</li>
</ul>
<p>💡 <strong>식별자라는 이름은 변수 이름에만 국한해서 사용하지 않는다.</strong></p>
<ul>
<li>변수, 함수, 클래스 등의 이름은 모두 식별자다.</li>
<li>즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자다 .</li>
<li>변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, <strong>선언</strong>에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.</li>
</ul>
<h2 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h2><h3 id="✅-변수-선언"><a href="#✅-변수-선언" class="headerlink" title="✅  변수 선언"></a>✅  변수 선언</h3><p>: 값을 저장하기 위한 <strong>메모리 공간을 확보</strong>하고 <strong>변수 이름과 확보된 메모리 공간의 주소를 연결</strong>해서 값을 저장할 수 있게 준비하는 것</p>
<ul>
<li>선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.</li>
</ul>
<p><strong>🔥 변수를 사용하려면 반드시 선언이 필요하다.</strong></p>
<ul>
<li>선언할 때는 <strong>var, let, const</strong> 키워드를 사용한다.</li>
<li>ES6에서 let, const 키워드가 도입되기 전까지는 var 키워드가 변수를 선언할 수 있는 유일한 키워드였다.</li>
</ul>
<p><strong>✨ 키워드</strong></p>
<p>키워드는 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 <strong>수행할 동작을 규정한 일종의 명령</strong>이다.</p>
<p>자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행한다. 예를 들어, var 키워드를 만나면 자바스크립트 엔진은 뒤에 오는 변수 이름으로 새로운 변수를 선언한다.</p>
<p>🙌🏻 다음 코드를 살펴보자.</p>
<p>var 키워드는 뒤에오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 변수 선언문은 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/arthur/post/68947fa0-da3e-4f1f-97f2-b3bd791953dc/image.png" alt="https://velog.velcdn.com/images/arthur/post/68947fa0-da3e-4f1f-97f2-b3bd791953dc/image.png"></p>
<ul>
<li>변수를 선언한 이후, 아직 변수에 값을 할당하지 않았다.<ul>
<li>따라서, <strong>변수 선언에 의해 확보된 메모리 공간</strong>은 비어있을 것이라고 생각할 수 있으나, 확보된 메모리 공간에는 undefined라는 값이 암묵적으로 할당되어 초기화된다. 👉🏻 자바스크립트의 독특한 특징</li>
</ul>
</li>
</ul>
<p><strong>✨ undefined</strong></p>
<p>undefined는 자바스크립트에서 제공하는 원시 타입의 값이다.</p>
<p>💡 자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다.</p>
<ol>
<li>선언 단계: 변수 이름을 등록 👉🏻 자바스크립트 엔진에게 변수의 존재를 알린다.</li>
<li>초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined을 할당해 초기화한다.</li>
</ol>
<p><strong>✨ 변수 이름은 어디에 등록될까?</strong></p>
<p>변수 이름을 비롯한 모든 식별자는 <strong>실행 컨텍스트</strong>에 등록된다.</p>
<p><strong>실행 컨텍스트</strong> ➡️ 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.</p>
<p>변수 이름과 변수 값은 실행 컨텍스트 내에 키, 값 형식인 객체로 등록되어 관리된다. 자바스크립트 엔진이 변수를 관리하는 매커니즘은 <code>👉실행 컨텍스트</code>에서 자세히 살펴보자.</p>
<ul>
<li>var 키워드를 사용한 변수 선언은 <strong>선언 단계</strong>와 <strong>초기화 단계</strong>가 동시에 진행된다.</li>
<li><code>var score;</code> 는 선언 단계를 통해 ➡️ 변수 이름 score를 등록</li>
<li>초기화 단계를 통해 ➡️ score 변수에 암묵적으로 undefined를 할당해 초기화</li>
</ul>
<p><strong>✅ 초기화(initialization)</strong></p>
<p>: 변수가 선언된 이후 최초로 값을 할당하는 것</p>
<ul>
<li><p>var 키워드로 선언한 변수는 undefined로, <strong>암묵적인 초기화</strong>가 자동 수행된다.</p>
<p>👉🏻 따라서 var 키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.</p>
</li>
<li><p>만약 초기화 단게를 거치지 않으면 어떻게 될까?</p>
<ul>
<li>선언만 하계 되면 공간을 확보한 상태에서 값을 할당해주지 않은 상태이다.</li>
<li>확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 👉🏻 쓰레기 값(garbage value)</li>
</ul>
</li>
</ul>
<p>➡️ 따라서 메모리 공간을 확보한 다음, 값을 할당하지’ 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있다. 자바스크립트 var 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다.</p>
<p><strong>🔥 변수를 사용하면 반드시 선언이 필요하다.</strong></p>
<p>변수 뿐만 아니라 모든 식별자는 선언이 필요하다.</p>
<p>만약 선언하지 않은 식별자에 접근하면? 👉🏻 ReferenceError 발생</p>
<p><strong>✅ ReferenceError</strong></p>
<p>: 식별자를 통해 값을 참조하려 했지만, 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러</p>
<p>✨ <strong>var 키워드로 선언한 변수의 문제점이 무엇일까?</strong></p>
<p>가장 대표적인 것은 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되는 경우가 발생한다. <code>👉 var 키워드로 선언한 변수의 문제점</code></p>
<h2 id="변수-선언의-실행-시점과-변수-호이스팅"><a href="#변수-선언의-실행-시점과-변수-호이스팅" class="headerlink" title="변수 선언의 실행 시점과 변수 호이스팅"></a>변수 선언의 실행 시점과 변수 호이스팅</h2><p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수 선언문보다 변수를 참조하는 코드가 앞에 있다.</li>
<li>자바스크립트 코드는? 👉🏻 인터프리터에 의해 한 줄씩 순차적으로 실행된다.<ul>
<li>console.log(score)가 가장 먼저 실행</li>
<li>순차적으로 다음 줄에 있는 코드를 실행</li>
<li>console.log(score)가 실행되는 시점 👉🏻 아직 score 변수 선언이 실행되지 않았으므로 에러가 발생할 것 같지만, undefined가 출력된다.</li>
</ul>
</li>
</ul>
<p><strong>🔥 왜 첫 번째 <code>console.log(foo)</code> 에서 undefined가 출력될까?</strong></p>
<p>그 이유는 변수 선언이 런타임 이전 단계에서 먼저 실행되기 때문이다.</p>
<ol>
<li>자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.</li>
<li>이때 소스코드 실행을 위한 준비 단계인 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다.</li>
<li>그리고 소스코드 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.</li>
</ol>
<p><strong>👉🏻 즉, 변수 선언이 소스코드의 어디에 있는 상관없이 다른 코드보다 먼저 실행한다. 따라서 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다.</strong></p>
<p>🙌🏻 위 예제를 다시 살펴보자.</p>
<ul>
<li><p>변수 선언문인 <code>var score;</code>보다 변수를 참조하는 코드인 <code>console.log(score);</code>가 앞에 있다.</p>
</li>
<li><p>만약 코드가 순차적으로실행되는 런타임에 변수 선언이 실행된다면 <code>console.log(score);</code> 가 실행되는 시점에는 아직 변수가 선언되기 이전이므로 참조 에러가 발생해야 한다. 하지만 undefined가 출력된다.</p>
<p>👉🏻 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점 즉, 런타임이 아니라 그 이전 단계에서 먼저 실행된다는 증거</p>
</li>
</ul>
<h3 id="✅-변수-호이스팅"><a href="#✅-변수-호이스팅" class="headerlink" title="✅ 변수 호이스팅"></a>✅ 변수 호이스팅</h3><p>: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징</p>
<p>(변수 선언 뿐 아니라 var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다. <strong>모든 선언문은 런타임 이전 단계에서 실행되기 때문이다.</strong>)</p>
<h2 id="값의-할당"><a href="#값의-할당" class="headerlink" title="값의 할당"></a>값의 할당</h2><p>🖥 <strong>변수에 값을 할당할 때</strong>는 할당 연산자 &#x3D;를 사용한다.</p>
<ul>
<li>할당 연산자는 우변의 값을 좌변에 변수에 할당한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언문</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>변수 선언</strong>과 <strong>값의 할당</strong>을 다음과 같이 하나의 문으로 단축 표현할 수도 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>변수 선언과 값의 할당을 2개의 문으로 나누어 표현한 코드와 변수 선언과 값의 할당을 하나의 문으로 단축표현한 코드는 정확히 동일하게 동작한다.</li>
<li>즉, 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.</li>
</ul>
<p>📚 <strong>이때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다.</strong></p>
<p>변수 선언 👉🏻 소스코드가 실행되는 시점인 런타임 이전에 먼저 실행</p>
<p>값의 할당 👉🏻 소스코드가 순차적으로 실행되는 시점인 런타임에 실행</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// ① 변수 선언</span></span><br><span class="line">score = <span class="number">80</span>; <span class="comment">// ② 값의 할당</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// 80</span></span><br></pre></td></tr></table></figure>

<ul>
<li>① 변수 선언 👉🏻 런타임 이전에 먼저 실행</li>
<li>② 값의 할당 👉🏻 런타임에 실행</li>
<li>따라서 score 변수에 값을 할당하는 시점(②)에는 이미 변수 선언이 완료된 상태이며, 이미 undefined로 초기화되어 있다.</li>
<li>따라서 변수에 undefined가 할당되어 초기화되는 것은 변함이 없다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/arthur/post/2e649c6b-9851-4940-a03f-b7bcdb52a1fc/image.png" alt="https://velog.velcdn.com/images/arthur/post/2e649c6b-9851-4940-a03f-b7bcdb52a1fc/image.png"></p>
<ul>
<li>변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고</li>
<li>그 메모리 공간에 할당 값 80을 새롭게 저장하는 것이 아니라 <strong>새로운 메모리 공간을 확보</strong>하고 <strong>그 곳에 할당 값 80을 저장</strong>한다.</li>
</ul>
<p>✨ <strong>변수가 어떻게 생성되며 호이스팅은 어떻게 이루어질까?</strong></p>
<ol>
<li>선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.</li>
<li>초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.</li>
<li>할당 단계: undefined로 초기화된 변수에 실제값을 할당한다.</li>
</ol>
<ul>
<li>var키워드로 선언된 변수는 선언 단계와 초기화 단계가 한 번에 이루어 진다.</li>
<li>즉 스코프에 변수가 등록되고 변수는 메모리 공간을 확보한 후 undefined로 초기화된다.</li>
<li>따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 👉🏻 이러한 현상을 <strong>변수 호이스팅</strong>이라고 한다.</li>
</ul>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5bad11c1-9046-47e0-97c3-0316b7b1c99e/Untitled.png" alt="Untitled"></p>
<p>자바스크립트의 변수는 다른 C-family와는 달리 **블록 레벨 스코프(block-level scope)**를 가지지 않고 **함수 레벨 스코프(function-level scope)**를 갖는다.</p>
<p>단, ES6에서 도입된 let, const 키워드를 사용하면 블록 레벨 스코프를 사용할 수 있다.</p>
<p>✅ <strong>함수 레벨 스코프</strong></p>
<p>: 함수 내에서 선언된 변수는 함수 내에서만 유효하며 외부에서는 사용할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.</p>
<p>✅ <strong>블록 레벨 스코프</strong></p>
<p>: 코드 블록 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.</p>
<h2 id="값의-재할당"><a href="#값의-재할당" class="headerlink" title="값의 재할당"></a>값의 재할당</h2><p><strong>✅ 재할당</strong></p>
<p>: 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것</p>
<p>🙌🏻 score 변수에 새로운 값을 할당해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">score = <span class="number">80</span>; <span class="comment">// 값의 할당</span></span><br><span class="line"><span class="keyword">var</span> score; <span class="comment">// 변수 선언</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>var 키워드로 선언한 변수는 값을 재할당할 수 있다.</strong></p>
<ul>
<li>재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다.</li>
<li>var 키워드로 선언한 변수는 <strong>선언과 동시에 undefined로 초기화</strong>되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 재할당이다.</li>
<li>재할당은 변수에 저장된 값을 다른 값으로 변경 👉🏻 그래서 변수인것</li>
<li>만약 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면? 👉🏻 <strong>상수(constant)</strong><ul>
<li>상수는 단 한 번만 할당할 수 있는 변수다.</li>
</ul>
</li>
</ul>
<p><strong>✨ const 키워드</strong></p>
<p>ES6에서 도입된 const 키워드를 사용해 선언한 변수는 재할당이 금지된다.</p>
<p>👉🏻 즉, const 키워드는 단 한 번만 할당할 수 있는 변수를 선언한다. 따라서 const 키워드를 사용하면 상수를 표현할 수 있다. 하지만 const 키워드는 반드시 상수만을 위해 사용하지 않는다.</p>
<ul>
<li>변수에 값을 할당하면 score 변수의 값은? 👉🏻 이전 값 80에서 재할당한 값 90으로 변경</li>
<li>처음 값을 할당했을 때와 마찬가지로 이전 값 80이 저장되어 메모리 공간을 지우고 그 메모리 공간에 재할당 값 90을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/arthur/post/d4c7e2a3-0e42-42bf-8efc-d58508e936cf/image.png" alt="https://velog.velcdn.com/images/arthur/post/d4c7e2a3-0e42-42bf-8efc-d58508e936cf/image.png"></p>
<ol>
<li>현재 변수의 값은? 👉🏻 90</li>
<li>score 변수의 이전 값인 undefined와 80은 어떤 변수도 값으로 갖고 있지 않다. 👉🏻 어떤 식별자와도 연결되어 있지 않다.</li>
<li><strong>undefined와 80이 더 이상 필요하지 않다는 것을 의미 👉🏻</strong> 이러한 불필요한 값들은 <strong>가비지 콜렉터</strong>에 의해 메모리에서 메모리에서 자동 해제된다. (단, 메모리에서 언제 해제될지는 예측할 수 없다.)</li>
</ol>
<p><strong>✨ 가비지 콜렉터(garbage collector)</strong></p>
<p><a href="https://fe-developers.kakaoent.com/2022/220519-garbage-collection/">자바스크립트 v8 엔진의 가비지 컬렉션 동작 방식</a></p>
<p><strong>✨ 언매니지드 언어와 매니지드 언어</strong></p>
<p>프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지든 언어로 분류할 수 있다.</p>
<ul>
<li>언매니지드 언어<ul>
<li>개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc()과 free() 같은 저수준 메모리 제어 기능을 제공한다.</li>
<li>메모리 제어를 개발자가 주도할 수 있으므로 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만</li>
<li>치명적 오류를 생산할 가능성도 있다.</li>
</ul>
</li>
<li>매니지드 언어<ul>
<li>메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 집적적인 메모리 제어를 허용하지 않는다.</li>
<li>개발자가 명시적으로 메로리를 할당하고 해제할 수 없다.</li>
<li>더 이상 사용하지 않는 메모리의 해제는 가비지 콜렉터가 수행하며, 이 또한 개발자가 관여할 수 없다.</li>
<li>개발자의 역량에 의존한느 부분이 상대적으로 적어 어느정도 일정한 생산성을 확보할 수 있다.</li>
<li>성능 면에서 어느 정도의 손실은 감수할 수밖에 없다.</li>
</ul>
</li>
</ul>
<h2 id="식별자-네이밍-규칙"><a href="#식별자-네이밍-규칙" class="headerlink" title="식별자 네이밍 규칙"></a>식별자 네이밍 규칙</h2><p><strong>✅ 식별자</strong></p>
<p>: 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름</p>
<p>🔥 <strong>식별자는 네이밍 규칙을 준수해야한다.</strong></p>
<ul>
<li>식별자는 특수문자를 제외한 **문자, 숫자, 언더스코어(_), 달러 기호($)**를 포함할 수 있다.</li>
<li>단, 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러기호($)로 시작해야한다.</li>
<li>숫자로 시작하는 것은 허용하지 않는다.</li>
<li>예약어는 식별자로 사용할 수 없다.</li>
</ul>
<p><strong>🔥 변수 이름도 식별자이므로 네이밍 규칙을 따라야 한다.</strong></p>
<ul>
<li>변수는 쉼표(,)로 구분해 하나의 문에서 여러 개를 한 번에 선언할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person, $elem, _name, first_name, val1;</span><br></pre></td></tr></table></figure>

<ul>
<li>ES5부터 식별자를 만들 때 유니코드 문자를 허용하므로 알파벳 외의 한글이나 일본어 식별자도 사용할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 이름, なまえ;</span><br></pre></td></tr></table></figure>

<ul>
<li>다음 식별자는 명명 규칙에 위배되므로 변수 이름으로 사용할 수 없다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first-name; <span class="comment">// SyntaxError: Unexpected token –</span></span><br><span class="line"><span class="keyword">var</span> 1st;        <span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable language_">this</span>;       <span class="comment">// SyntaxError: Unexpected token this</span></span><br></pre></td></tr></table></figure>

<ul>
<li>자바스크립트는 <strong>대소문자를 구별</strong>하므로 다음 변수는 각각 별개의 변수다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstname;</span><br><span class="line"><span class="keyword">var</span> firstName;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">FIRSTNAME</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>; <span class="comment">// NG. x 변수가 의미하는 바를 알 수 없다.</span></span><br><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>; <span class="comment">// OK. score 변수는 점수를 의미한다.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 경과 시간. 단위는 날짜다</span></span><br><span class="line"><span class="keyword">var</span> d; <span class="comment">// NG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elapsedTimeInDays; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 네이밍 컨벤션</strong></p>
<p>: 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한 눈에 구문하기 위해 규정한 명명 규칙</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 카멜 케이스 (camelCase)</span></span><br><span class="line"><span class="keyword">var</span> firstName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스네이크 케이스 (snake_case)</span></span><br><span class="line"><span class="keyword">var</span> first_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파스칼 케이스 (PascalCase)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">FirstName</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 헝가리언 케이스 (typeHungarianCase)</span></span><br><span class="line"><span class="keyword">var</span> strFirstName; <span class="comment">// type + identifier</span></span><br><span class="line"><span class="keyword">var</span> $elem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myId&#x27;</span>); <span class="comment">// DOM 노드</span></span><br><span class="line"><span class="keyword">var</span> observable$ = <span class="title function_">fromEvent</span>(<span class="variable language_">document</span>, <span class="string">&#x27;click&#x27;</span>); <span class="comment">// RxJS 옵저버블</span></span><br></pre></td></tr></table></figure>

<ul>
<li>자바스크립트에서 일반적으로 변수나 함수의 이름에는 👉🏻 카멜 케이스</li>
<li>생성자 함수, 클래스 이름에는 👉🏻 파스칼 케이스</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>왜 1byte는 8bit일까?</title>
    <url>/2022/221022-archive/</url>
    <content><![CDATA[<h3 id="이-질문에-대해서-생각해보기-전에-컴퓨터가-개발되던-시기로-돌아가보자"><a href="#이-질문에-대해서-생각해보기-전에-컴퓨터가-개발되던-시기로-돌아가보자" class="headerlink" title="이 질문에 대해서 생각해보기 전에 컴퓨터가 개발되던 시기로 돌아가보자."></a>이 질문에 대해서 생각해보기 전에 컴퓨터가 개발되던 시기로 돌아가보자.</h3><p>컴퓨터는 미국에서 발전한 기계인데, 처음 컴퓨터를 통해 문자를 나타내기 위한 규약인 ASCII(American Standard Code for Information Interchange)도 알파벳을 포함한 미국에서 사용하기 위한 문자들을 표현하기 위해 만든 것이었다.</p>
<p>ASCII는 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 그리고 일부 특수문자를 포함한다.</p>
<p>이때 ASCII의 총 문자수가 공백을 포함하여 128자였기 때문에 7bit 만으로 모든 문자를 표현하는 것이 가능했다.</p>
<p><img src="https://blog.kakaocdn.net/dn/qOPNt/btrAdcY26CF/Ksn1qKzUqEaCql1Cbk6GG0/img.png" alt="https://blog.kakaocdn.net/dn/qOPNt/btrAdcY26CF/Ksn1qKzUqEaCql1Cbk6GG0/img.png"></p>
<h3 id="🤔-그럼-7bit여야하는거-아닌가"><a href="#🤔-그럼-7bit여야하는거-아닌가" class="headerlink" title="🤔 그럼 7bit여야하는거 아닌가?"></a><strong>🤔 그럼 7bit여야하는거 아닌가?</strong></h3><p>싶지만 8비트 중 1비트는 패리티 비트라고 불리는 오류 검출을 위해 사용되기 때문에 1바이트가 8비트로 이루어져 있는 것이다.</p>
<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>1바이트는 8비트다라고 당연하게 생각하고 넘어갔던 것들에 대해서 궁금해하고 찾아보니 새로운 정보들을 찾아보게 되고 새롭게 알게 된 것들이 많아 보람차다.</p>
<p>이후에는 문자를 인코딩하는 방법에 대해서 알아보자 (๑・‿・๑)</p>
<p>참고자료)</p>
<ul>
<li><a href="https://devbull.xyz/1baiteuga-8biteuin-iyu-the-reason-why-1byte-equals-to-8bit/">https://devbull.xyz/1baiteuga-8biteuin-iyu-the-reason-why-1byte-equals-to-8bit/</a></li>
<li>혼자 공부하는 컴퓨터 구조 + 운영체제</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>IT</tag>
        <tag>Computer</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터 타입 - 자바스크립트는 동적 타입 언어다.</title>
    <url>/2022/221023-archive/</url>
    <content><![CDATA[<p>🔥 <strong>자바스크립트는 동적 타입 언어이다.</strong></p>
<p>변수의 타입 지정없이 값이 할당되는 과정에서 자동으로 변수의 타입이 결정된다.</p>
<p>데이터 타입은 프로그래밍 언어에서 사용할 수 있는 데이터의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. ES6는 7개의 데이터 타입을 제공한다.</p>
<p><img src="https://velog.velcdn.com/images/kozel/post/9890a85e-2e2e-478a-9bb7-c3ff43645b11/image.jpeg" alt="https://velog.velcdn.com/images/kozel/post/9890a85e-2e2e-478a-9bb7-c3ff43645b11/image.jpeg"></p>
<ul>
<li>숫자 타입의 값 1과 문자열 타입의 값 “1”은 비슷해보이지만 전혀 다른 값이다. ➡️ 생성한 목적과 용독가 다름<ul>
<li>숫자 타입의 값 👉🏻 산술 연산을 위해 생성</li>
<li>문자 타입의 값 👉🏻 주로 텍스트 화면에 출력하기 위해 생성</li>
</ul>
</li>
<li>확보해야 할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 해석하는 방식도 다르다.</li>
</ul>
<h2 id="숫자-타입"><a href="#숫자-타입" class="headerlink" title="숫자 타입"></a>숫자 타입</h2><p>ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다.</p>
<p>👉🏻 즉, 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 모두 숫자 타입이다.</span></span><br><span class="line"><span class="keyword">var</span> integer = <span class="number">10</span>; <span class="comment">// 정수</span></span><br><span class="line"><span class="keyword">var</span> double = <span class="number">10.12</span>; <span class="comment">// 실수</span></span><br><span class="line"><span class="keyword">var</span> negative = -<span class="number">20</span>; <span class="comment">// 음의 정수</span></span><br></pre></td></tr></table></figure>

<ul>
<li>정수, 실수, 2진수, 8진수, 16진수 리터럴 👉🏻 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다.</li>
<li>자바스크립트는 2진수, 8진수, 16진수 데이터 타입을 제공하지 않기 때문에 값을 참조하면 10진수로 해석된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> binary = <span class="number">0b01000001</span>; <span class="comment">// 2진수</span></span><br><span class="line"><span class="keyword">var</span> octal = <span class="number">0o101</span>; <span class="comment">// 8진수</span></span><br><span class="line"><span class="keyword">var</span> hex = <span class="number">0x41</span>; <span class="comment">// 16진수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표기법만 다를 뿐 모두 같은 값이다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binary); <span class="comment">// 65</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(octal); <span class="comment">// 65</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hex); <span class="comment">// 65</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binary === octal); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(octal === hex); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>🖥 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다.</strong></p>
<p>➡️ 이는 정수로 표시된다 해도 사실은 실수라는 것을 의미한다. 따라서 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 숫자 타입은 모두 실수로 처리된다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> === <span class="number">1.0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span> / <span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> / <span class="number">2</span>); <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure>

<p>📚 <strong>추가적으로 3가지 특별한 값들도 표현할 수 있다.</strong></p>
<ul>
<li><code>Infinity</code> : 양의 무한대</li>
<li><code>Infinity</code> : 음의 무한대</li>
<li><code>NaN</code> : 산술 연산 불가(not-a-number)</li>
</ul>
<p>💡 <strong>자바스크립트는 대소문자를 구별하기 때문에 NAN, Nan, nan을 값이 아닌 식별자로 해석한다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 자바스크립트는 대소문자를 구별한다.</span></span><br><span class="line"><span class="keyword">var</span> x = nan; <span class="comment">// ReferenceError: nan is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><ul>
<li>문자열 타입은 텍스트 데이터를 나타내는 데 사용한다.</li>
<li>문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 타입</span></span><br><span class="line"><span class="keyword">var</span> string;</span><br><span class="line">string = <span class="string">&#x27;문자열&#x27;</span>; <span class="comment">// 작은따옴표</span></span><br><span class="line">string = <span class="string">&#x27;문자열&#x27;</span>; <span class="comment">// 큰따옴표</span></span><br><span class="line">string = <span class="string">`문자열`</span>; <span class="comment">// 백틱 (ES6)</span></span><br><span class="line"></span><br><span class="line">string = <span class="string">&#x27;작은따옴표로 감싼 문자열 내의 &quot;큰따옴표&quot;는 문자열로 인식된다.&#x27;</span>;</span><br><span class="line">string = <span class="string">&quot;큰따옴표로 감싼 문자열 내의 &#x27;작은따옴표&#x27;는 문자열로 인식된다.&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>다른 타입의 값과 달리 문자열을 따옴표로 감싸는 이유 ➡️ 키워드나 식별자와 같은 토큰과 구분하기 위해서</li>
<li>자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값이다.<br>👉🏻 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다.</li>
</ul>
<p>✨ <strong>부동소수점이란?</strong></p>
<p>console.log(0.1 + 0.2)의 결과값이 무엇일까? 결과는 0.30000000004가 나온다.</p>
<p>그렇다면 console.log(0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3)의 결과는? 👉🏻 당연히 false가 나오게 된다.</p>
<p>원시 타입 중 숫자 타입의 정수, 실수, 2진수, 8진수, 16진수, 리터럴 등은 <strong>배정밀도 64비트 부동소수점 형식의 2진수</strong>로 저장된다.</p>
<p>✅ <strong>부동소수점(floating point)</strong></p>
<p>: 컴퓨터가 실수를 표현하는 방법(.이 부표처럼 앞뒤로 이동한다고 해서 부동이라는 이름이 붙었다.)</p>
<p>9.625가 이진법으로 표현하면 1001.101로 표현되는데 부동소수점은 1.001101의 형식으로 변환한다. 1001.101이 1.001101처럼 되려면 소수점이 왼쪽으로 세 칸 이동해야한다. 그래서 소숫점이 떠서 움직여야한다고 표현하는 것이다.</p>
<h2 id="문자열-타입-1"><a href="#문자열-타입-1" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><p>텍스트 데이터를 나타내는데 사용한다. 문자열은 0개 이상의 16비트 유니코드 문자의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.</p>
<p>C와 같은 언어와는 다르게, 자바스크립트의 문자열은 원시 타입이며 변경 불가능(immutable)하다. 이것은 한 번 문자열이 생성되면, 그 문자열을 변경할 수 없다는 것을 의미한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">str = <span class="string">&#x27;world&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>첫 번째 구문이 실행되면 메모리에 문자열 ‘Hello’가 생성되고 식별자 str은 메모리에 생성된 문자열 ‘Hello’의 메모리 주소를 가리킨다.</p>
<p>그리고 두 번째 구문이 실행되면 이저에 생성된 문자열을 수정하는 것이 아니라 새로운 문자열 ‘world’를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 이때 문자 ‘Hello’와 ‘world’는 모두 메모리에 존재하고 있다.</p>
<p>변수 str은 문자열 ‘Hello’를 가리키고 있다가 문자열 ‘world’를 가리키도록 변경되었을 뿐이다.</p>
<p>문자열은 배열 처럼 인덱스를 통해 접근할 수 있다. 이와 같은 특성을 갖는 데이터를 <strong>유사 배열</strong>이라 한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="comment">// 문자열은 유사배열이다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 변경할 수 없다.</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p><code>str[0] = &#39;S&#39;</code>처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다(이때 에러가 발생하지 않는다). 한번 생성된 문자열은 read only로서 변경할 수 없다. 이것을 변경 불가능(immutable)이라 한다.</p>
<p>그러나 새로운 문자열을 재할당하는 것은 물론 가능하다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문이다. <code>👉문자열과 불변성</code></p>
<h2 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h2><ul>
<li>ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.<ul>
<li>멀티라인 문자열</li>
<li>표현식 삽입</li>
<li>태그드 템플릿</li>
</ul>
</li>
<li>템플릿 리터럴은 일반 문자열과 비슷해 보이지만 백틱을 사용해 표현한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello</span></span><br><span class="line"><span class="string">world.&#x27;</span>;</span><br><span class="line"><span class="comment">// SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<h3 id="1-멀티라인-문자열"><a href="#1-멀티라인-문자열" class="headerlink" title="1. 멀티라인 문자열"></a>1. <strong>멀티라인 문자열</strong></h3><p>🔥 <strong>일반 문자열 내에서는 줄바꿈이 허용되지 않는다.</strong></p>
<p>➡️ 따라서 일반 문자열 내에서 줄바꿈 등의 공백을 표현하려면 👉🏻 백슬래시로 시작하는 <strong>이스케이프 시퀀스</strong>를 사용해야 한다.</p>
<p><img src="https://velog.velcdn.com/images/kozel/post/cf106d59-c4cb-4e53-a3f6-ba7668ab1d78/image.jpeg" alt="https://velog.velcdn.com/images/kozel/post/cf106d59-c4cb-4e53-a3f6-ba7668ab1d78/image.jpeg"></p>
<p>✨ <strong>라인 피드와 캐리지 리턴</strong></p>
<p>과거 타자기에서 커서를 제어하는 방식에서 비롯되었다.</p>
<ul>
<li><p>라인 피드(\n): 커서를 정지한 상태에서 종이를 한 줄 올리는 것</p>
</li>
<li><p>캐리지 리턴(\r): 종이를 움직이지 않고 커서를 맨 앞줄로 이동하는 것</p>
</li>
<li><p>자바스크립트에서는 라인 피드와 캐리지 리턴 모두 개행을 의미한다.</p>
</li>
<li><p>줄바꿈과 들여쓰기가 적용된 HTML 문자열은 다음과 같이 이스케이프 시퀀스를 사용해 작성한다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;&lt;ul&gt;**\n\t**&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;**\n**&lt;/ul&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(template);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>일반 문자열과 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(template);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="2-표현식-삽입"><a href="#2-표현식-삽입" class="headerlink" title="2. 표현식 삽입"></a>2. <strong>표현식 삽입</strong></h3><p>🖥 <strong>문자열은 문자열 연산자 +를 사용해 연결할 수 있다.</strong></p>
<ul>
<li>+연산자 👉🏻 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="string">&#x27;Ung-mo&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5: 문자열 연결</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My name is &#x27;</span> + first + <span class="string">&#x27; &#x27;</span> + last + <span class="string">&#x27;.&#x27;</span>); <span class="comment">// My name is Ung-mo Lee.</span></span><br></pre></td></tr></table></figure>

<p>📚 <strong>템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있다.</strong></p>
<ul>
<li>이를 통해 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="string">&#x27;Ung-mo&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">&#x27;Lee&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6: 표현식 삽입</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span>); <span class="comment">// My name is Ung-mo Lee.</span></span><br></pre></td></tr></table></figure>

<p>💡 <strong>표현식을 삽입하려면 ${}으로 표현식을 감싼다.</strong></p>
<ul>
<li>이때 표현식의 <strong>평가 결과가 문자열이 아니더라도</strong> 문자열로 타입이 강제로 변환되어 삽입된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`1 + 2 = <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span>); <span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다.<ul>
<li>템플릿 리터럴이 아닌 일반 문자열에서의 표현식 삽입 👉🏻 문자열로 취급된다.<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1 + 2 = $&#123;1 + 2&#125;&#x27;</span>); <span class="comment">// 1 + 2 = $&#123;1 + 2&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="불리언-타입"><a href="#불리언-타입" class="headerlink" title="불리언 타입"></a>불리언 타입</h2><p>불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 <code>true</code>와 <code>false</code> 뿐이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof 연산자는 타입을 나타내는 문자열을 반환한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> bar); <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<h2 id="undefined-타입"><a href="#undefined-타입" class="headerlink" title="undefined 타입"></a>undefined 타입</h2><p>💡 <strong>undefined의 값은 undefined가 유일하다.</strong></p>
<ul>
<li>var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다.<br>➡️ 다시 말해 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화된다.</li>
<li>이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.</li>
<li>개발자가 변수 값이 없다는 것을 명시하고 싶을 때는? 👉🏻 null을 할당한다.</li>
</ul>
<p><strong>✨ 선언과 정의</strong></p>
<p>undefined를 직역하면 “정의되지 않은”이다.</p>
<ul>
<li>일반적으로 정의란? 👉🏻 어떤 대상을 명확하게 규정하는 것을 의미한다.</li>
<li>자바스크립트의 undefined에서 말하는 정의란? 👉🏻 변수에 값을 할당하여 변수의 실체를 명확히 하는 것</li>
</ul>
<h2 id="null-타입"><a href="#null-타입" class="headerlink" title="null 타입"></a>null 타입</h2><p>💡 <strong>null 타입은 null이 유일하다.</strong></p>
<ul>
<li>값이 없다는 것을 의도적으로 명시할 때 사용한다.</li>
<li>null을 할당하는 것 👉🏻 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다.</li>
<li>이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미한다. 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management">가비지 콜렉션</a>을 수행할 것이다.</li>
</ul>
<h2 id="심벌-타입"><a href="#심벌-타입" class="headerlink" title="심벌 타입"></a>심벌 타입</h2><p>심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다. 심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Symbol은 고유한 존재 이기 때문에 문자열이 같아도 영향을 미치지 않는다.</span></span><br></pre></td></tr></table></figure>

<p>✨ <strong>object.key로 사용</strong></p>
<p>객체에서 Symbol로도 객체의 property를 만들 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;cy&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&#x27;id&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[id]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Symbol을 key를 사용하여 데이터에 접근할 수 있다. 그러면 string을 사용하면 되지 왜 굳이 Symbol을 사용할까? 만약 obj 객체에 무수히 많은 프로퍼티가 있다고 가정해보자.</li>
<li>협업을 하다가 한 팀원이 obj객체에 name 속성이 있는지 모르고 name 속성을 추가해서 덮어씌어버린다면? 오류가 발생할 것이다.</li>
<li>이 속성값은 건들지 말아줘!하고 싶을 경우 Symbol을 사용한다. 같은 속성이름으로 값을 추가하더라도 Symbol은 다른 존재로 인식 하기 때문에 오류가 없을 것이다.</li>
</ul>
<p>참고자료)</p>
<p><a href="https://chaeyoung2.tistory.com/40">https://chaeyoung2.tistory.com/40</a></p>
<h2 id="객체-타입"><a href="#객체-타입" class="headerlink" title="객체 타입"></a>객체 타입</h2><p>객체는 데이터와 그 데이터에 관련한 동작을 모두 포함한다.</p>
<ul>
<li>이름과 값을 가지는 데이터: 프로퍼티(property)</li>
<li>그 데이터에 관련한 동작: 메서드(method)</li>
</ul>
<p>🔥 <strong>자바스크립트는 객체 기반의 스크립트 언어로서 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다.</strong></p>
<p>원시 타입(Primitives)을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체이다. 또한 객체는 <strong><a href="https://poiemaweb.com/js-object#4-pass-by-reference">pass-by-reference(참조에 의한 전달)</a></strong> 방식으로 전달된다.</p>
<h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2><ol>
<li>값을 저장할 때 확보해야하는 메모리 공간의 크기를 결정하기 위해</li>
<li>값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li>
<li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li>
</ol>
<h3 id="1-데이터-타입에-의한-메모리-공간-확보와-참조"><a href="#1-데이터-타입에-의한-메모리-공간-확보와-참조" class="headerlink" title="1. 데이터 타입에 의한 메모리 공간 확보와 참조"></a>1. <strong>데이터 타입에 의한 메모리 공간 확보와 참조</strong></h3><p>값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수를 알아야 한다.</p>
<p>🤔 <strong>그렇다면 컴퓨터는 한 번에 읽어 들여야 할 메모리 셀의 크기를 어떻게 알 수 있을까?</strong></p>
<p>➡️ 변수에 어떤 데이터 타입의 값이 할당되어 있는지 확인하고 메모리 공간을 확보한다.</p>
<p><img src="https://velog.velcdn.com/images/kozel/post/9d170f6a-db60-4bef-b5f5-282fadcd1d59/image.png" alt="https://velog.velcdn.com/images/kozel/post/9d170f6a-db60-4bef-b5f5-282fadcd1d59/image.png"></p>
<p>자바스크립트는 숫자 타입의 값을 생성할 때 배정밀도 64비트 부동소수점 형식을 사용한다. 따라서 실제로 메모리에 저장되는 2진수 값은 위 그림과 다르다.</p>
<p><strong>🔥 이번에는 참조의 경우를 생각해보자.</strong></p>
<ul>
<li>위의 예제에서 식별자 score를 통해 숫자 값 100이 저장되어 있는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있다.</li>
<li>이때 값을 참조하려면 한번에 읽어 들여야 할 메모리 셀의 개수(바이트 수)를 알아야한다.<ul>
<li>그러기 위해 자바스크립트 엔진은 score 변수의 값이 숫자 타입임을 인식하고 8바이트 단위로 메모리 공간에 저장된 값을 읽어 들인다.</li>
</ul>
</li>
</ul>
<h3 id="2-데이터-타입에-의한-값의-해석"><a href="#2-데이터-타입에-의한-값의-해석" class="headerlink" title="2. 데이터 타입에 의한 값의 해석"></a>2. <strong>데이터 타입에 의한 값의 해석</strong></h3><p>메모리에서 읽어들인 2진수를 어떻게 해석해야하는지에 대한 문제가 남아있다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.</p>
<ul>
<li>예를 들어 0100 0001을 숫자로 해석하면 65지만 문자열로 해석하면 ‘A’다. 이렇게 같은 2진수여도 해석이 달라질 수 있다.</li>
<li>하지만 우리는 데이터 타입이 있고, 위의 예제에서 score 변수에 할당된 값은 숫자 타입의 값이므로 score 변수를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수를 숫자로 해석한다.</li>
</ul>
<p><strong>📚 데이터 타입이 필요한 이유는 다음과 같다.</strong></p>
<ul>
<li>값을 저장할 때 확보해야 하는 <strong>메모리 공간의 크기</strong>를 결정하기 위해</li>
<li>값을 참조할 때 한 번에 읽어 들여야 할 <strong>메모리 공간의 크기</strong>를 결정하기 위해</li>
<li>메모리에서 읽어 들인 <strong>2진수를 어떻게 해석</strong>할지 결정하기 위해</li>
</ul>
<h2 id="동적-타이핑"><a href="#동적-타이핑" class="headerlink" title="동적 타이핑"></a>동적 타이핑</h2><h3 id="1-동적-타입-언어와-정적-타입-언어"><a href="#1-동적-타입-언어와-정적-타입-언어" class="headerlink" title="1. 동적 타입 언어와 정적 타입 언어"></a>1. 동적 타입 언어와 정적 타입 언어</h3><p>✨ <strong>변수는 타입을 가질까?</strong></p>
<p>➡️ 결론부터 말하자면 변수는 타입을 갖지 않는다. <strong>하지만 값은 타입을 갖는다.</strong> 따라서 변수에 할당되어 있는 값에 의해 변수의 타입이 결정된다라고 표현하는 것이 적절하다.</p>
<p>🖥 <strong>정적 타입 언어</strong></p>
<p>변수를 선언할 때 변수에 할당할 수 있는 값의 종류를 사전에 선언해야 한다.(&#x3D; 명시적 타입 선언)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c 변수에는 1바이트 정수 타입의 값만 할당할 수 있다.</span></span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// num 변수에는 4바이트 정수 타입의 값만 할당할 수 있다.</span></span><br><span class="line">int num;</span><br></pre></td></tr></table></figure>

<p>변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적타입 언어는 컴파일 시점에 타입 체크를 수행한다. 만약 타입 체크를 통과하지 못했다면 에러를 발생시킨다.</p>
<p>🖥 <strong>동적 타입 언어</strong></p>
<p>자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3.14</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">&#x27;Hi&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> foo); <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트 변수에는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다.</p>
<ul>
<li>정적 타입 언어는 변수 선언 시점에 변수의 타입이 결정되고</li>
<li>자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정된다.</li>
</ul>
<p>➡️ 다시 말해, 자바스크립트의 변수는 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 <strong>동적 타이핑</strong>이라고 한다.</p>
<h3 id="2-동적-타입-언어와-변수"><a href="#2-동적-타입-언어와-변수" class="headerlink" title="2. 동적 타입 언어와 변수"></a>2. 동적 타입 언어와 변수</h3><p>동적 타입 언어는 변수에 대해 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.</p>
<p>👿 <strong>이러한 편리함 이면에는 위험이 있다.</strong></p>
<p>모든 소프트웨어 아키텍처에는 트레이드오프가 존재하며, 동적 타입 언어 또한 구조적인 단점이 있다.</p>
<ul>
<li>변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다.</li>
<li>그뿐만 아니라 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다.</li>
</ul>
<p><em>➡️ 따라서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.</em></p>
<p>🔥 <strong>변수를 사용할 때 주의할 사항은 다음과 같다.</strong></p>
<ul>
<li>변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.</li>
<li>변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.</li>
<li>전역 변수는 최대한 사용하지 않도록 한다.</li>
<li>변수보다는 상수를 사용해 값의 변경을 억제한다.</li>
<li>변수의 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.</li>
</ul>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>연산자</title>
    <url>/2022/221026-archive/</url>
    <content><![CDATA[<h3 id="✅-연산자"><a href="#✅-연산자" class="headerlink" title="✅ 연산자"></a>✅ 연산자</h3><p>: <strong>하나 이상의 표현식</strong>을 대상으로 산술, 할당, 비교, 논리, 차입, 지수 연산 등을 수행해 하나의 값을 만든다.</p>
<ul>
<li>이때 연산의 대상을 <strong>피연산자</strong>라 한다.</li>
<li>피연산자는 값으로 평가될 수 있는 표현식이어야 한다.</li>
</ul>
<p>➡️ 그리고 피연산자와 연산자의 조합으로 이뤄진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="number">5</span> * <span class="number">4</span>; <span class="comment">// -&gt; 20</span></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">&#x27;My name is &#x27;</span> + <span class="string">&#x27;Lee&#x27;</span>; <span class="comment">// -&gt; &#x27;My name is Lee&#x27;</span></span><br><span class="line"><span class="comment">// 할당 연산자</span></span><br><span class="line">color = <span class="string">&#x27;red&#x27;</span>; <span class="comment">// -&gt; &#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// 비교 연산자</span></span><br><span class="line"><span class="number">3</span> &gt; <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 논리 연산자</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 타입 연산자</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;Hi&#x27;</span>; <span class="comment">// -&gt; string</span></span><br></pre></td></tr></table></figure>

<ul>
<li>피연산자 👉🏻 ”값”이라는 명사의 역할</li>
<li>연산자 👉🏻 ”피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할</li>
</ul>
<p>➡️ 다시 말해, 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다.</p>
<h2 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h2><h3 id="✅-산술-연산자"><a href="#✅-산술-연산자" class="headerlink" title="✅ 산술 연산자"></a>✅ 산술 연산자</h3><p>: 피연산자를 대항으로 <strong>수학적 계산</strong>을 수행해 새로운 숫자 값을 만든다.</p>
<ul>
<li>산술 연산이 불가능한 경우 👉🏻 NaN를 반환한다.</li>
</ul>
<h3 id="1-이항-산술-연산자"><a href="#1-이항-산술-연산자" class="headerlink" title="1. 이항 산술 연산자"></a>1. <strong>이항 산술 연산자</strong></h3><p>: <strong>2개의 피연산자</strong>를 산술 연산하여 숫자 값을 만든다.</p>
<ul>
<li>부수효과 👉🏻 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(Side effect)가 <strong>없다.</strong></li>
</ul>
<p>➡️ 다시 말해, 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 단지 <strong>새로운 값을 만들 뿐이다.</strong></p>
<table>
<thead>
<tr>
<th>이항 산술 연산자</th>
<th>의미</th>
<th>부수효과</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>덧셈</td>
<td>X</td>
</tr>
<tr>
<td>-</td>
<td>뺄셈</td>
<td>X</td>
</tr>
<tr>
<td>*</td>
<td>곱셈</td>
<td>X</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>나눗셈</td>
<td>X</td>
</tr>
<tr>
<td>%</td>
<td>나머지</td>
<td>X</td>
</tr>
</tbody></table>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> + <span class="number">2</span>; <span class="comment">// -&gt; 7</span></span><br><span class="line"><span class="number">5</span> - <span class="number">2</span>; <span class="comment">// -&gt; 3</span></span><br><span class="line"><span class="number">5</span> * <span class="number">2</span>; <span class="comment">// -&gt; 10</span></span><br><span class="line"><span class="number">5</span> / <span class="number">2</span>; <span class="comment">// -&gt; 2.5</span></span><br><span class="line"><span class="number">5</span> % <span class="number">2</span>; <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-단항-산술-연산자"><a href="#2-단항-산술-연산자" class="headerlink" title="2. 단항 산술 연산자"></a>2. <strong>단항 산술 연산자</strong></h3><p>: <strong>1개의 피연산자</strong>를 산술 연산하여 숫자 값을 만든다.</p>
<table>
<thead>
<tr>
<th>단항 산술 연산자</th>
<th>의미</th>
<th>부수 효과</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>증가</td>
<td>O</td>
</tr>
<tr>
<td>–</td>
<td>감소</td>
<td>O</td>
</tr>
<tr>
<td>+</td>
<td>어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.</td>
<td>X</td>
</tr>
<tr>
<td>-</td>
<td>양수를 음수로, 음수를 양수로 반전한 값을 반환한다.</td>
<td>X</td>
</tr>
</tbody></table>
<ul>
<li>부수효과 👉🏻 주의할 점은 이항 산술 연산자와는 달리 증가&#x2F;감소 연산자는 피연산자의 <strong>값을 변경하는 부수효과가 있다</strong>는 것이다.</li>
</ul>
<p>➡️ 다시 말해, 증가&#x2F;감소 연산을 하면 피연산자의 값을 변경하는 <strong>암묵적 할당</strong>이 이뤄진다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.</span></span><br><span class="line">x++; <span class="comment">// x = x + 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- 연산자는 피연산자의 값을 변경하는 암묵적 할당이 이뤄진다.</span></span><br><span class="line">x--; <span class="comment">// x = x - 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>증가·감소 연산자는 변수에만 쓸 수 있다. <code>5++</code>와 같이 값에 사용하려고 하면 에러가 발생한다.<ul>
<li><strong>증가 연산자</strong>: <code>++</code>는 변수를 1 증가시킴</li>
<li><strong>감소 연산자:</strong> <code>--</code>는 변수를 1 감소시킴</li>
</ul>
</li>
</ul>
<p>🔥 <strong>증가·감소 연산자는 위치에 의미가 있다.</strong></p>
<ul>
<li><code>counter++</code>와 같이 피연산자 뒤에 올 때는, **’후위형(postfix form)’**이라고 부른다.</li>
<li><code>++counter</code>와 같이 피연산자 앞에 올 때는, **’전위형(prefix form)’**이라고 부른다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>,</span><br><span class="line">  result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 선할당 후증가(postfix increment operator)</span></span><br><span class="line">result = x++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선증가 후할당(prefix increment operator)</span></span><br><span class="line">result = ++x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 7 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선할당 후감소(postfix decrement operator)</span></span><br><span class="line">result = x--;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 7 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 선감소 후할당 (prefix decrement operator)</span></span><br><span class="line">result = --x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result, x); <span class="comment">// 5 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>후위형과 전위형은 피연산자인 <code>**counter</code>를 <code>1</code>만큼 증가시켜 준다는 점**에서 동일한 역할을 한다.</li>
<li>두 형의 차이는 <code>++/--</code>의 반환 값을 사용할 때 드러난다.<ul>
<li>전위형은 증가·감소 후의 새로운 값을 반환하는 반면,</li>
<li>후위형은 증가·감소 전의 기존 값을 반환한다.</li>
</ul>
</li>
</ul>
<p>🖥 <strong>+단항 연산자는 피연산자에 어떠한 효과도 없다.</strong></p>
<ul>
<li>양수를 음수로 반전하지도 않는다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 아무런 효과가 없다.</span></span><br><span class="line">+<span class="number">10</span>; <span class="comment">// -&gt; 10</span></span><br><span class="line">+-<span class="number">10</span>; <span class="comment">// -&gt; -10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>숫자 타입이 아닌 +단항 연산자를 사용하면 👉🏻 피연산자를 <strong>숫자타입으로 변환</strong>하여 반환</li>
</ul>
<p>➡️ 따라서 피연산자를 변경하는 것이 아니라 숫자 타입으로 변환한 값을 생성해서 반환한다. <strong>(부수효과 X)</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">x = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">x = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.</span></span><br><span class="line">x = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+x); <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 부수 효과는 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>🖥 -<strong>단항 연산자는 피연산자의 부호를 반전한 값을 반환한다.</strong></p>
<ul>
<li>+단항 연산자와 마찬가지로 <strong>숫자 타입이 아닌 피연산자</strong>에 사용하면? 👉🏻 피연산자를 숫자 타입으로 변환하여 반환한다.</li>
<li>이때 피연산자를 변경하는것이 아니고 부호를 생성해 반전한 값을 생성한다. ➡️ 부수효과X</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 부호를 반전한다.</span></span><br><span class="line">-(-<span class="number">10</span>); <span class="comment">// -&gt; 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열을 숫자로 타입 변환한다.</span></span><br><span class="line">-<span class="string">&#x27;10&#x27;</span>; <span class="comment">// -&gt; -10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 값을 숫자로 타입 변환한다.</span></span><br><span class="line">-<span class="literal">true</span>; <span class="comment">// -&gt; -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.</span></span><br><span class="line">-<span class="string">&#x27;Hello&#x27;</span>; <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="3-문자열-연결-연산자"><a href="#3-문자열-연결-연산자" class="headerlink" title="3. 문자열 연결 연산자"></a>3. 문자열 연결 연산자</h3><p>: +연산자는 피연산자 중 <strong>하나 이상이 문자열인 경우</strong> 문자열 연결 연산자로 동작한다.</p>
<p>그 외의 경우는 산술 연산자로 동작한다.</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> + <span class="number">2</span>; <span class="comment">// -&gt; &#x27;12&#x27;</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;2&#x27;</span>; <span class="comment">// -&gt; &#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 산술 연산자</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span>; <span class="comment">// -&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// true는 1로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">true</span>; <span class="comment">// -&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// false는 0으로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">false</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null은 0으로 타입 변환된다.</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">null</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined는 숫자로 타입 변환되지 않는다.</span></span><br><span class="line">+<span class="literal">undefined</span>; <span class="comment">// -&gt; NaN</span></span><br><span class="line"><span class="number">1</span> + <span class="literal">undefined</span>; <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure>

<p>💡 <strong>주목할 것은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동변환 되기도 한다는 것이다.</strong></p>
<ul>
<li>위 예제에서 1 + true를 연산하면 👉🏻 자바스크립트 엔진은 암묵적으로 불리언 타입의 값이 true를 숫자 타입인 1로 변환 후 연산을 수행한다.</li>
</ul>
<p>➡️ <strong>암묵적 타입 변환(implicit coercion) &#x2F; 타입 강제 변환(type coercion)</strong></p>
<h2 id="할당-연산자"><a href="#할당-연산자" class="headerlink" title="할당 연산자"></a>할당 연산자</h2><h3 id="할당-연산자-1"><a href="#할당-연산자-1" class="headerlink" title="할당 연산자"></a>할당 연산자</h3><p>: 우항에 있는 피연산자의 평가 결과를 <strong>좌항의 변수</strong>에 할당한다.</p>
<ul>
<li>할당 연산자는 좌항의 변수 값을 할당하므로 변수 값이 변하는 <strong>부수 효과가 있다.</strong></li>
</ul>
<table>
<thead>
<tr>
<th>할당 연산자</th>
<th>사례</th>
<th>동일 표현</th>
<th>부수 효과</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>x &#x3D; y</td>
<td>x &#x3D; y</td>
<td>O</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>x +&#x3D; y</td>
<td>x &#x3D; x + y</td>
<td>O</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>x -&#x3D; y</td>
<td>x &#x3D; x - y</td>
<td>O</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>x *&#x3D; y</td>
<td>x &#x3D; x * y</td>
<td>O</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>x &#x2F;&#x3D; y</td>
<td>x &#x3D; x &#x2F; y</td>
<td>O</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>x %&#x3D; y</td>
<td>x &#x3D; x % y</td>
<td>O</td>
</tr>
</tbody></table>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x += <span class="number">5</span>; <span class="comment">// x = x + 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">x -= <span class="number">5</span>; <span class="comment">// x = x - 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x *= <span class="number">5</span>; <span class="comment">// x = x * 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">x /= <span class="number">5</span>; <span class="comment">// x = x / 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">x %= <span class="number">5</span>; <span class="comment">// x = x % 5;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;My name is &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 연결 연산자</span></span><br><span class="line">str += <span class="string">&#x27;Lee&#x27;</span>; <span class="comment">// str = str + &#x27;Lee&#x27;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// &#x27;My name is Lee&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 표현식</strong></p>
<p>: 값으로 평가될 수 있는 문</p>
<p><strong>✅ 문</strong></p>
<p>: 표현식이 문과 표현식이 아닌문</p>
<p><strong>🤔 그렇다면 할당문은 표현식인 문일까? 표현식이 아닌 문일까?</strong></p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문은 표현식인 문이다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((x = <span class="number">10</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>할당문 👉🏻 변수에 값을 할당하는 부수 효과만 있을 뿐 값으로 평가되지 않을 것처럼 보인다.</li>
<li><strong>하지만 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.</strong></li>
<li>위 예제의 x&#x3D;10은 x에 할당된 숫자 값 10으로 평가된다.</li>
</ul>
<p>🔥 <strong>할당문을 다른 변수에 할당할 수도 있다. ➡️ 연쇄 할당</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연쇄 할당. 오른쪽에서 왼쪽으로 진행.</span></span><br><span class="line"><span class="comment">// ① c = 0 : 0으로 평가된다</span></span><br><span class="line"><span class="comment">// ② b = 0 : 0으로 평가된다</span></span><br><span class="line"><span class="comment">// ③ a = 0 : 0으로 평가된다</span></span><br><span class="line">a = b = c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// 0 0 0</span></span><br></pre></td></tr></table></figure>

<h2 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h2><h3 id="✅-비교-연산자"><a href="#✅-비교-연산자" class="headerlink" title="✅ 비교 연산자"></a>✅ 비교 연산자</h3><p>: 좌항과 우항의 피연산자를 비교한 다음 그 결과를 <strong>불리언 값</strong>으로 반환</p>
<ul>
<li>비교 연산자는 if문이나 for문과 같은 <strong>제어문의 조건식</strong>에서 주로 사용된다.</li>
</ul>
<h3 id="1-동등-x2F-일치-비교-연산자"><a href="#1-동등-x2F-일치-비교-연산자" class="headerlink" title="1. 동등&#x2F;일치 비교 연산자"></a>1. 동등&#x2F;일치 비교 연산자</h3><ul>
<li>동등 비교 연산자와 일치 비교 연산자 <strong>공통점</strong> 👉🏻 같은 값으로 평가되는지 비교하여 불리언 값을 반환한다.</li>
<li>동등 비교 연산자와 일치 비교 연산자 <strong>차이점</strong> 👉🏻 비교하는 엄격성의 정도가 다르다.</li>
</ul>
<table>
<thead>
<tr>
<th>비교 연산자</th>
<th>의미</th>
<th>사례</th>
<th>설명</th>
<th>부수 효과</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>동등 비교</td>
<td>x &#x3D;&#x3D; y</td>
<td>x와 y의 값이 같음</td>
<td>X</td>
</tr>
<tr>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>일치 비교</td>
<td>x &#x3D;&#x3D;&#x3D; y</td>
<td>x와 y의 값과 타입이 같음</td>
<td>X</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>부동등 비교</td>
<td>x !&#x3D; y</td>
<td>x와 y의 값이 다름</td>
<td>X</td>
</tr>
<tr>
<td>!&#x3D;&#x3D;</td>
<td>불일치 비교</td>
<td>x !&#x3D;&#x3D; y</td>
<td>x와 y의 값과 타입이 다름</td>
<td>X</td>
</tr>
</tbody></table>
<p>🖥 <strong>동등 비교 연산자</strong></p>
<p>: 좌항과 우항의 피연산자를 비교할 때 <strong>암묵적 타입 변환을 통해 타입을 일치시킨 후</strong> 같은 값인지 비교한다.</p>
<ul>
<li>동등 비교 연산자는 좌항과 우항의 피연산자가 타입은 다르더라도 암묵적 타입 변환 후에 같은 값일 수 있다면 true를 반환한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 동등 비교</span></span><br><span class="line"><span class="number">5</span> == <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.</span></span><br><span class="line"><span class="number">5</span> == <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>동등 비교 연산자는 편리한 경우도 있지만 결과를 예측하기 어렵고 실수하기 쉽다.</li>
</ul>
<p>➡️ 동등 비교 연산자는 예측하기 어려운 결과를 만들어 낸다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 동등 비교. 결과를 예측하기 어렵다.</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="string">&#x27;&#x27;</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;0&#x27;</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;false&#x27;</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>일치 비교 연산자</strong></p>
<p>: 좌항과 우항의 피연산자가 <strong>타입도 같고 값도 같은 경우</strong> true를 반환한다.</p>
<ul>
<li>암묵적 타입을 변환하지 않고 값을 비교한다. 👉🏻 일치 비교 연산자는 예측하기 쉽다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 일치 비교</span></span><br><span class="line"><span class="number">5</span> === <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 타입 변환을 하지 않고 값을 비교한다.</span></span><br><span class="line"><span class="comment">// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.</span></span><br><span class="line"><span class="number">5</span> === <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>일치 비교 연산자에서 주의해야 할 것은 NaN이다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NaN은 자신과 일치하지 않는 유일한 값이다.</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>NaN은 자신과 일치하지 않는 유일한 값이다.</li>
<li>따라서 숫자가 NaN인지 확인하려면? 👉🏻 isNaN 빌트인 함수 사용</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number.isNaN 함수는 지정한 값이 NaN인지 확인하고 그 결과를 불리언 값으로 반환한다.</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">10</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">1</span> + <span class="literal">undefined</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>숫자 0도 주의하자</strong></p>
<ul>
<li>자바스크립트에는 양의 0과 음의 0이 있는데 비교하면 true를 반환한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 결과는 true이다.</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">0</span> == -<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p><strong>✨ Object.is 메서드</strong></p>
<p>동등 비교 연산자와 일치 비교 연산자는 +0과 -0을 동일한 값, NaN과 NaN를 다른 값이라고 평가한다.</p>
<p>예측 가능한 정확한 비교를 반환한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">-<span class="number">0</span> === +<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, +<span class="number">0</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>부동등 비교 연산자(!&#x3D;)와 불일치 비교 연산자(!&#x3D;&#x3D;)는 각각 동등 비교 연산자와 일치 비교 연산자의 반대 개념이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 부동등 비교</span></span><br><span class="line"><span class="number">5</span> != <span class="number">8</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> != <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> != <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불일치 비교</span></span><br><span class="line"><span class="number">5</span> !== <span class="number">8</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> !== <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> !== <span class="string">&#x27;5&#x27;</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-대소-관계-비교-연산자"><a href="#2-대소-관계-비교-연산자" class="headerlink" title="2. 대소 관계 비교 연산자"></a>2. 대소 관계 비교 연산자</h3><p>: 대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>
<p><img src="https://velog.velcdn.com/images/indongcha/post/6d0537c5-ee15-4359-9e31-4a4b746d599e/image.png" alt="https://velog.velcdn.com/images/indongcha/post/6d0537c5-ee15-4359-9e31-4a4b746d599e/image.png"></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 대소 관계 비교</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> &gt; <span class="number">5</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="number">5</span> &gt;= <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="number">5</span> &lt;= <span class="number">5</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h2 id="삼항-조건-연산자"><a href="#삼항-조건-연산자" class="headerlink" title="삼항 조건 연산자"></a>삼항 조건 연산자</h2><h3 id="✅-삼항-조건-연산자"><a href="#✅-삼항-조건-연산자" class="headerlink" title="✅ 삼항 조건 연산자"></a>✅ 삼항 조건 연산자</h3><p>: 조건 식의 평가 결과에 따라 반환할 값을 결정한다.</p>
<ul>
<li>자바스크립트의 유일한 삼항 연산자</li>
<li>부수 효과는 없다.</li>
</ul>
<p>🙌🏻 삼항 조건 연산자의 표현식은 다음과 같이 사용한다.</p>
<p><img src="https://velog.velcdn.com/images/indongcha/post/493e2d87-0390-4140-ac45-8108c34ebbc3/image.png" alt="https://velog.velcdn.com/images/indongcha/post/493e2d87-0390-4140-ac45-8108c34ebbc3/image.png"></p>
<ul>
<li>첫 번째 피연산자가 true로 반환되면? 👉🏻 두 번째 피연산자를 반환</li>
<li>첫 번째 피연산자가 false로 반환되면? 👉🏻 세 번째 피연산자를 반환<br>➡️ 즉, 삼항 조건 연산자는 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식이다.</li>
<li>물음표 앞의 첫 번째 피연산자는? 👉🏻 조건식<ul>
<li>즉, 불리언 타입의 값으로 평가될 표현식</li>
<li>평가결과가 불리언 타입의 값이 아니면? ➡️ 불리언 값으로 암묵적 타입 변환된다.</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>🤔 <strong>삼항 조건 연산자는 조건식인가?</strong></p>
<p>삼항 조건 연산자의 첫 번째 피연산자는 조건식이므로 조건문이다.</p>
<p>따라서 if…else문을 사용해도 삼항 조건 연산자 표현식과 유사하게 처리할 수 있다.</p>
<p><strong>🔥 삼항 조건 연산자와 if…else문의 차이점</strong></p>
<p>: 삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만 if…else문은 값처럼 사용할 수 없다.</p>
<p>➡️ if…else은 표현식이 아닌 문이다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">if</span> (x % <span class="number">2</span>) &#123; result = <span class="string">&#x27;홀수&#x27;</span>; &#125; <span class="keyword">else</span> &#123; result = <span class="string">&#x27;짝수&#x27;</span>; &#125;;</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected token if</span></span><br></pre></td></tr></table></figure>

<p>💡 <strong>삼항 조건 연산자는 표현식은 값으로 평가할 수 있는 표현식인 문이다.</strong></p>
<p>➡️ 따라서 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 삼항 조건 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<ul>
<li>조건에 따라 어떤 값을 결정해야 한다면? 👉🏻 삼항 조건 연산자 표현식을 사용하는 것이 유리하다.</li>
<li>조건에 따라 수행해야 할 문이 여러개라면? 👉🏻 if…else문을 사용</li>
</ul>
<h2 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h2><h3 id="논리-연산자-1"><a href="#논리-연산자-1" class="headerlink" title="논리 연산자"></a>논리 연산자</h3><p>: 우항과 좌항의 피연산자를 논리 연산한다. (부정 논리 연산자의 경우 우항의 피연산자)</p>
<p><img src="https://velog.velcdn.com/images/indongcha/post/e2cf5c14-c666-4aad-a598-aa8af2121c8b/image.png" alt="https://velog.velcdn.com/images/indongcha/post/e2cf5c14-c666-4aad-a598-aa8af2121c8b/image.png"></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">true</span> || <span class="literal">false</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">false</span> || <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리 부정(!) 연산자</span></span><br><span class="line">!<span class="literal">true</span>; <span class="comment">// -&gt; false</span></span><br><span class="line">!<span class="literal">false</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>논리 부정 연산자는 언제나 불리언 값을 반환한다.</strong></p>
<ul>
<li>단, 피연산자가 반드시 불리언 값일 필요는 없다.</li>
<li>만약 피연산자가 불리언 값이 아니라면? 👉🏻 불리언 타입으로 암묵적 타입 변환된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 암묵적 타입 변환</span></span><br><span class="line">!<span class="number">0</span>; <span class="comment">// -&gt; true</span></span><br><span class="line">!<span class="string">&#x27;Hello&#x27;</span>; <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>논리합 또는 논리곱 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다.</strong></p>
<p>논리합 또는 논리곱 연산자는 언제나 2개의 피연산자 중 어느 한 쪽으로 평가된다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 단축 평가</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>; <span class="comment">// -&gt; &#x27;Dog&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="쉼표-연산자"><a href="#쉼표-연산자" class="headerlink" title="쉼표 연산자"></a>쉼표 연산자</h2><h3 id="✅-쉼표-연산자"><a href="#✅-쉼표-연산자" class="headerlink" title="✅ 쉼표 연산자"></a>✅ 쉼표 연산자</h3><p>: 왼쪽 피연산자부터 차례대로 연산자를 평가하고 마지막 피연산자의 평가가 끝나면 <strong>마지막 피연산자의 평가 결과를 반환</strong>한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y, z;</span><br><span class="line"></span><br><span class="line">(x = <span class="number">1</span>), (y = <span class="number">2</span>), (z = <span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="그룹-연산자"><a href="#그룹-연산자" class="headerlink" title="그룹 연산자"></a>그룹 연산자</h2><h3 id="✅-그룹-연산자"><a href="#✅-그룹-연산자" class="headerlink" title="✅ 그룹 연산자"></a>✅ 그룹 연산자</h3><p>: 소괄호로 피연산자를 감싸는 그룹 연산자는 <strong>자신의 피연산자인 표현식</strong>을 가장 먼저 평가한다.</p>
<p>그룹 연산자를 사용하면 <strong>연산자의 우선순위</strong>를 조절할 수 있다. 그룹 연산자는 우선순위가 가장 높다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> * <span class="number">2</span> + <span class="number">3</span>; <span class="comment">// -&gt; 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 그룹 연산자를 사용하여 우선순위를 조절</span></span><br><span class="line"><span class="number">10</span> * (<span class="number">2</span> + <span class="number">3</span>); <span class="comment">// -&gt; 50</span></span><br></pre></td></tr></table></figure>

<ul>
<li>첫 번째 문에서는 10 * 2를 먼저 연산 ➡️ 그 다음 20 + 3을 연산<ul>
<li>곱셈 연산자가 덧셈 연산자보다 우선순위가 높기 때문에</li>
</ul>
</li>
<li>두번째 문에서는 그룹 연산자로 감싼 표현식을 먼저 연산 ➡️ 2 + 3 연산 ➡️ 그 다음 10 * 5 연산</li>
</ul>
<h2 id="typeof-연산자"><a href="#typeof-연산자" class="headerlink" title="typeof 연산자"></a>typeof 연산자</h2><h3 id="✅-typeof-연산자"><a href="#✅-typeof-연산자" class="headerlink" title="✅ typeof 연산자"></a>✅ typeof 연산자</h3><p>: 피연산자의 <strong>데이터 타입</strong>을 문자열로 변환</p>
<p>7가지 문자열(string, number, boolean, undefined, symbol, object, function) 중 하나를 반환</p>
<ul>
<li>null을 반환하는 경우는 없다.</li>
<li>함수의 경우 undefined를 반환한다.</li>
</ul>
<p>➡️ 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">// -&gt; &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// -&gt; &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">NaN</span>; <span class="comment">// -&gt; &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// -&gt; &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// -&gt; &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>(); <span class="comment">// -&gt; &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> /test/gi; <span class="comment">// -&gt; &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;; <span class="comment">// -&gt; &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>null을 “null”이 아닌 “object”로 반환한다는데 주의하자</strong></p>
<p>이것은 자바스크립트의 첫 번째 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.</p>
<p>➡️ 따라서 <strong>null타입인지 확인할 때</strong>는 <strong>일치 연산자</strong>를 사용하자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> foo === <span class="literal">null</span>; <span class="comment">// -&gt; false</span></span><br><span class="line">foo === <span class="literal">null</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p><strong>🔥 선언하지 않은 식별자를 typeof연산자로 연산해보면 ReferenceError가 아닌 undefined를 반환한다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// undeclared 식별자를 선언한 적이 없다.</span></span><br><span class="line"><span class="keyword">typeof</span> undeclared; <span class="comment">// -&gt; undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="지수-연산자"><a href="#지수-연산자" class="headerlink" title="지수 연산자"></a>지수 연산자</h2><h3 id="✅-지수-연산자"><a href="#✅-지수-연산자" class="headerlink" title="✅ 지수 연산자"></a>✅ 지수 연산자</h3><p>: ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 거듭제곱하여 숫자 값을 반환한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>; <span class="comment">// -&gt; 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">2.5</span>; <span class="comment">// -&gt; 5.65685424949238</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">0</span>; <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="number">2</span> ** -<span class="number">2</span>; <span class="comment">// -&gt; 0.25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자가 도입되기 이전에는? 👉🏻 Math.pow 메서드를 사용</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// -&gt; 4</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">2.5</span>); <span class="comment">// -&gt; 5.65685424949238</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">2</span>); <span class="comment">// -&gt; 0.25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자는 다음과 같은 경우 Math.pow 메서드보다 가독성이 좋다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 지수 연산자의 결합 순서는 우항에서 좌항이다. 즉, 우결합성을 갖는다.</span></span><br><span class="line"><span class="number">2</span> ** (<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// -&gt; 512</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// -&gt; 512</span></span><br></pre></td></tr></table></figure>

<ul>
<li>음수를 거듭제곱의 밑으로 사용해 계산하려면 다음과 같이 괄호로 묶어야 한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">-<span class="number">5</span> ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">// SyntaxError: Unary operator used immediately before exponentiation expression.</span></span><br><span class="line"><span class="comment">// Parenthesis must be used to disambiguate operator precedence</span></span><br><span class="line"></span><br><span class="line">(-<span class="number">5</span>) ** <span class="number">2</span>; <span class="comment">// -&gt; 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">5</span>;</span><br><span class="line">num **= <span class="number">2</span>; <span class="comment">// -&gt; 25</span></span><br></pre></td></tr></table></figure>

<ul>
<li>지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.</li>
</ul>
<h2 id="그-외의-연산자"><a href="#그-외의-연산자" class="headerlink" title="그 외의 연산자"></a>그 외의 연산자</h2><p><img src="https://velog.velcdn.com/images/indongcha/post/87952395-013e-4fe9-892b-33e6d8226cb8/image.png" alt="옵셔널 체이닝 연산자, null 병합 연산자, 프로퍼티 삭제 연산자 등 "></p>
<p>옵셔널 체이닝 연산자, null 병합 연산자, 프로퍼티 삭제 연산자 등</p>
<h2 id="연산자의-부수-효과"><a href="#연산자의-부수-효과" class="headerlink" title="연산자의 부수 효과"></a>연산자의 부수 효과</h2><p>대부분의 연산자는 다른 코드에 영향을 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다.</p>
<p>💡 <strong>부수 효과가 있는 연산자</strong></p>
<ul>
<li>할당 연산자(&#x3D;)</li>
<li>증가&#x2F;감소 연산자 (++&#x2F;–)</li>
<li>delete 연산자</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 이는 x 변수를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 증가/감소 연산자(++/--)는 피연산자의 값을 변경하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 피연산자 x의 값이 재할당되어 변경된다. 이는 x 변수를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line">x++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.</span></span><br><span class="line"><span class="comment">// 이는 o 객체를 사용하는 다른 코드에 영향을 준다.</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">a</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="연산자-우선순위"><a href="#연산자-우선순위" class="headerlink" title="연산자 우선순위"></a>연산자 우선순위</h2><h3 id="✅-연산자-우선순위"><a href="#✅-연산자-우선순위" class="headerlink" title="✅ 연산자 우선순위"></a>✅ 연산자 우선순위</h3><p>: 여러 개의 연산자로 이뤄진 문이 실행될 때 <strong>연산자가 실행되는 순서</strong>를 의미한다.</p>
<p>우선 순위가 높을수록 먼저 실행된다.</p>
<p><img src="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F369f38d6-96d5-4aaa-9b44-58a8f0a68f43%2Fimage.png" alt="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F369f38d6-96d5-4aaa-9b44-58a8f0a68f43%2Fimage.png"></p>
<p>➡️ 우선순위가 가장 높은 <strong>그룹 연산자</strong>를 사용하여 우선 순위를 명시적으로 조절하는 것을 권장한다.</p>
<h2 id="연산자-결합-순서"><a href="#연산자-결합-순서" class="headerlink" title="연산자 결합 순서"></a>연산자 결합 순서</h2><h3 id="✅-연산자-결합-순서"><a href="#✅-연산자-결합-순서" class="headerlink" title="✅ 연산자 결합 순서"></a>✅ 연산자 결합 순서</h3><p>: 연산자의 어느쪽부터 평가를 수행할 것인지를 나타내는 순서</p>
<p><img src="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F84fa2eee-da12-43ca-81d1-5ba01a5683e5%2Fimage.png" alt="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2F84fa2eee-da12-43ca-81d1-5ba01a5683e5%2Fimage.png"></p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode Snippets 설정하기 - 우리의 손목은 소중하니까:)</title>
    <url>/2022/221027-archive/</url>
    <content><![CDATA[<h1 id="VSCode-스니펫-설정하기"><a href="#VSCode-스니펫-설정하기" class="headerlink" title="VSCode 스니펫 설정하기"></a>VSCode 스니펫 설정하기</h1><p>console.log를 매일 쓰고 있는데 이걸 계속 치다간 손목이 곧 망가질 것 같다라는 생각이 들었다.</p>
<p>cl만 검색해서 console.log를 완성하고 싶다..!</p>
<p>이전에 sass에 스니펫을 설정했었던 것 같은데 기억을 되돌려보자🤔</p>
<h3 id="Cmd-SHIFT-P-→-Configure-User-Snippets-클릭"><a href="#Cmd-SHIFT-P-→-Configure-User-Snippets-클릭" class="headerlink" title="Cmd + SHIFT + P → [Configure User Snippets] 클릭"></a><code>Cmd + SHIFT + P</code> → [Configure User Snippets] 클릭</h3><p>자신이 사용하는 언어를 클릭하자. 자바스크립트를 사용하니까 javascript.json 클릭!</p>
<h3 id="우리의-VSCode는-생각보다-친절하다"><a href="#우리의-VSCode는-생각보다-친절하다" class="headerlink" title="우리의 VSCode는 생각보다 친절하다"></a>우리의 VSCode는 생각보다 친절하다</h3><p>예시를 보고 만들고 싶은 스니펫을 만들어보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Place your snippets for javascript here. Each snippet is defined under a snippet name and has a prefix, body and</span></span><br><span class="line"><span class="comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span></span><br><span class="line"><span class="comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the</span></span><br><span class="line"><span class="comment">// same ids are connected.</span></span><br><span class="line"><span class="comment">// Example:</span></span><br><span class="line"><span class="comment">// &quot;Print to console&quot;: &#123;</span></span><br><span class="line"><span class="comment">// 	&quot;prefix&quot;: &quot;log&quot;,</span></span><br><span class="line"><span class="comment">// 	&quot;body&quot;: [</span></span><br><span class="line"><span class="comment">// 		&quot;console.log(&#x27;$1&#x27;);&quot;,</span></span><br><span class="line"><span class="comment">// 		&quot;$2&quot;</span></span><br><span class="line"><span class="comment">// 	],</span></span><br><span class="line"><span class="comment">// 	&quot;description&quot;: &quot;Log output to console&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>prefix</code>는 호출할 <strong>예약어</strong>이고</li>
<li><code>body</code>에 설정하는 내용은 예약어 호출 시 <strong>출력할 코드</strong></li>
<li>출력 코드 내부의 <code>$1</code>, <code>$2</code>로 설정된 부분은 포커스가 이동될 순서</li>
<li><code>$1</code>로 설정된 부분이 예약어 호출 시 처음으로 포커싱 될 위치이고 <strong>tab</strong> 키를 누르게 되면 <code>$2</code>로 포커싱이 이동한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;console.log print&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;prefix&quot;</span>: <span class="string">&quot;cl&quot;</span>,</span><br><span class="line">    <span class="string">&quot;body&quot;</span>: [<span class="string">&quot;console.log($1) &quot;</span>],</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Log output to console&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>해당 내용을 추가하고 저장하면 끝!</p>
<p><img src="https://2runzzal.com/media/RTV1aHQ2ZGt3RUcybExYeHBieVZaUT09/zzal.jpg"></p>
<p>이제 cl 하나로 console.log를 완성할 수 있게 되었다.😃</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>표현식과 문&#39;</title>
    <url>/2022/221020-archive/</url>
    <content><![CDATA[<h2 id="값"><a href="#값" class="headerlink" title="값"></a>값</h2><h3 id="✅-값"><a href="#✅-값" class="headerlink" title="✅ 값"></a>✅ 값</h3><p>: <strong>표현식</strong>이 평가되어 생성된 결과</p>
<p>✅ <strong>평가</strong></p>
<p>: 식을 해석해서 값을 생성하거나 참조하는 것</p>
<p>🙌🏻 다음 예제의 식은 평가되어 숫자 값 30을 생성한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10 + 20은 평가되어 숫자 값 30을 생성한다.</span></span><br><span class="line"><span class="number">10</span> + <span class="number">20</span>; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p><strong>🖥 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다.</strong></p>
<ul>
<li><p>메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다.</p>
</li>
<li><p>예를 들어, 메모리에 저장된 값 0100 0001을</p>
<ul>
<li>숫자로 해석하면? 👉🏻 65</li>
<li>문자로 해석하면? 👉🏻 ”A”</li>
</ul>
</li>
<li><p>변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름</p>
<p>➡️ 따라서 변수에 할당되는 것은 값이다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">10</span> + <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>위 예제의 sum 변수에 할당되는 것 👉🏻 10 + 20이 아니라 <strong>10 + 20이 평가된 결과인 숫자 값 30</strong></p>
<p>➡️즉, 변수 이름 sum이 기억하는 메모리 공간에 저장된 것은 값 30이다.</p>
</li>
</ul>
<p>🔥 <strong>값은 다양한 방법으로 생성할 수 있다.</strong></p>
<p>➡️ 식으로 생성할 수도 있지만, 가장 기본적인 방법은 <strong>리터럴</strong>을 사용하는 것이다.</p>
<h2 id="리터럴"><a href="#리터럴" class="headerlink" title="리터럴"></a>리터럴</h2><h3 id="✅-리터럴"><a href="#✅-리터럴" class="headerlink" title="✅ 리터럴"></a>✅ 리터럴</h3><p>: 사람이 이해할 수 있는 <strong>문자 또는 약속된 기호</strong>를 사용해 <strong>값을 생성</strong>하는 표기법</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 숫자 리터럴 3</span></span><br><span class="line"><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>3은 단순한 아라비아 숫자가 아니라 <strong>숫자 리터럴</strong>이다.</li>
<li>사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 코드에 기술하면 ➡️ 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성한다.</li>
</ul>
<p>🖥 <strong>리터럴을 사용하면 다양한 종류의 값을 생성할 수 있다.</strong></p>
<table>
<thead>
<tr>
<th>리터럴</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td>정수 리터럴</td>
<td>100</td>
</tr>
<tr>
<td>부동소수점 리터럴</td>
<td>10.5</td>
</tr>
<tr>
<td>2진수 리터럴</td>
<td>0b0100001</td>
</tr>
<tr>
<td>8진수 리터럴</td>
<td>0o101</td>
</tr>
<tr>
<td>16진수 리터럴</td>
<td>0x41</td>
</tr>
<tr>
<td>문자열 리터럴</td>
<td>“Hello”, “World”</td>
</tr>
<tr>
<td>불리언 리터럴</td>
<td>true, false</td>
</tr>
<tr>
<td>null 리터럴</td>
<td>null</td>
</tr>
<tr>
<td>undefined 리터럴</td>
<td>undefined</td>
</tr>
<tr>
<td>객체 리터럴</td>
<td>{ name: “Lee”, address: “Seoul” }</td>
</tr>
<tr>
<td>배열 리터럴</td>
<td>[1, 2, 3]</td>
</tr>
<tr>
<td>함수 리터럴</td>
<td>function(){}</td>
</tr>
<tr>
<td>정규 표현식 리터럴</td>
<td>&#x2F;[A-Z]+&#x2F;g</td>
</tr>
</tbody></table>
<h2 id="표현식"><a href="#표현식" class="headerlink" title="표현식"></a>표현식</h2><h3 id="✅-표현식"><a href="#✅-표현식" class="headerlink" title="✅ 표현식"></a>✅ 표현식</h3><p>: <strong>값으로 평가될 수 있는 문</strong>, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.</p>
<ul>
<li>표현식은 값으로 평가된다. 즉, 값으로 평가될 수 있는 문은 모두 표현식이다.</li>
<li>리터럴은? 👉🏻 값으로 평가된다. 따라서 리터럴도 표현식이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>위 예제의 100 👉🏻 리터럴</li>
<li>리터럴 100은? 👉🏻 자바스크립트 엔진에 의해 <strong>평가되어 값을 생성</strong>하므로 리터럴은 그 자체로 <strong>표현식</strong>이다.</li>
</ul>
<p>🙌🏻 다른 예제를 살펴보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">50</span> + <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>50 + 50은 👉🏻 <strong>리터럴</strong>과 <strong>연산자</strong>로 이루어져 있다.</li>
<li>하지만 50 + 50도 평가되어 <strong>숫자 값 100을 생성</strong>하므로 <strong>표현식</strong>이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">score;</span><br></pre></td></tr></table></figure>

<ul>
<li>변수 식별자를 참조하면 변수 값으로 평가된다.</li>
<li>식별자 참조 👉🏻 값을 생성하지는 않지만 <strong>값으로 평가</strong>되므로 <strong>표현식</strong>이다.</li>
</ul>
<p>🔥 <strong>표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.</strong></p>
<ul>
<li>다양한 표현식이 있지만 값으로 평가된다는 점에서 모두 동일하다.</li>
<li><strong>값으로 평가되는 문</strong>은 모두 표현식이다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 리터럴 표현식</span></span><br><span class="line"><span class="number">10</span>;</span><br><span class="line">(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 식별자 표현식(선언이 이미 존재한다고 가정)</span></span><br><span class="line">sum;</span><br><span class="line">person.<span class="property">name</span>;</span><br><span class="line">arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 연산자 표현식</span></span><br><span class="line"><span class="number">10</span> + <span class="number">20</span>;</span><br><span class="line">sum = <span class="number">10</span>;</span><br><span class="line">sum !== <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)</span></span><br><span class="line"><span class="title function_">square</span>();</span><br><span class="line">person.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p><strong>💡 표현식은 값으로 평가된다.</strong></p>
<ul>
<li><p>이때 표현식과 표현식이 평가된 값은 동등한 관계다.</p>
<ul>
<li>예를 들어, 수학 수식 1 + 2 &#x3D; 3에서 1 + 2는 3과 동치다.</li>
<li>즉, 1 + 2는 3과 같다고 할 수 있다.</li>
</ul>
</li>
<li><p>자바스크립트의 표현식 1 + 2는 평가되어 값 3을 생성하므로 표현식 1 + 2와 3은 동치다.</p>
<p><strong>➡️ 따라서 표현식은 값처럼 사용할 수 있다.</strong></p>
</li>
</ul>
<p><strong>📚 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.</strong></p>
<ul>
<li>예를 들어, 산술 연산자 +의 좌항과 우항에는 숫자 값이 위치해야한다.</li>
<li>이때 <strong>숫자 값으로 평가될 수 있는 표현식</strong>이라면 👉🏻 숫자 값 대신 사용할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 식별자 표현식 x는 3으로 평가된다.</span></span><br><span class="line">x + <span class="number">3</span>; <span class="comment">// -&gt; 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 예제의 x + 3은? 👉🏻 표현식</li>
<li><ul>
<li>연산자는 좌항과 우항의 값을 산술 연산하는 연산자이므로 좌항과 우항에는 숫자 값이 위치해야 함<ul>
<li>이때 좌항 x는 식별자 표현식 👉🏻 x는 할당되어 있는 숫자 값 3으로 평가한다.</li>
</ul>
</li>
</ul>
</li>
<li>이처럼 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다.</li>
</ul>
<h2 id="문"><a href="#문" class="headerlink" title="문"></a>문</h2><p>🔥 문과 표현식을 구별하고 해석하기</p>
<h3 id="✅-문"><a href="#✅-문" class="headerlink" title="✅ 문"></a>✅ 문</h3><p>: <strong>프로그램을 구성</strong>하는 <strong>기본 단위</strong>이자 <strong>최소실행 단위</strong></p>
<ul>
<li>문의 집합으로 이루어진 것 👉🏻 프로그램이며</li>
<li>문을 작성하고 순서에 맞게 나열하는 것 👉🏻 프로그래밍이다.</li>
</ul>
<p>문은 여러 <strong>토큰</strong>으로 구성된다.</p>
<p>✅ <strong>토큰</strong></p>
<p>: 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본요소</p>
<ul>
<li>키워드, 식별자, 연산자, 리터럴, 세미콜론이나 마침표 등의 특수기호는 기본 요소를 의미한다.</li>
</ul>
<p><img src="https://velog.velcdn.com/images/kozel/post/7a45d92d-ecf6-45a6-b90c-cfb6835d3c5a/image.jpeg" alt="https://velog.velcdn.com/images/kozel/post/7a45d92d-ecf6-45a6-b90c-cfb6835d3c5a/image.jpeg"></p>
<p>💡 <strong>문은 컴퓨터에게 내리는 명령으로, 명령문이라고도 부른다.</strong></p>
<ul>
<li>문이 실행되면 ➡️ 명령이 실행되고 무슨일인가가 일어난다.</li>
</ul>
<p><strong>📚 문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.</strong></p>
<ul>
<li>변수 선언문을 실행하면 👉🏻 변수가 선언</li>
<li>할당문을 실행하면 👉🏻 값이 할당</li>
<li>조건문을 실행하면 👉🏻 지정한 조건에 따라 실행할 코드블록({…})이 결정되어 실행</li>
<li>반복문을 실행하면 👉🏻 특정 코드 블록이 반복 실행</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식 문(할당문)</span></span><br><span class="line">x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 조건문</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복문</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="세미콜론과-세미콜론-자동-삽입-기능"><a href="#세미콜론과-세미콜론-자동-삽입-기능" class="headerlink" title="세미콜론과 세미콜론 자동 삽입 기능"></a>세미콜론과 세미콜론 자동 삽입 기능</h2><p>💡 <strong>세미콜론(;)은 문의 종료를 나타낸다.</strong></p>
<ul>
<li>자바스크립트 엔진이 <strong>문의 종료 위치를 파악</strong>하고 순차적으로 하나씩 문을 실행하기 때문에 문을 끝낼 때는 세미콜론을 붙여야 한다.</li>
<li>단, 0개 이상의 문을 중괄호로 묶은 코드 블록({ … })은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문에 붙이지 않는다.</li>
</ul>
<blockquote>
<p>물론 필수는 아니다. 자바스크립트에서 문의 끝에 붙이는 세미콜론은 옵션이므로 생략 가능하다. 이는 자바스크립트 엔진이 소스코드를 해석 할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI) 이 암묵적으로 수행되기 때문이다.</p>
</blockquote>
<p>하지만 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 간혹 있고 다수의 주장이 세미콜론을 붙여야 한다고 주장하니, 붙이는 습관을 들이는 것을 추천한다.</p>
<h2 id="표현식인-문과-표현식이-아닌-문"><a href="#표현식인-문과-표현식이-아닌-문" class="headerlink" title="표현식인 문과 표현식이 아닌 문"></a>표현식인 문과 표현식이 아닌 문</h2><p><strong>🔥 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.</strong></p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="comment">// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.</span></span><br><span class="line"><span class="comment">// x = 1 + 2는 표현식이면서 완전한 문이기도 하다.</span></span><br><span class="line">x = <span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>🖥 <strong>문에는 표현식인 문과 표현식이 아닌문이 있다.</strong></p>
<ul>
<li>표현식인 문 👉🏻 값으로 평가될 수 있는 문</li>
<li>표현식이 아닌 문 👉🏻 값으로 평가될 수 없는 문</li>
<li>변수 선언문은? ➡️ 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다.</li>
<li>할당문은? ➡️ 값으로 평가될 수 있다. 따라서 표현식인 문이다.</li>
</ul>
<p><strong>🖥 표현식과 문을 구별하는 방법 👉🏻 변수에 할당해 보는 것</strong></p>
<p>표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.</p>
<p>하지만 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다.</p>
<p>🙌🏻 다음 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표현식이 아닌 문은 값처럼 사용할 수 없다.</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">var</span> x; <span class="comment">// SyntaxError: Unexpected token var</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>변수 선언문 👉🏻 표현식이 아닌 문</p>
<p>➡️ 값으로 평가될 수 없다. 따라서 변수 선언문은 값처럼 사용할 수 없다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 변수 선언문은 표현식이 아닌 문이다.</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.</span></span><br><span class="line">x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>할당문 x &#x3D; 100 👉🏻 그 자체가 표현식</p>
<p>➡️ 즉, 할당문은 표현식인 문이기 때문에 값처럼 사용할 수 있다.</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표현식인 문은 값처럼 사용할 수 있다</span></span><br><span class="line"><span class="keyword">var</span> foo = (x = <span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>할당문을 값처럼 변수에 할당했다.</p>
</li>
<li><p>표현식인 문인 할당문 👉🏻 할당 값으로 평가된다.</p>
<p>➡️ 즉, x &#x3D; 100은 x 변수에 할당한 값 100으로 평가된다. 따라서 foo 변수에는 100이 할당된다.</p>
</li>
</ul>
<p><strong>✨ 완료 값(completion value)</strong></p>
<p>크롬 개발자 도구에서 <strong>표현식이 아닌 문을 실행</strong>하면 <strong>언제나 undefined를 반환</strong>한다. 👉🏻 <strong>완료 값</strong></p>
<p>완료 값은 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.</p>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 실습해보기 [ Express 환경 세팅하기 ]</title>
    <url>/2022/221112-archive/</url>
    <content><![CDATA[<h3 id="📚-데이터가-변경되면-변경된-내용을-다시-렌더링하자"><a href="#📚-데이터가-변경되면-변경된-내용을-다시-렌더링하자" class="headerlink" title="📚 데이터가 변경되면 변경된 내용을 다시 렌더링하자"></a>📚 <strong>데이터가 변경되면 변경된 내용을 다시 렌더링하자</strong></h3><p>수업시간에 Mock data를 만들어 데이터가 변경되면 setState 함수를 실행시켜 데이터의 변경사항을 렌더링했었다.<br>이 내용들을 공부하면서 state와 setState의 개념에 대해서 확실하게 알고갈 수 있었다.</p>
<p>하지만 이전 코드의 문제점이 있다. 회사에선 아무도 이런 코드로 프로그래밍을 하지 않는다는 것이다. 회사엔 데이터를 다루는 백엔드 개발자가 있을 것이고, 프론트엔드는 서버에 데이터를 요청하고 응답받은 데이터를 사용해서 사용자가 보는 화면에 렌더링을 할 것이다.</p>
<h2 id="Express로-서버를-만들어보자"><a href="#Express로-서버를-만들어보자" class="headerlink" title="Express로 서버를 만들어보자"></a>Express로 서버를 만들어보자</h2><p>서버에 데이터를 요청하고 응답받는 연습을 해보자. 연습을 하기 위해 Express 프레임워크를 사용해보자🙌🏻</p>
<h3 id="🔥-express의-역할-express는-뭐하는-친구야"><a href="#🔥-express의-역할-express는-뭐하는-친구야" class="headerlink" title="🔥 express의 역할 [ express는 뭐하는 친구야? ]"></a><strong>🔥 express의 역할 [ express는 뭐하는 친구야? ]</strong></h3><p><img src="https://velog.velcdn.com/images/riceintheramen/post/d222cd4a-70f4-4495-b620-300d81dad825/786d30e016fad2cb7dc2c76af86d55f6afd277dd5a8a80dd17b13332bfe0131f.png" alt="https://velog.velcdn.com/images/riceintheramen/post/d222cd4a-70f4-4495-b620-300d81dad825/786d30e016fad2cb7dc2c76af86d55f6afd277dd5a8a80dd17b13332bfe0131f.png"><br>Node.js를 위한 빠르고 쉬운 웹 프레임워크이다. 익히 들어본 자바의 spring처럼 Express는 JS의 웹 프레임워크이다. Express를 사용해 서버를 만들고 Node.js 개발 시 개발을 빠르고 손쉽게 할 수 있도록 도와주는 역할을 한다.</p>
<h3 id="🔥-express-설치하기-express-설치-어렵지-않아요"><a href="#🔥-express-설치하기-express-설치-어렵지-않아요" class="headerlink" title="🔥 express 설치하기 [ express 설치 어렵지 않아요! ]"></a><strong>🔥 express 설치하기 [ express 설치 어렵지 않아요! ]</strong></h3><ol>
<li><p>먼저, 프로젝트를 진행할 프로젝트 폴더를 만든다.</p>
</li>
<li><p>npm init -y로 초기화를 진행한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;playground&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>초기화를 하면 package.json 파일이 생성된 것을 확인할 수 있다.</p>
</li>
<li><p>npm i express CLI 명령어를 사용해 express를 설치한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;playground&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  **<span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.18.2&quot;</span></span><br><span class="line">  &#125;**</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dependencies에 추가되었다! 아주 간단하게 express 설치를 완료했다. 😎</p>
</li>
</ol>
<h3 id="🔥-express-사용해서-서버-실행하기-설치는-했는데-어떻게-사용하는건데"><a href="#🔥-express-사용해서-서버-실행하기-설치는-했는데-어떻게-사용하는건데" class="headerlink" title="🔥 express 사용해서 서버 실행하기 [ 설치는 했는데 어떻게 사용하는건데? ]"></a><strong>🔥 express 사용해서 서버 실행하기 [ 설치는 했는데 어떻게 사용하는건데? ]</strong></h3><ol>
<li><p>express를 import 해오자</p>
<p>: require를 사용해서 외부 모듈을 가져오자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>babel을 사용하면 흔히 아는 import 키워드를 사용해서 가져올 수도 있지만 지금은 babel을 따로 설치하지 않았기 때문에 require를 사용하자</p>
</li>
<li><p>express를 실행하자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line">**<span class="keyword">const</span> app = <span class="title function_">express</span>();**</span><br></pre></td></tr></table></figure>
</li>
<li><p>app.<strong>listen</strong>( ) 메서드를 사용하자</p>
<p>: app.listen( ) 메서드는 웹 서버를 시작하는 시작점의 역할을 한다.</p>
<p>app.listen은 두 개의 인자를 받는데, 첫 번째 인자로 PORT 번호 두 번째 인자로 listen 메서드로 서버를 계속 열어두면 무한 루프로 실행될 콜백함수를 받는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server Listening on http://localhost:<span class="subst">$&#123;PORT&#125;</span>)</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>

<p>이제 node app.js로 실행시켜보면?</p>
<p><img src="/../img/terminal.png"></p>
<p>👉🏻 서버가 열린 것을 확인할 수 있고</p>
<p><img src="/../img/result.png"></p>
<p>👉🏻 Cannot GET &#x2F;이 뜨는것을 확인할 수 있다.</p>
<p>이러면 express 서버를 실행시키는 것까지 성공적으로 완료했다!</p>
</li>
</ol>
<h3 id="🔥-받은-요청-처리하기-이걸-우리는-라우팅이라고-부르기로-했어요"><a href="#🔥-받은-요청-처리하기-이걸-우리는-라우팅이라고-부르기로-했어요" class="headerlink" title="🔥 받은 요청 처리하기 [ 이걸 우리는 라우팅이라고 부르기로 했어요 ]"></a><strong>🔥 받은 요청 처리하기 [ 이걸 우리는 라우팅이라고 부르기로 했어요 ]</strong></h3><p>프론트엔드 관점에서 생각을 하는 것보다 내가 서버의 입장이 되었을 때, express를 이해하기 쉽다. 나는 서버야!라는 생각을 가지고 코드를 보면,</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>‘&#x2F;’ path로 get 요청이 오면 👉🏻 <h1>Hello World</h1> 을 보내주자와 동일하다<br>정리하면 이러한 클라이언트 요청에 응답하는 방법을 결정하는 것을 <strong>라우팅</strong>이라 한다. 각 라우트는 하나 이상의 핸들러 함수를 가질 수 있으며, 이러한 함수는 라우트가 일치할 때 실행된다.<br>라우트 정의에는 다음과 같은 구조가 필요하다.<br><img src="https://poiemaweb.com/img/define-route.png" alt="https://poiemaweb.com/img/define-route.png"><br>지금은 코드 하나를 작성하고 변경된 내용을 확인하려면 서버를 껐다가 다시 켜야하는 불편함이 있다. 개발자는 불편함을 참으면 안된다고 배웠으며, 우리의 선배님들은 이 불편함을 해결하기 위해 무언가를 만들어 내셨을 것이다. 그것이 바로 nodemon이다.<br><a href="https://www.npmjs.com/package/nodemon">nodemon</a><br>nodemon은 변경된 내용들을 계속 watch하면서 자동적으로 서버를 껐다가 켜주는 역할을 한다.</p>
<h3 id="🖥-dependencies와-devDependencies의-차이점"><a href="#🖥-dependencies와-devDependencies의-차이점" class="headerlink" title="🖥 dependencies와 devDependencies의 차이점"></a>🖥 dependencies와 devDependencies의 차이점</h3><p>설치를 하기 전에 생각을 해봐야 할 것이 있다. 이 nodemon은 어디에 설치를 해야할까?<br>다시 말해서, nodemon은 사용자가 필요한 패키지인가?<br>nodemon은 개발자가 사용하기 위해서 설치하는 것이기 때문에 배포할 때에는 필요없는 기능이다. 그렇기 때문에 <code>—save-dev</code> 라는 옵션을 추가해서 install 해야한다.<br><code>npm i —D nodemon</code><br>-D와 —save-dev는 동일하다.<br>nodemon을 설치했다면 package.json에서 script를 수정해보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;playground&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    **<span class="string">&quot;start&quot;</span>: <span class="string">&quot;nodemon server.js&quot;</span>**</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;express&quot;</span>: <span class="string">&quot;^4.18.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;nodemon&quot;</span>: <span class="string">&quot;^2.0.20&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nodemon으로 server.js를 실행시키겠다는 단축키를 만들었다.<br>이제 터미널에 node server.js가 아닌 npm run start를 사용해서 서버를 실행시킬 수 있다.</p>
<h3 id="✏️-정적-파일-HTML-제공-HTML은-어떻게-받아오는거지"><a href="#✏️-정적-파일-HTML-제공-HTML은-어떻게-받아오는거지" class="headerlink" title="✏️ 정적 파일(HTML) 제공 [ HTML은 어떻게 받아오는거지? ]"></a>✏️ 정적 파일(HTML) 제공 [ HTML은 어떻게 받아오는거지? ]</h3><p>HTML, CSS, Javascript, 이미지 파일과 같은 정적 파일을 제공하기 위해 <code>express.static</code>을 사용한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PORT</span> = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">**app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));**</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server Listening on http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>public directory에 있는 파일을 사용할 수 있다.<br>우린 지금 public 폴더가 없으니, public 폴더를 만들고 index.html을 만들어보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ko-KR&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./css/style.css&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;js/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World! 😎<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/../img/result2.png"><br>이제 서버는 애플리케이션이 실행되면 index.html을 제공한다.</p>
<hr>
<h3 id="참고-자료"><a href="#참고-자료" class="headerlink" title="참고 자료"></a>참고 자료</h3><ul>
<li><a href="https://poiemaweb.com/express-basics">https://poiemaweb.com/express-basics</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>TIL에 대한 나의 생각</title>
    <url>/2022/221117-archive/</url>
    <content><![CDATA[<h2 id="TIL-꼭-써야하는건가-🙋🏻‍♀️"><a href="#TIL-꼭-써야하는건가-🙋🏻‍♀️" class="headerlink" title="[ TIL, 꼭 써야하는건가? 🙋🏻‍♀️ ]"></a>[ TIL, 꼭 써야하는건가? 🙋🏻‍♀️ ]</h2><p>비전공자로서 개발공부를 처음 시작할 때, 모든 용어들이 낯설었지만 그 중에서도 TIL이라는 용어를 처음 들어봤었다. Today I Learned의 약자로 하루동안 배웠던 것들을 정리한다는 의미이다.<br>주변에서 TIL을 쓰면 도움이 될거라는 말은 많이 들었었지만, 왜 써야하는지 알지 못한채로 쓰기 시작했던 것 같다. 왜 써야하는건지 모른채로 쓰는건 스스로에겐 아무런 도움이 되지 않을 텐데 말이다.</p>
<p><em>(어리석은 내 자신 반성하자…)</em><br><img src="https://2runzzal.com/media/L09nRFBaWXJCWnV1Q1BEYWNrVmQ3dz09/zzal.jpg"></p>
<p>그래서 TIL은 꼭 써야하는걸까?<br>공부를 하다보니 공부해야 할 양은 끝이 없고, 오늘 배운다고 내일 기억이 나는게 아니라는 것을 뼈저리게 느꼈다. 나의 기억 저장 공간은 턱없이 부족하며, 무조건 글로 남겨야 한다는 것을 잊지 말자.</p>
<p>TIL은 오늘의 기억을 잊지 않기 위해 작성하는 것이다. 공부를 하다보면 다시 정리해서 기록하는 것이 귀찮을 때도 있다. 하지만 바로 기록해놓지 않으면 결국 제자리이기 때문에 매일 TIL은 꼭 쓰는 것이 좋다고 생각한다.</p>
<h2 id="✏️-TIL-작성-방법"><a href="#✏️-TIL-작성-방법" class="headerlink" title="[ ✏️ TIL 작성 방법 ]"></a>[ ✏️ TIL 작성 방법 ]</h2><p>그렇다면 TIL은 어떻게 쓰는게 좋을까? 🤔</p>
<p>내가 여태 써온 TIL은 오늘은 무엇을 공부했는지, 공부한 내용이 무엇인지에 대해서 작성했었다. 오늘 배운 것, 내일 해야 할 것들에 대해서 리스트로 정리하는 형식을 사용했었는데, 오늘 수업을 듣고 나서 내가 여태 써온 TIL이 안티패턴이라는 것을 알게되었다.</p>
<p>TIL은 무엇을 배웠는지 적는 것이 아니라 오늘 배웠던 것을 토대로 내가 무엇을 몰랐는지, 이전엔 어떻게 공부했었는데 이제 무엇을 새롭게 알게되었는지에 대해 정리하는 것이라는걸 배웠다.</p>
<p>이제부터는 이전에 써왔던 TIL과 다르게 어떤 내용이 나에게 새롭게 다가왔는지, 회고하는 식으로 정리를 해야겠다. 어떤 점이 문제가 있었고, 왜 문제가 있었는지 파악을 하고, 그 이후로 어떻게 개선해 나갈 건지에 대해서 정리하자 .</p>
]]></content>
      <tags>
        <tag>Retrospective</tag>
      </tags>
  </entry>
  <entry>
    <title>Frontend 관점에서 바라본 MVC 패턴</title>
    <url>/2022/221102-archive/</url>
    <content><![CDATA[<h2 id="MVC-패턴이란"><a href="#MVC-패턴이란" class="headerlink" title="MVC 패턴이란?"></a>MVC 패턴이란?</h2><p>사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 디자인 패턴</p>
<p><strong>M</strong>odel-<strong>V</strong>iew-<strong>C</strong>ontroller의 약자로 애플리케이션을 세 가지 역할로 구분한 개발 방법론</p>
<p><a href="https://developer.mozilla.org/ko/docs/Glossary/MVC">MVC - 용어 사전 | MDN</a></p>
<h2 id="MVC란-패턴은-왜-생겨난-걸까-🤔"><a href="#MVC란-패턴은-왜-생겨난-걸까-🤔" class="headerlink" title="MVC란 패턴은 왜 생겨난 걸까? 🤔"></a>MVC란 패턴은 왜 생겨난 걸까? 🤔</h2><h3 id="역사-1979년-GUI-데스크톱-애플리케이션이-등장하면서-생긴-패턴"><a href="#역사-1979년-GUI-데스크톱-애플리케이션이-등장하면서-생긴-패턴" class="headerlink" title="역사 [ 1979년 GUI 데스크톱 애플리케이션이 등장하면서 생긴 패턴 ]"></a>역사 [ 1979년 GUI 데스크톱 애플리케이션이 등장하면서 생긴 패턴 ]</h3><ul>
<li>사람-컴퓨터 간의 간극을 해결하기 위함.</li>
<li>도메인의 재사용을 목적으로 둔다.</li>
<li>입력 &amp; 이벤트 &amp; 출력 메커니즘을 자연스럽게 처리하기 위함이다.</li>
</ul>
<h3 id="현대식-MVC-패턴의-등장-애플-Applie-에서-발표한-Cocoa-MVC-패턴"><a href="#현대식-MVC-패턴의-등장-애플-Applie-에서-발표한-Cocoa-MVC-패턴" class="headerlink" title="현대식 MVC 패턴의 등장 [ 애플(Applie)에서 발표한 Cocoa MVC 패턴 ]"></a><strong>현대식 MVC 패턴의 등장 [ 애플(Applie)에서 발표한 Cocoa MVC 패턴 ]</strong></h3><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://k.kakaocdn.net/dn/dlf6g4/btrj0LcpNei/uJKMEIQ8tlN8LvOqMBJiw0/img.png" alt="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fdlf6g4%2Fbtrj0LcpNei%2FuJKMEIQ8tlN8LvOqMBJiw0%2Fimg.png"></p>
<p>👉🏻 사용자가 Controller를 조작하면 Controller는 Model을 통해 데이터를 가져오고 그 데이터를 바탕으로 View를 통해 시각적 표현을 제어하여 사용자에게 전달하게 된다.</p>
<p><strong>사용자가 구글에 “코딩”이라고 검색했을 때,</strong></p>
<ol>
<li>Controller는 코딩에 대한 검색 결과 데이터를 Model에게 요청한다.</li>
<li>그럼 이 Model은 검색 결과 데이터를 찾아서 Controller에게 전달하고</li>
<li>Controller는 다시 View에 전달한다.</li>
</ol>
<h2 id="🖥-Model-View-Controller가-뭔데"><a href="#🖥-Model-View-Controller가-뭔데" class="headerlink" title="🖥 Model, View, Controller가 뭔데?"></a>🖥 Model, View, Controller가 뭔데?</h2><ul>
<li>Model: 데이터와 비즈니스 로직을 관리 (데이터와 관련된 일을 하는 곳)</li>
<li>Controller: 명령을 모델과 뷰 부분으로 라우팅 (Model과 View를 이어주는 역할)</li>
<li>View: 레이아웃과 화면을 처리 (사용자에게 보여자는 것을 담당)</li>
</ul>
<h2 id="모델-뷰-컨트롤러-예시"><a href="#모델-뷰-컨트롤러-예시" class="headerlink" title="모델 뷰 컨트롤러 예시"></a>모델 뷰 컨트롤러 예시</h2><p>간단한 쇼핑 리스트 앱이 있다고 상상해보자.</p>
<p>우리가 원하는 것은 <strong>이번 주에 사야할 각 항목의 이름, 개수, 가격의 목록</strong></p>
<h3 id="MVC를-사용해-이-기능의-일부를-구현하는-방법"><a href="#MVC를-사용해-이-기능의-일부를-구현하는-방법" class="headerlink" title="[ MVC를 사용해 이 기능의 일부를 구현하는 방법 ]"></a>[ MVC를 사용해 이 기능의 일부를 구현하는 방법 ]</h3><p><img src="https://developer.mozilla.org/en-US/docs/Glossary/MVC/model-view-controller-light-blue.png" alt="https://developer.mozilla.org/en-US/docs/Glossary/MVC/model-view-controller-light-blue.png"></p>
<ul>
<li>모델<ul>
<li>앱이 포함해야할 <strong>데이터</strong>가 무엇인지를 정의</li>
<li><strong>데이터의 상태가 변경</strong>되면 모델을 일반적으로 뷰에게 알리며(따라서 필요한대로 화면을 변경할 수 있습니다) 가끔 컨트롤러에게 알리기도 한다. (업데이트된 뷰를 제거하기 위해 다른 로직이 필요한 경우).</li>
<li>리스트 항목이 포함해야 하는 데이터(품목, 가격 등)와 이미 존재하는 리스트 항목이 무엇인지를 지정한다.</li>
</ul>
</li>
<li>뷰<ul>
<li>앱의 데이터를 보여주는 방식을 정의</li>
<li>뷰는 항목이 사용자에게 보여지는 방식을 정의하며, 표시할 데이터를 모델로부터 받는다.</li>
</ul>
</li>
<li>컨트롤러<ul>
<li>앱의 사용자로부터의 입력에 대한 응답으로 모델 및&#x2F;또는 뷰를 업데이트하는 로직을 포함한다.</li>
<li>쇼핑 리스트는 항목을 추가하거나 제거할 수 있게 해주는 입력 폼과 버튼을 갖는다.</li>
<li>이러한 액션들은 모델이 업데이트되는 것이므로 입력이 컨트롤러에게 전송되고, 모델을 적당하게 처리한다음, 업데이트된 데이터를 뷰로 전송한다.</li>
<li>단순히 데이터를 다른 형태로 나타내기 위해 뷰를 업데이트하고 싶은 경우<ul>
<li>(예를 들면, 항목을 알파벳순서로 정렬한다거나, 가격이 낮은 순서 또는 높은 순서로 정렬).</li>
<li>이런 경우에 컨트롤러는 모델을 업데이트할 필요 없이 바로 처리할 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="웹에서의-MVC"><a href="#웹에서의-MVC" class="headerlink" title="웹에서의 MVC"></a>웹에서의 MVC</h2><p>프론트엔드단에선 MVC 패턴을 어떻게 바라볼 수 있을까? 백엔드처럼 확실하게 MVC 패턴으로 프로그래밍할 수는 없다. 우리에게 View는 사용자가 보여지는 렌더링된 화면 즉, DOM이고 Model은 데이터베이스에 요청했을 때 받아오는 JSON 파일이다.</p>
<p>데이터의 흐름은 한 방향으로 흘러야한다. 양방향으로 연결되는 순간 내가 보낸 데이터가 어느 방향으로 흘러갔는지, 또한 이 데이터는 어느 방향에서 흘러왔는지 파악하기가 힘들어진다. 단순한 구조가 이해하기 더 빠르기 때문에 one-way data flow를 지켜야한다.</p>
<p><strong>그렇다면 어떻게 흘러가야하는게 맞을까?</strong></p>
<p>사용자가 애플리케이션을 동작하는 경우를 생각해보면 이해하기 쉽다. 사용자는 화면에 보이는 버튼, 또는 입력창에 클릭을 하거나 글씨를 입력한다. 👉🏻 이것을 사용자의 액션이라고 부른다.</p>
<p>사용자의 액션을 감지하는 이벤트 핸들러는 상태를 변화시킬 수 있는 기능을 가지는 함수에게 상태를 변경해달라고 부탁한다. 즉, 특정한 setState를 할 수 있는 기능을 가진 함수를 호출한다. 예를 들어, 할 일 리스트가 하나 더 추가되어야하는 경우 이벤트 핸들러는 사용자가 입력한 값을 addTodo에 전달한다.</p>
<p>인자로 추가되어야하는 내용을 전달받은 addTodo 함수는 setState를 호출하여 어떤 내용을 변경시켜야하는지에 내용을 전달해준다. 👉🏻 이렇게 state를 변경시키는 역할을 하는 함수들을 state mutator라고 부른다.</p>
<p>state가 변경되었으면 render 함수를 호출해서 다시 리렌더링을 시키는 일을 해야하고 사용자는 변경된 내용을 화면에서 다시 볼 수 있다. 이렇게 한 방향으로 계속해서 흘러가야한다.</p>
<p>그림으로 정리하면 다음과 같다.<br><img src="/../img/mvc.jpeg"></p>
<h3 id="MVC-패턴으로-파일을-모듈화하자"><a href="#MVC-패턴으로-파일을-모듈화하자" class="headerlink" title="[ MVC 패턴으로 파일을 모듈화하자 ]"></a>[ MVC 패턴으로 파일을 모듈화하자 ]</h3><p>한 파일에 모든 내용을 집어넣는 것은 코드 가독성을 떨어뜨릴 뿐만 아니라, 유지 보수성도 떨어진다. 파일을 분리시키고 싶은 생각이 들 때 한 가지 의문점이 들기 시작한다. 어떤 기준을 가지고 파일을 모듈화해야하지?</p>
<p>MVC 관점에서 모듈화를 해보자. 일반적으로 알려져있는 MVC 패턴이 아닌, 앞서 말한 프론트엔드에서의 MVC 패턴을 말한다.</p>
<ul>
<li>eventHandler<ul>
<li>사용자의 액션을 감지할 수 있는 이벤트 핸들러 함수만을 모듈화한다.</li>
</ul>
</li>
<li>state<ul>
<li>상태로 관리하는 정보들과, 그 상태를 변경시킬 수 있는 함수들을 모듈화한다.</li>
</ul>
</li>
<li>render<ul>
<li>변경된 내용으로 render 함수 호출을 통해 DOM을 다시 생성한다.</li>
</ul>
</li>
</ul>
<hr>
<p>+) MVC 패턴에 대한 내용 자료 참고<br><a href="https://cocoon1787.tistory.com/733">https://cocoon1787.tistory.com/733</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>input에 keydown 이벤트를 사용했을 때 e.target.value가 예상과 다르게 나오는 이유</title>
    <url>/2022/221119-archive/</url>
    <content><![CDATA[<p>검색창을 구현하는 과정에서 input 창에 텍스트를 입력하면 input.value를 가져오도록 하려고 했다. 이때 keydown 이벤트가 발생하면 e.target.value를 가져올 수 있게 만들었다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;input-text&quot;</span> /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">const</span> $inputText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.input-text&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  $inputText.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">value</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/leejaelll/TIL/raw/main/TIL/image/error1.png"></p>
<p>콘솔 창을 확인해보면 텍스트를 입력했을 때 바로 value를 보여주는 것이 아니라 맨 처음에는 빈 텍스트가 찍히고 그 다음에 입력한 텍스트 값을 가져오는 것을 볼 수 있다.</p>
<h3 id="📚-keydown-이벤트는-input-요소의-‘바뀌기-전의-값’을-반환한다"><a href="#📚-keydown-이벤트는-input-요소의-‘바뀌기-전의-값’을-반환한다" class="headerlink" title="[ 📚 keydown 이벤트는 input 요소의 ‘바뀌기 전의 값’을 반환한다. ]"></a>[ 📚 keydown 이벤트는 input 요소의 ‘바뀌기 전의 값’을 반환한다. ]</h3><p>그렇기 때문에 value가 변경되었을 때 변경된 요소를 반환하는 것이 아니라 이전의 값을 보여주는 것이다. 만약 이벤트 타깃을 input으로 하고, input의 value를 가지고 오고 싶다면 input 이벤트를 사용해야한다.</p>
<p>관련된 이벤트들(keydown, keyup, input, change)을 한 번에 비교해보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $inputText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.input-text&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// keydown event</span></span><br><span class="line">$inputText.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;keydown event occur!!&#x27;</span>, <span class="string">`input key: <span class="subst">$&#123;e.key&#125;</span>/current input value: <span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// keyup event</span></span><br><span class="line">$inputText.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;keyup event occur!!&#x27;</span>, <span class="string">`input key: <span class="subst">$&#123;e.key&#125;</span>/current input value: <span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// input event</span></span><br><span class="line">$inputText.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;input event occur!!&#x27;</span>, <span class="string">`input key: <span class="subst">$&#123;e.data&#125;</span>/current input value: <span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// change event</span></span><br><span class="line">$inputText.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;change event occur!!&#x27;</span>, <span class="string">`input key: <span class="subst">$&#123;e.data&#125;</span>/current input value: <span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/leejaelll/TIL/raw/main/TIL/image/error2.png"></p>
<p>a라는 텍스트를 입력했을 때, 이벤트는 keydown → input → keyup 순으로 발생한다.<br>input 이벤트는 input의 value가 변경되는 순간 이벤트가 발생한다. 그리고 input 요소에서 벗어나기 위해 엔터 혹은 다른 영역을 클릭했을 때 change 이벤트가 발생한다.</p>
<h2 id="Review-😎"><a href="#Review-😎" class="headerlink" title="Review 😎"></a>Review 😎</h2><p>keydown과 keyup은 눌리고 손을 뗐을 때 이 두 차이만 있고 나머지 동작은 동일하다고 생각했었는데, 이번 기회를 통해 keydown과 keyup 이벤트의 차이점에 대해서 알게 되었다.</p>
<p>만약 input에 이벤트를 발생시키는 경우라면, keyboard 이벤트 대신 <strong>input 이벤트</strong>를 사용하자.</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>제로베이스 커넥to 2기를 마치며</title>
    <url>/2022/221226-archive/</url>
    <content><![CDATA[<p>8월 29일을 시작으로 12월 23일까지 총 4개월의 기간동안의 제로베이스 오프라인 교육이 드디어 끝났다. 뜻 깊었던 4개월을 회고해보려고한다.</p>
<p>커넥to는 온라인 수강생 중 우수 수강생에게 제공하는 무료 오프라인 교육이다. 내가 제로베이스라는 부트캠프를 선택한 이유도 바로 이 오프라인 교육 때문이었다. (열심히 공부하면 우수 수강생이 될 수 있지 않을까라는 막연한 생각이긴 했지만..😐)</p>
<h2 id="메일-한-통으로-시작된-커넥to의-시작"><a href="#메일-한-통으로-시작된-커넥to의-시작" class="headerlink" title="메일 한 통으로 시작된 커넥to의 시작"></a>메일 한 통으로 시작된 커넥to의 시작</h2><p>생각지도 못한 우수 수강생 메일을 받았다. 와 나 진짜 된거야?<br><img src="https://github.com/leejaelll/TIL/raw/main/TIL/image/221226-01.png"></p>
<p>메일을 읽어보니 월요일부터 금요일 10to10으로 진행되며, 교육과정만 무료고 그외 교통비&#x2F;숙식비 등은 본인이 부담해야한다했다. 메일을 읽고 나서 바로 든 생각은 고등학생 때도 안해본 텐투텐을 견딜 수 있을까? 내가 정말 우수 수강생인가? 다른 사람들 사이에서 너무 뒤쳐지면 어떡하지 :( 였다. <em>(지금 생각해보면 조금 한심한 생각이라고 느껴지지만 그 땐 그랬었지…ㅠ )</em></p>
<h2 id="HTML-이렇게-어려운-거였어"><a href="#HTML-이렇게-어려운-거였어" class="headerlink" title="HTML 이렇게 어려운 거였어?"></a>HTML 이렇게 어려운 거였어?</h2><p>처음 한 달간은 HTML 수업이 진행되었다. 수업은 김데레사 강사님께서 진행해주셨는데 웹 접근성 분야에서 유명하신 강사님이셨다.🥺</p>
<p><a href="https://blog.naver.com/fastcampus_nklcb/222405159434">제로베이스 스쿨 교육 과정 블로그 : 네이버 블로그</a></p>
<p>내가 생각한 HTML&#x2F;CSS는 화면에 내가 원하는대로 그려지면 되는거 아닐까? 라고 생각했었는데 이게 왠걸?</p>
<p>모든 태그에는 목적이 있다는 걸 처음 알게되었고 CSS는 속성마다 어떤 특징을 가지고 있는지 하나하나 가르쳐주시면서 정말 어렵다라는걸 느끼게 되었다. 가장 크게 배운 건 어떠한 환경에서도 모든 사람이 사용할 수 있도록 만들어야 한다는 것이었다.</p>
<p>웹 접근성 그리고 최적화(Google Vitals)를 공부하면서 정말 깊이있게 공부했다라는 생각이 들었다. ‘아! 프론트엔드 개발자를 지망한다면서 이것도 모르면 안되지!’라는 생각이 들 정도로 왜 공부해야하는가에 대해서 스스로 느낄 수 있도록 강의해주셨다. 내가 봐왔던 교육자 중에 가장 책임의식을 가지고 교육을 해주신 분이 아닐까 싶을 정도로.</p>
<p>강의할 때는 카리스마 넘치시는 호랑이 선생님인데 강의 이외의 모습은 너무 친절하신 분이었다.</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>정신없이 HTML&#x2F;CSS 프로젝트를 끝내니 자바스크립트 수업이 다가왔다. 처음 프론트엔드 개발자가 되고싶다고 생각하고 처음 산 책이 ‘자바스크립트 Deep Dive’인데 그 책을 쓰신 분이 강의를 해주신다니…!</p>
<p>이건 무조건 어떻게든 수업을 따라가야겠다라는 마음을 먹고 수업을 듣기 시작했다. 처음에는 모르는 내용이 있으면 괜히 나만 모른다는 생각에 강의 시간에 질문하지 않고 조용히 지나가려고 했었는데 이 부분에 대해서 많이 혼났던 것 같다. 혼나는 건 참 슬픈 일이다. 돌이켜보니 강사님한테 무식하다는 얘기를 듣는 것보다 반 애들한테 무식하게 보이고 싶지 않았던 게 아닐까 싶다. 웅모님 덕분에 더 악바리로 공부하기로 마음먹고 정신차린 이후로는 뭐든지 물어보려고 노력했던 것 같다.</p>
<p>자바스크립트를 공부하면서 느꼈던 건 돌아가기만 하는 코드가 다가 아니라는 것, 돌아가게 만들었다면 그 때부터가 시작이라는 것이다. 강사님은 항상 돌아간다고 거기서 넘어갈게 아니라, 항상 가독성이 좋은 코드를 작성하기 위해 고민해야한다고 말씀해주셨다. 가독성이 좋은 코드를 만들기 위해선 자바스크립트의 기본 지식을 잘 알고 있어야 가능하다고 생각한다. 커넥to가 끝나고 나서 혼자 공부할 때에도 DeepDive 책은 반복해서 읽어야지!🙌🏻</p>
<p>커넥to 과정을 들을 때에는 실력이 제자리인 것 같다라는 생각을 많이 했다. 같이 공부하는 사람들을 계속해서 성장하는데.. 왜 나만 늘지않지?라는 고민이 계속해서 들었었는데 끝나고나니 나 스스로도 많이 성장했다고 느껴진다. 이전엔 혼자 어떻게 공부해야할지 항상 막막했는데 스스로 공부하는 방법을 터득한 것 같다. 이것만으로도 큰 수확이 아닐까. 힘들기도 했지만 너무 보람찬 4개월이었다!</p>
]]></content>
      <tags>
        <tag>Retrospective</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 새로운 시작🐥</title>
    <url>/2023/230213-archive/</url>
    <content><![CDATA[<h2 id="부트캠프-했는데-왜-또-해"><a href="#부트캠프-했는데-왜-또-해" class="headerlink" title="부트캠프, 했는데 왜 또 해?"></a>부트캠프, 했는데 왜 또 해?</h2><p><img src="https://codestates-photo.s3.ap-northeast-2.amazonaws.com/codestates_logo_thumbnail.jpg"></p>
<p>그렇다. 나는 이미 제로베이스로 부트캠프를 경험한 적이 있다. 원래는 온라인 부트캠프이지만 좋은 기회로 오프라인 수업도 들었다. 온라인 부트캠프는 나의 성장엔 도움이 거의 되지 않았고, 오프라인 교육은 자바스크립트 과정까지만 들을 수 있었다. 취업 시장에선 리액트가 필수인 상황이고 바로 취업하기는 어렵다고 생각해서 국비로 들을 수 있는 코드스테이츠를 선택하게 되었다.</p>
<p>코드스테이츠를 선택하게 된 이유는 다른 곳들보다 오래되기도 했고, 수강생과 수료생들 간에 커뮤니티가 활발해서이다. 수료생들과의 활발한 커뮤니케이션을 하고 싶은 마음도 있었고 현재 실무를 경험하고 있는 개발자의 조언도 듣고 싶었다. 다시 처음이라는 마음으로 열심히 배워나가야지 ｡·͜·｡</p>
<h2 id="이젠-전략적으로-공부해야할-때"><a href="#이젠-전략적으로-공부해야할-때" class="headerlink" title="이젠 전략적으로 공부해야할 때"></a>이젠 전략적으로 공부해야할 때</h2><p>제로베이스 커넥to 수업을 들을 땐 정말 아무것도 모르는 노베이스에서 수업을 들었기 때문에 그저 학습에만 초점을 두었다. 취업 걱정은 사치일 정도로 HTML과 자바스크립트 공부에 모든 시간을 다 쓴 것 같다.</p>
<p>하지만 이젠 취업을 해야하니까! 취준생의 마음으로 어떻게 나를 매력적으로 어필할 수 있을 것인가에 대해서 항상 생각하고 초반부터 이력서 작성을 꾸준히 할 생각이다. 포트폴리오뿐만 아니라 이력서 또한 충분한 시간을 거쳐서 작성해야 좋은 결과물이 나온다고 생각한다.</p>
<h2 id="두근두근-첫-수업"><a href="#두근두근-첫-수업" class="headerlink" title="두근두근 첫 수업"></a>두근두근 첫 수업</h2><p>오늘 코드스테이츠 첫 수업을 들었다. 오늘은 간단한 오리엔테이션이었기 때문에 특별한 지식을 배운 것 없지만, 장거리 마라톤을 뛰기 위해 준비운동을 할 수 있었던 시간이었던 것 같다. 44기 수강생들과 함께 성장할 수 있었으면 좋겠다!🏃🏻</p>
]]></content>
      <tags>
        <tag>Retrospective</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML의 기초 정리하기</title>
    <url>/2023/230214-archive/</url>
    <content><![CDATA[<h2 id="HTML-기초"><a href="#HTML-기초" class="headerlink" title="HTML 기초"></a>HTML 기초</h2><h3 id="학습-목표"><a href="#학습-목표" class="headerlink" title="학습 목표"></a>학습 목표</h3><ul>
<li>HTML이 무엇일까?</li>
<li>HTML의 구조와 문법</li>
<li>자주 사용되는 HTML 요소가 무엇일까?</li>
<li>id와 class를 목적에 맞게 사용하여 사람과 컴퓨터가 읽기 쉬운 semantic HTML 문서를 작성하자.</li>
<li>시맨틱 요소엔 무엇이 있을까?</li>
<li>시맨틱 요소를 사용하는 이유는 무엇일까?</li>
</ul>
<p>🙋🏻‍♀️ HTML이 뭐야?</p>
<p>: Hyper Text Markup Language의 약자. 웹페이지의 틀을 만드는 마크업 언어이다.</p>
<p>🙋🏻‍♂️ HTML은 어떻게 쓰는거지?</p>
<p>: HTML은 tag들의 집합이다. &lt;&gt;로 묶인 HTML의 기본 구성 요소로 사용한다. 예를 들어 <code>&lt;span&gt;&lt;/span&gt;</code> 과 같이 태그를 열고 닫는 방식으로 사용한다.</p>
<p>🙋🏻‍♂️ 무조건 여는태그와 닫는태그가 쌍으로 있어야 하는건가?</p>
<p>: 무조건은 아니다. img 태그와 같은 경우엔 self-closing tag로 <code>&lt;img /&gt;</code> 처럼 사용할 수 있다.</p>
<p>🙋🏻 자주 사용하는 element로는 어떤 것들이 있을까?</p>
<p>: 자주 사용하는 태그로는 <code>div</code>, <code>span</code>, <code>img</code>, <code>a</code>, <code>ul</code>, <code>ol</code>, <code>li</code>, <code>input</code>, <code>textarea</code>, <code>button</code> 태그가 있다.</p>
<p>textarea 태그는 줄바꿈이 되는 입력폼이다.</p>
<p>🙋🏻‍♂️ 시맨틱 요소란 무엇일까?</p>
<p>: HTML5에서는 시멘틱 웹이 중요시되면서 여러 시맨틱 요소가 새롭게 만들어졌다. semantic이란 ‘의미가 있는’ 이라고 해석할 수 있는데 즉, 의미를 가진 요소를 사용하는 방식을 추구한 것이다.</p>
<p>예를 들어서 문단의 제목을 div 태그를 사용하여 폰트사이즈를 키워서 제목처럼 보이게 만들 수 있지만, h1 태그를 사용하여 heading level 1의 의미를 주는 것과는 다르다.</p>
<p>🙋🏻 시맨틱 요소를 사용해야 하는 이유는 무엇일까?</p>
<p>: 첫 번째로 검색 엔진이 시맨틱 요소를 좋아하기 때문이다. 두 번째로는 개발자가 협업을 할 때 의미가 없는 div 태그를 탐색하는 것보다 의미있는 코드 블록을 찾는 것이 편리하기 때문이다.</p>
<p>🙋🏻 시맨틱 요소의 종류로는 뭐가 있을까?</p>
<p><code>&lt;article&gt;</code></p>
<p>: 독립적이고 자체 포함된 콘텐츠를 지정한다.</p>
<p><code>&lt;aside&gt;</code></p>
<p>: 본문의 주요 부분을 표시하고 남은 부분을 설명하는 요소. 사이드바나 광고창 등 중요하지 않은 부분에 사용된다.</p>
<p><code>&lt;footer&gt;</code></p>
<p>: 일반적으로 페이지나 해당 파트의 <strong>가장 아랫부분</strong>에 위치하며, 사이트의 라이선스, 주소, 연락처 등을 넣을 때 사용한다.</p>
<p><code>&lt;header&gt;</code></p>
<p>: 일반적으로 페이지나 해당 섹션의 <strong>가장 윗부분</strong>에 위치하며, 사이트의 제목이 보통 들어간다.</p>
<p><code>&lt;nav&gt;</code></p>
<p>: 내비게이션(<strong>nav</strong>igation)의 약자로, 일반적으로 상단바 등 사이트를 안내하는 요소에 사용한다.</p>
<p><code>&lt;main&gt;</code></p>
<p>: 문서의 주된 콘텐츠를 표시</p>
<h2 id="HTML-심화"><a href="#HTML-심화" class="headerlink" title="HTML 심화"></a>HTML 심화</h2><h3 id="학습-목표-1"><a href="#학습-목표-1" class="headerlink" title="학습 목표"></a>학습 목표</h3><ul>
<li>웹 앱의 구조 잡기</li>
<li><code>&lt;div&gt;</code> 요소 또는 <code>&lt;section&gt;</code>, <code>&lt;header&gt;</code> 등의 시맨틱 요소로 영역을 구분하는 이유를 이해할 수 있다.</li>
<li>HTML 문서에서 언제 id 혹은 class를 사용해야 하는지 이해할 수 있다.</li>
</ul>
<p>🙋🏻‍♀️ 웹 앱의 구조는 어떻게 잡아야할까?</p>
<p>: 댓글창을 생각해보자. 크게 작성하는 영역과 읽기 영역으로 나눠져있다.</p>
<p>🙋🏻‍♂️ 댓글창엔 어떤 태그로 구조를 만들어야할까?</p>
<p><img src="https://github.com/leejaelll/TIL/raw/main/TIL/image/230214-01.png"></p>
<p><img src="https://github.com/leejaelll/TIL/raw/main/TIL/image/230214-02.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>댓글<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;댓글을 입력해주세요&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>🙋🏻‍♀️ 읽기 영역은 어떤 구조로 잡아야할까?</p>
<p><img src="https://github.com/leejaelll/TIL/raw/main/TIL/image/230214-03.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>ouo***<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>댓글...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>2018-03-22 23:29:22<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>👍🏻<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>👎🏻<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>cake***<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>댓글...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>2018-03-22 23:29:22<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>👍🏻<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>&gt;</span>👎🏻<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>💬 id 및 class를 목적에 맞게 사용하자</strong></p>
<p>🙋🏻‍♀️ id는 언제 쓰고 class는 언제 써야할까?</p>
<ul>
<li>id: 고유한 이름을 붙일 때 사용한다.</li>
<li>class: 반복되는 영역을 유형별로 분류할 때 사용한다.</li>
</ul>
<table>
<thead>
<tr>
<th>HTML 태그</th>
<th>Selector</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;div id=”writing-seciton”&gt;</code></td>
<td>div#writing-section</td>
</tr>
<tr>
<td><code>&lt;li class=”comment”&gt;</code></td>
<td>li.comment</td>
</tr>
</tbody></table>
<p>반복되는 영역은? 👉🏻 <strong>class</strong>를 사용하자.</p>
<p>🙋🏻‍♀️ id를 사용하지 않은 이유는?</p>
<p>: id는 고유한 이름을 붙일 때 사용한다. id를 사용하게 되면 모든 영역이 고유해야한다.</p>
<p><img src="https://github.com/leejaelll/TIL/raw/main/TIL/image/230214-04.png"></p>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 기초 정리하기</title>
    <url>/2023/230215-archive/</url>
    <content><![CDATA[<h2 id="CSS-기초"><a href="#CSS-기초" class="headerlink" title="CSS 기초"></a>CSS 기초</h2><h3 id="학습-목표"><a href="#학습-목표" class="headerlink" title="학습 목표"></a>학습 목표</h3><ul>
<li>CSS의 사용 목적을 이해한다.</li>
<li>CSS의 기본 문법과 구조를 이해한다.</li>
<li>CSS를 HTML에 적용하는 방법에 대해서 이해한다.</li>
<li>HTML 안에 CSS를 직접 정의하는 것을 권장하지 않는 이유를 이해한다.</li>
<li>CSS를 이용해 텍스트를 꾸밀 수 있다.</li>
<li>CSS에서 쓰이는 단위의 두 가지 구분을 이해한다.<ul>
<li>각 단위가 적합한 경우를 구분할 수 있다.</li>
</ul>
</li>
<li>MDN 또는 W3School 등의 레퍼런스 사이트를 이용해 CSS 속성을 검색하고 사용할 수 있다.</li>
</ul>
<h3 id="🙋🏻‍♂️-CSS가-뭐야"><a href="#🙋🏻‍♂️-CSS가-뭐야" class="headerlink" title="🙋🏻‍♂️ CSS가 뭐야?"></a>🙋🏻‍♂️ CSS가 뭐야?</h3><p>: Cascading Style Sheets로 웹 페이지 스타일 및 레이아웃을 정의하는 스타일 시트이다.</p>
<p>🙋🏻 CSS로 개발자는 무엇을 만드는거지?</p>
<p>: 웹 애플리케이션에 접근할 수 있는 사용자 인터페이스부터 만든다.</p>
<p>🙋🏻‍♂️ 사용자 인터페이스는 무엇을 말하는거지?</p>
<p>: 사용자 인터페이스에 대해서 설명하기 전 인터페이스에 대해서 알아보자.</p>
<blockquote>
<p>인터페이스는 컴퓨터와 교류하기 위한 연결고리이다. 마우스도 없던 시대의 개발자는 자신이 만든 애플리케이션과 소통하기 위해 CLI를 사용했다. 키보드로 작성한 비밀 암호같은 코드를 적어서 엔터를 눌러야만 애플리케이션을 작동시킬 수 있었다.</p>
<p><img src="/../img/230215/230215-01.png" alt="230215-01.png"></p>
</blockquote>
<p>요즘엔 메세지를 보낼 때 키보드 인터페이스로 입력하고 버튼 모양의 인터페이스를 누르면 메세지가 전송이 된다. 이렇게 일반 사용자가 쉽게 사용할 수 있는 인터페이스에는 앞에 사용자를 붙여 사용자 인터페이스, UI라고 부른다.</p>
<h3 id="💬-페이지-만들어보기"><a href="#💬-페이지-만들어보기" class="headerlink" title="💬 페이지 만들어보기"></a>💬 페이지 만들어보기</h3><p><img src="/../img/230215/230215-02.png" alt="230215-01.png"></p>
<p>🙋🏻‍♀️ HTML 구조는 어떻게 잡아야할까?</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- header --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>This is the header.<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- nav --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span>&gt;</span>This is the navigation section.<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>Mac<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>iPhone<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>iPad<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- main --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is the main content.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- aside --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span>&gt;</span>This is an aside section.<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- footer --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>개인정보 처리방침<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>이용 약관<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>법적 고지<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>💬 index.css에 코드를 넣고 차이점을 확인해보자</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#4a4a4a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: large;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#4a4a4a</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f9f9f9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f9f9f9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/230215/230215-03.png" alt="230215-03.png"></p>
<h3 id="CSS-문법-이해하기"><a href="#CSS-문법-이해하기" class="headerlink" title="CSS 문법 이해하기"></a>CSS 문법 이해하기</h3><p><img src="/../img/230215/230215-04.png" alt="230215-04.png"></p>
<p>셀렉터는 요소 이름이나 id, 또는 클래스를 선택한다.</p>
<p>셀렉터로 특정 요소를 선택했다면? 👉🏻 중괄호 안에서 이 요소에 적용할 내용을 작성한다.</p>
<p>요소에 적용할 수 있는 내용을 <strong>속성</strong>이라고 한다. 색상, 글자 크기 등 다양한 속성이 있으며, 속성에 적용할 적절한 값을 입력하여 스타일을 표현합니다.</p>
<p>그림에 나타나 있는 <code>color: red;</code>는 이 요소의 색상을 빨간색으로 스타일링한다. 속성과 값의 끝에는 세미콜론(<code>;</code>)을 붙여 속성끼리 구분한다.</p>
<p>🙋🏻‍♀️ 텍스트의 가운데 정렬을 하기 위한 속성은?</p>
<p>: <code>text-align: center</code></p>
<p>🙋🏻‍♂️ 글자 색을 바꾸기 위한 속성은?</p>
<p>: <code>color</code></p>
<p>🙋🏻‍♂️ 배경 색을 바꾸기 위한 속성은?</p>
<p>: <code>background-color</code></p>
<p>🙋🏻 <code>background</code> 속성과 <code>background-color</code> 속성의 차이점은?</p>
<p>: <code>background</code>는 색상, 이미지, 원점, 크기, 반복 등 여러 배경 스타일을 한 번에 지정할 수 있다. background는 단축 속성으로서 하위 속성으로 background-color를 포함하고 있다.</p>
<p>🙋🏻‍♀️ em의 의미는 무엇인가?</p>
<p>: CSS에서 사용하는 상대 길이 단위이다. <strong>상대 길이 단위</strong>는 상위요소의 글꼴 크기 또는 viewprot 크기와 관련이 있다.</p>
<p>상대 단위를 사용하면? 👉🏻 텍스트나 다른 요소의 크기가 페이지의 다른 모든 것에 비례하여 조정되도록 신중하게 계획할 수 있다는 이점이 있다.</p>
<p>💬 각각의 div가 어떤 형태로 나타날 지 예측해보자.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;box px&quot;&gt;<span class="selector-tag">I</span> am <span class="number">200px</span> wide&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;box vw&quot;&gt;<span class="selector-tag">I</span> am <span class="number">10vw</span> wide&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;box <span class="selector-tag">em</span>&quot;&gt;<span class="selector-tag">I</span> am <span class="number">10em</span> wide&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.px</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.vw</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.em</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3개의 div를 감싸고 있는 wrapper에 <code>font-size: 1em;</code> 를 적용했다. 즉, 부모 요소의 폰트 크기의 1배 사이즈로 설정한 것과 동일하다.</p>
<p><code>div.box px</code> 👉🏻 200px 이라는 절대 단위를 사용했기 때문에 상위 요소의 영향을 받지 않고 width: 200px의 크기를 가진 div로 나타난다.</p>
<p><code>div.box vw</code> 👉🏻 vw는 viewport 너비 단위로 설정된다. 이 값은 viewport 너비를 기준으로 하므로 10vw는 viewport 너비의 10%이다. 브라우저 창의 너비를 변경하면 박스의 크기가 변경될 것이다.</p>
<p><code>div.box em</code> 👉🏻 em은 글꼴 크기에 상대적이다. <code>.wrapper</code>의 font-size가 부모요소(현재 root) 글꼴 크기이므로 width는 글꼴 크기의 10배이다.</p>
<h3 id="💬-단위에-대해서-알아보기"><a href="#💬-단위에-대해서-알아보기" class="headerlink" title="💬 단위에 대해서 알아보기"></a>💬 단위에 대해서 알아보기</h3><p><strong>글꼴 사이즈를 정할 때</strong></p>
<dl><dt>🔨 <strong>기기나 브라우저 사이즈 등의 환경에 영향을 받지 않는 절대적인 크기로 정하는 경우</strong></dt><dd><code>px</code>(픽셀)을 사용. 픽셀은 크기가 고정된 절대 단위이기 때문에 사용자 접근성이 불리하다.</dd></dl><p>글꼴의 크기를 픽셀로 설정하면, 작은 글씨를 보기 힘든 사용자가 브라우저의 기본 글꼴 크기를 더 크게 설정하더라도 글꼴의 크기는 항상 설정된 픽셀로 고정된다.</p>
<p>개발자가 제목(heading)을 강조하기 위해 픽셀을 이용해 글꼴의 크기를 지정했으나 사용자의 환경에 따라 일반 텍스트보다 작게 보이는 결과를 초래할 수 있다. 그리고 픽셀은 모바일 기기처럼 작은 화면이면서, 동시에 고해상도인 경우에도 적합하지 않다.</p>
<p>기본적으로 고해상도에서는 1px이 모니터의 한 점보다 크게 업스케일(upscale) 되기 때문에, 뚜렷하지 못한 형태로 출력되는 경우도 있다.</p>
<dl><dt><strong>🔨 일반적인 경우</strong></dt><dd>상대 단위인 <code>rem</code>을 사용한다. <strong>root의 글자 크기</strong>, 즉 브라우저의 기본 글자 크기가 1rem이며, 두 배로 크게 하고 싶다면 2rem, 작게 하려면 0.8rem 등으로 조절해서 사용할 수 있다.</dd></dl><p>이는 사용자가 설정한 기본 글꼴 크기를 따르므로, <strong>접근성에 유리</strong>하다. (<code>em</code>은 부모 엘리먼트에 따라 상대적으로 크기가 변경되므로 계산이 어렵지만 <code>rem</code>은 root의 글자 크기에 따라서만 상대적으로 변합니다.)</p>
<p><strong>화면 사이즈를 정할 때</strong></p>
<p><strong>✍🏻  반응형 웹(responsive web)에서 기준점을 만들 때</strong></p>
<p>: 데스크탑에서 볼 때, 스마트폰에서 세로 모드로 볼 때, 가로 모드로 볼 때, 태블릿으로 볼 때가 각각 달라야한다. 이 때에는 디바이스 크기별로 CSS를 달리 적용해야 한다.</p>
<p>이때, 디바이스 크기를 나누는 기준은 보통 <code>px</code>로 정한다.</p>
<p><strong>✍🏻 화면 너비나 높이에 따른 상대적인 크기가 중요한 경우</strong></p>
<p>: 이때에는 <code>vw</code>, <code>vh</code>를 사용한다.</p>
<hr>
<h2 id="박스-모델-기초"><a href="#박스-모델-기초" class="headerlink" title="박스 모델 기초"></a>박스 모델 기초</h2><h3 id="학습-목표-1"><a href="#학습-목표-1" class="headerlink" title="학습 목표"></a>학습 목표</h3><ul>
<li>CSS 박스 모델을 이해할 수 있다.</li>
<li>박스를 구성하는 네 가지 요소를 구분하고 각각에 대해 설명할 수 있다.<ul>
<li>margin, border, padding, content</li>
</ul>
</li>
<li>박스 크기를 측정하는 두 가지 기준의 차이를 이해할 수 있다.</li>
</ul>
<h3 id="💬-모든-콘텐츠는-고유한-영역이-있다"><a href="#💬-모든-콘텐츠는-고유한-영역이-있다" class="headerlink" title="💬 모든 콘텐츠는 고유한 영역이 있다."></a>💬 모든 콘텐츠는 고유한 영역이 있다.</h3><p><img src="/../img/230215/230215-05.png" alt="230215-05.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Basic document flow<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I am a basic block level element. My adjacent block level elements sit on new lines below me.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  By default we span 100% of the width of our parent element, and we are as tall as our child content. Our total width</span><br><span class="line">  and height is our content + padding + border width/height.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins,</span><br><span class="line">  not both.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  inline elements <span class="tag">&lt;<span class="name">span</span>&gt;</span>like this one<span class="tag">&lt;/<span class="name">span</span>&gt;</span> and <span class="tag">&lt;<span class="name">span</span>&gt;</span>this one<span class="tag">&lt;/<span class="name">span</span>&gt;</span> sit on the same line as one another, and adjacent</span><br><span class="line">  text nodes, if there is space on the same line. Overflowing inline elements will</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>wrap onto a new line if possible (like this one containing text)<span class="tag">&lt;/<span class="name">span</span>&gt;</span>, or just go on to a new line if not</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">84</span>, <span class="number">104</span>, <span class="number">0.3</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🙋🏻 위 HTML에서 줄 바꿈이 적용되는 요소는 무엇일까?</p>
<p>: 줄 바꿈이 적용되는 요소로는 h1, p 태그가 있다.</p>
<p>🙋🏻 위 CSS 코드에서 실제로 작동하지 않는 것이 존재한다. 무엇일까?</p>
<p>: span에 width, height 속성을 주었지만, 작동하지 않는다. span은 inline 요소로서 width, height를 가지지 않고 컨텐츠 크기만큼만 크기를 가진다.</p>
<h3 id="💬-block-vs-inline-vs-line-block"><a href="#💬-block-vs-inline-vs-line-block" class="headerlink" title="💬 block vs. inline vs. line-block"></a>💬 block vs. inline vs. line-block</h3><table>
<thead>
<tr>
<th></th>
<th>block</th>
<th>inline</th>
<th>inline-block</th>
</tr>
</thead>
<tbody><tr>
<td>줄 바꿈 여부</td>
<td>O</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>기본적으로 갖는 너비(width)</td>
<td>100%</td>
<td>글자가 차지하는 만큼</td>
<td>글자가 차지하는 만큼</td>
</tr>
<tr>
<td>width, height 사용 가능 여부</td>
<td>가능</td>
<td>가능</td>
<td>불가능</td>
</tr>
</tbody></table>
<h3 id="💬-박스를-구성하는-요소"><a href="#💬-박스를-구성하는-요소" class="headerlink" title="💬 박스를 구성하는 요소"></a>💬 박스를 구성하는 요소</h3><p><img src="/../img/230215/230215-06.png" alt="230215-06.png"></p>
<h3 id="🙋🏻‍♀️-박스를-벗어나는-콘텐츠는-어떻게-처리해야할까"><a href="#🙋🏻‍♀️-박스를-벗어나는-콘텐츠는-어떻게-처리해야할까" class="headerlink" title="🙋🏻‍♀️ 박스를 벗어나는 콘텐츠는 어떻게 처리해야할까?"></a>🙋🏻‍♀️ 박스를 벗어나는 콘텐츠는 어떻게 처리해야할까?</h3><p>박스 크기보다 콘텐츠 크기가 더 큰 경우에는 콘텐츠가 박스 바깥으로 빠져나온다. 이런 경우 박스 크기에 맞게 콘텐츠를 더 이상 표시하지 않거나, 박스 안에 스크롤을 추가하여 콘텐츠를 확인할 수 있게 만든다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>overflow</code> 속성의 <code>auto</code> 값은, 콘텐츠가 넘치는 경우 스크롤을 생성하도록 한다.</p>
<p>🙋🏻‍♂️ 넘치는 내용을 보여주고 싶지 않다면? 👉🏻 <code>overflow: hidden;</code></p>
<h3 id="💬-박스-크기-측정-기준"><a href="#💬-박스-크기-측정-기준" class="headerlink" title="💬 박스 크기 측정 기준"></a>💬 박스 크기 측정 기준</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>안쪽 box<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid green;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🙋🏻‍♀️ 현재 <code>#container</code> 너비는 얼마일까?</p>
<p>: <code>#container</code>의 너비는 300px이 아니라, 324px이다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">300px</span> (콘텐츠 영역)</span><br><span class="line">+ <span class="number">10px</span> (<span class="attribute">padding-left</span>)</span><br><span class="line">+ <span class="number">10px</span> (<span class="attribute">padding-right</span>)</span><br><span class="line">+ <span class="number">2px</span> (<span class="attribute">border-left</span>)</span><br><span class="line">+ <span class="number">2px</span> (<span class="attribute">border-right</span>)</span><br></pre></td></tr></table></figure>

<p>🙋🏻‍♂️ 이런 현상이 발생하는 이유는 무엇일까?</p>
<p>: 박스의 크기를 측정하는 기본 값이 <code>content-box</code> 이기 때문이다. content-box는 border와 padding을 고려하지 않고 박스 크기를 결정한다.</p>
<p>🙋🏻‍♂️ 이를 해결하기 위한 방법은 뭐가 있을까?</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/230215/230215-07.png" alt="230215-07.png"></p>
<hr>
<h2 id="CSS-Selector"><a href="#CSS-Selector" class="headerlink" title="CSS Selector"></a>CSS Selector</h2><h3 id="학습-목표-2"><a href="#학습-목표-2" class="headerlink" title="학습 목표"></a>학습 목표</h3><ul>
<li>다양한 CSS selector 규칙을 이해한다.</li>
<li>후손 selector와 자식 selector의 차이를 이해한다.</li>
<li>필요시 검색을 통해 필요한 selector를 찾아 적용할 수 있다.</li>
</ul>
<h3 id="💬-attribute-셀렉터"><a href="#💬-attribute-셀렉터" class="headerlink" title="💬 attribute 셀렉터"></a>💬 <strong>attribute 셀렉터</strong></h3><p>attribute 셀렉터는 같은 속성을 가진 요소를 선택</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[id=<span class="string">&#x27;only&#x27;</span>]</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~=<span class="string">&#x27;out&#x27;</span>]</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class|=<span class="string">&#x27;out&#x27;</span>]</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span><span class="selector-attr">[id^=<span class="string">&#x27;sect&#x27;</span>]</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class$=<span class="string">&#x27;2&#x27;</span>]</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class*=<span class="string">&#x27;w&#x27;</span>]</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="💬-자식-셀렉터"><a href="#💬-자식-셀렉터" class="headerlink" title="💬 자식 셀렉터"></a>💬 <strong>자식 셀렉터</strong></h3><p>자식 셀렉터는 첫 번째로 입력한 요소의 바로 아래 자식인 요소를 선택</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 경우 <code>&lt;header&gt;</code> 요소 바로 아래에 있는 두 개의 <code>&lt;p&gt;</code> 요소는 선택되지만, <code>&lt;span&gt;</code> 요소의 자식인 <code>&lt;p&gt;</code> 요소는 선택되지 않는다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="💬-후손-셀렉터"><a href="#💬-후손-셀렉터" class="headerlink" title="💬 후손 셀렉터"></a>💬 <strong>후손 셀렉터</strong></h3><p>후손 셀렉터는 첫 번째로 입력한 요소의 후손을 선택</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 경우 <code>&lt;header&gt;</code> 요소의 자식인 <code>&lt;p&gt;</code> 요소뿐 아니라, <code>&lt;header&gt;</code> 요소의 자식의 자식인 <code>&lt;p&gt;</code> 요소까지 모두 선택된다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- !!선택!! --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="comment">&lt;!-- !!선택!! --&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="💬-형제-셀렉터"><a href="#💬-형제-셀렉터" class="headerlink" title="💬 형제 셀렉터"></a>💬 형제 <strong>셀렉터</strong></h3><p>부모 요소를 공유하면서, 첫 번째 입력한 요소 뒤에 오는 두 번째 입력한 요소를 모두 선택</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> ~ <span class="selector-tag">p</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="💬-인접-형제-셀렉터"><a href="#💬-인접-형제-셀렉터" class="headerlink" title="💬 인접 형제 셀렉터"></a>💬 인접 형제 <strong>셀렉터</strong></h3><p>같은 부모 요소를 공유하면서, 첫 번째 입력한 요소 바로 뒤에 오는 두 번째 입력한 요소를 선택</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 선택 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="💬-가상-클래스-셀렉터"><a href="#💬-가상-클래스-셀렉터" class="headerlink" title="💬 가상 클래스 셀렉터"></a>💬 가상 클래스 <strong>셀렉터</strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">&#125; <span class="comment">/*사용자가 방문하지 않은 &lt;a&gt;요소를 선택합니다.*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">&#125; <span class="comment">/*사용자가 방문한 &lt;a&gt;요소를 선택합니다. */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* 마우스를 요소 위에 올렸을 때 선택합니다. */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* 활성화 된(클릭된) 상태일 때 선택합니다. */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">&#125; <span class="comment">/* 포커스가 들어와 있을 때 선택합니다. */</span></span><br></pre></td></tr></table></figure>

<h3 id="💬-UI-요소-상태-셀렉터"><a href="#💬-UI-요소-상태-셀렉터" class="headerlink" title="💬 UI 요소 상태 셀렉터"></a>💬 UI 요소 상태 <strong>셀렉터</strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">span</span> &#123;</span><br><span class="line">&#125; <span class="comment">/*체크 상태일 때 선택합니다. */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:enabled</span> + <span class="selector-tag">span</span> &#123;</span><br><span class="line">&#125; <span class="comment">/*사용 가능한 상태일 때 선택합니다. */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:disabled</span> + <span class="selector-tag">span</span> &#123;</span><br><span class="line">&#125; <span class="comment">/*사용 불가능한 상태일 때 선택합니다. */</span></span><br></pre></td></tr></table></figure>

<h3 id="💬-구조-가상-클래스-셀렉터"><a href="#💬-구조-가상-클래스-셀렉터" class="headerlink" title="💬 구조 가상 클래스 셀렉터"></a>💬 구조 가상 클래스 <strong>셀렉터</strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>n + <span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &gt; <span class="selector-tag">p</span><span class="selector-pseudo">:nth-last-child</span>(<span class="number">2</span>n + <span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-of-type &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:last-of-type</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-last-of-type</span>(<span class="number">1</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="💬-부정-셀렉터"><a href="#💬-부정-셀렉터" class="headerlink" title="💬 부정 셀렉터"></a>💬 부정 셀렉터</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not</span>(<span class="selector-attr">[type=<span class="string">&#x27;password&#x27;</span>]</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="💬-적합성-확인-셀렉터"><a href="#💬-적합성-확인-셀렉터" class="headerlink" title="💬 적합성 확인 셀렉터"></a>💬 적합성 확인 셀렉터</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&#x27;text&#x27;</span>]</span><span class="selector-pseudo">:valid</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&#x27;text&#x27;</span>]</span><span class="selector-pseudo">:invalid</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Layout - Flexbox 이해하기</title>
    <url>/2023/230216-archive/</url>
    <content><![CDATA[<p>부모 요소엔 Flexbox 속성을 잘 적용하지만 자식 요소에 적용할 수 있는 Flexbox 속성은 익숙치 않아서 정리해보았다.</p>
<h3 id="💬-자식-요소에-적용해야-하는-Flexbox-속성"><a href="#💬-자식-요소에-적용해야-하는-Flexbox-속성" class="headerlink" title="💬 자식 요소에 적용해야 하는 Flexbox 속성"></a>💬 <strong>자식 요소에 적용해야 하는 Flexbox 속성</strong></h3><blockquote>
<p><em>부모 요소에 적용해야 하는 속성들이 자식 요소들의 <strong>정렬</strong>과 관련이 있었다면, 자식 요소에게 적용해야 하는 속성인 <code>flex</code> 는 요소가 <strong>차지하는 공간</strong>과 관련이 있다.</em></p>
</blockquote>
<p><strong>flex 속성의 값</strong></p>
<p>: flex 속성에는 세 가지 값을 지정해줄 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>: &lt;<span class="built_in">grow</span>(팽창 지수) &gt; &lt;<span class="built_in">shrink</span>(수축 지수) &gt; &lt;<span class="built_in">basis</span>(기본 크기) &gt;;</span><br></pre></td></tr></table></figure>

<p><code>grow(팽창 지수)</code> 👉🏻 요소의 크기가 <strong>늘어나야 할 때</strong> 얼마나 늘어날 것인지</p>
<p><code>shrink(수축 지수)</code> 👉🏻 요소의 크기가 <strong>줄어들어야 할 때</strong> 얼마나 줄어들 것인지</p>
<p><code>basis(기본 크기)</code> 👉🏻 <strong>늘어나고 줄어드는 것과 상관없이</strong> 요소의 기본 크기는 얼마인지</p>
<p>🙋🏻‍♀️ 자식 요소에 <code>flex</code> 속성을 따로 설정해주지 않으면?</p>
<p>: <strong>기본값</strong>이 적용되며, 왼쪽에서부터 오른쪽으로 콘텐츠의 크기만큼 배치된다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex</span>: <span class="number">0</span> <span class="number">1</span> auto; //<span class="attribute">flex</span>: grow shrink basis</span><br></pre></td></tr></table></figure>

<p>꼭 <code>flex</code> 속성 안에 세 가지 값을 한 번에 설정해줄 필요 없이, 다음과 같이 각 값을 따로 지정해줄 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-grow</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">flex-shrink</span>: <span class="number">1</span>;</span><br><span class="line"><span class="attribute">flex-basis</span>: auto;</span><br></pre></td></tr></table></figure>

<p>💬 <strong>grow : 자식 박스는 얼마나 늘어날 수 있을까?</strong></p>
<p><code>grow(팽창 지수)</code> 는 요소의 크기가 늘어나야 할 때 <strong>얼마나 늘어날 것인지</strong>를 의미한다고 했다.</p>
<p>어떤 의미인지 알아보기 위해서 챕터 2-1에서 사용했던 HTML에서 자식 <code>&lt;div&gt;</code> 요소들에 id를 추가해서 <code>grow</code>값을 변경하며 변화를 확인해보자.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>box1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>box2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>box3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>flex</code> 속성을 설정하기 전의 모습</p>
<p><img src="/../img/230216/230216-01.png" alt="230216-01.png"></p>
<p>👉🏻 <code>grow</code>의 기본 값인 0은 빈 공간이 있어도 늘어나지 않음을 의미한다.</p>
<p>따라서 빈 공간이 있음에도 박스들이 늘어나지 않는다.</p>
<p>🙋🏻‍♂️ box1만 <code>flex-grow : 1</code>로 설정하면?</p>
<p><img src="/../img/230216/230216-02.png" alt="230216-02.png"></p>
<p>🙋🏻‍♀️ box2도 <code>flex-grow : 1</code>로 설정하면?</p>
<p><img src="/../img/230216/230216-03.png" alt="230216-03.png"></p>
<p>🙋🏻‍♀️ box3도 <code>flex-grow : 1</code>로 설정하면?</p>
<p><img src="/../img/230216/230216-04.png" alt="230216-04.png"></p>
<h3 id="grow-팽창-지수-는-정렬축-방향으로-빈-공간이-있을-때"><a href="#grow-팽창-지수-는-정렬축-방향으로-빈-공간이-있을-때" class="headerlink" title="grow(팽창 지수)는 정렬축 방향으로 빈 공간이 있을 때,"></a><code>grow(팽창 지수)</code>는 정렬축 방향으로 빈 공간이 있을 때,</h3><p>각 자식 요소들이 얼마나 늘어나서 남는 공간을 차지할 것인지 비율을 정하는 것</p>
<aside>
💡 1. grow는 box1 : box2 : box3 = 1 : 0 : 0 이므로 box1이 모든 공간을 차지
2. grow는 box1 : box2 : box3 = 1 : 1 : 0 이므로 box1과 box2가 1:1로 공간을 나눠가짐
3. grow는 box1 : box2 : box3 = 1 : 1 : 1 이므로 세 박스가 1:1:1로 공간을 나눠가짐

</aside>

<p>💬 <strong>shrink : 자식 박스는 얼마나 줄어들 수 있을까?</strong></p>
<p><code>shrink(수축 지수)</code>는 grow와 반대로, 설정한 비율만큼 박스 크기가 작아진다.</p>
<p><strong>비율이 클수록 더 많이 줄어드는 것.</strong></p>
<blockquote>
<p>💡 <code>flex-grow</code> 속성과 <code>flex-shrink</code> 속성을 함께 사용하는 일은 추천하지 않는다.</p>
</blockquote>
<p>비율로 레이아웃을 지정할 경우 <code>flex-grow</code> 속성 또는 <code>flex: &lt;grow&gt; 1 auto</code>와 같이 <code>grow</code> 속성에 변화를 주는 방식을 권장한다.<br><code>flex-shrink</code> 속성은 <code>width</code> 나 이후 설명할 <code>flex-basis</code> 속성에 따른 비율이므로 실제 크기를 예측하기가 어렵기 때문이다. <strong><code>flex-grow</code> 속성으로 비율을 변경하는 경우, <code>flex-shrink</code> 속성은 기본값인 1로 두어도 무방하다.</strong></p>
<blockquote>
</blockquote>
<p>💬 <strong>basis : 이 박스의 기본 크기는 얼마일까?</strong></p>
<p><code>basis(기본 크기)</code>는 자식 박스가 <code>flex-grow</code>나 <code>flex-shrink</code> 에 의해 늘어나거나 줄어들기 전에 가지는 기본 크기이다.</p>
<p><code>flex-grow</code>가 0일 때, <code>basis</code> 크기를 지정하면 그 크기는 유지된다.</p>
<p>🙋🏻‍♀️ <code>grow</code> 는 0 : 1 : 1 로 설정하고, box1에 <code>flex-basis : 50px</code> 로 설정하면?</p>
<p>: box1의 크기가 늘어나거나 줄어들지 않고 50픽셀을 유지한다.</p>
<p>💬 세 개의 박스 모두 <code>flex-grow : 1</code> 일 때, 위 예시는 <code>flex-basis : auto</code>, 아래 예시는 <code>flex-basis : 0</code> 으로 설정하였다. 두 예시 중 실제로 1 : 1 : 1 의 너비를 갖는 것은 어느 예시인가?</p>
<p><img src="/../img/230216/230216-05.png" alt="230216-05.png"></p>
<p>👉🏻 <code>flex-basis:0</code>으로 설정한 예시가 실제로 1 : 1 : 1의 너비를 갖는다.</p>
<p>🙋🏻 왜 이런 차이가 발생할까?</p>
<p>: flex-basis를 auto로 지정된 경우 컨텐츠 사이즈에 맞춰서 나타나기 때문이다.</p>
<h3 id="flex-grow-속성의-값이-0인-경우에만-flex-basis-속성의-값이-유지된다"><a href="#flex-grow-속성의-값이-0인-경우에만-flex-basis-속성의-값이-유지된다" class="headerlink" title="flex-grow 속성의 값이 0인 경우에만 flex-basis 속성의 값이 유지된다."></a><code>flex-grow</code> 속성의 값이 0인 경우에만 <code>flex-basis</code> 속성의 값이 유지된다.</h3><p>: <code>diplay</code> 속성에 <code>flex</code> 가 적용된 컨테이너 내부에 존재하는 자식 박스는 경우에 따라, <strong><code>basis</code> 로 설정된 크기가 항상 유지되는 것은 아니다.</strong> <code>flex-grow</code> 속성의 값이 양수일 경우, 늘어나면서 <code>flex-basis</code> 속성에 적용한 값보다 커질 수도 있다.</p>
<ul>
<li><code>width</code>와 <code>flex-basis</code>를 동시에 적용하는 경우, <code>flex-basis</code>가 우선된다.</li>
<li>콘텐츠가 많아 자식 박스가 넘치는 경우, <code>width</code>가 정확한 크기를 보장하지 않는다.</li>
<li>(<code>flex-basis</code>를 사용하지 않는다면) 콘텐츠가 많아 자식 박스가 넘치는 경우를 대비해, <code>width</code> 대신 <code>max-width</code>를 쓸 수 있다.</li>
</ul>
<p><strong>💬 Flexbox를 이용해 레이아웃 만들어보기</strong></p>
<p><img src="/../img/230216/230216-06.png" alt="230216-06.png"></p>
<ul>
<li><p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;ko-KR&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;column1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span>&gt;</span>아이콘1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span>&gt;</span>아이콘2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;icon&quot;</span>&gt;</span>아이콘3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;column2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;area&quot;</span>&gt;</span>영역1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;area&quot;</span>&gt;</span>영역2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;area&quot;</span>&gt;</span>영역3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;column3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;area&quot;</span>&gt;</span>영역4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;area&quot;</span>&gt;</span>영역5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>index.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column1</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column2</span>,</span><br><span class="line"><span class="selector-class">.column3</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column2</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column3</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> dotted red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.area</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> dotted blue;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 1주차 주간회고</title>
    <url>/2023/230217-archive/</url>
    <content><![CDATA[<p>벌써 수업이 1주차가 끝났다니..😱 한 주동안 어떻게 공부했는지에 대해서 회고를 작성하려 한다.</p>
<h2 id="주간-회고"><a href="#주간-회고" class="headerlink" title="주간 회고"></a>주간 회고</h2><h3 id="1주차엔-뭘-배웠지"><a href="#1주차엔-뭘-배웠지" class="headerlink" title="1주차엔 뭘 배웠지?"></a>1주차엔 뭘 배웠지?</h3><p>1주차에는 HTML과 CSS에 대해서 학습했다. 이미 알던 내용이라고 해서 대충 넘어가는 것이 아니라 내가 확실하게 알고 있는 것인가에 대해서 한 번씩 더 체크하고 넘어가는 과정이었다.</p>
<p>Section1 파트의 강사님이신 운도님께서 이후 과정에선 CSS를 자세히 살펴볼 기회가 많지 않으니 이때 많이 학습해놓는 것이 좋다고 말씀해주셨는데 정말 공감이 가는 말이었다. 왜냐하면 자바스크립트를 배우게 되는 순간, 헤어 나올 수 없는 늪에 빠지는 느낌이 들기 때문이다.</p>
<h3 id="잘한-점은-무엇이-있을까"><a href="#잘한-점은-무엇이-있을까" class="headerlink" title="잘한 점은 무엇이 있을까?"></a>잘한 점은 무엇이 있을까?</h3><ol>
<li>수업이 있는 9시부터 6시까지는 딴 짓하지 않고 집중해서 공부했다.</li>
<li>자바스크립트로 계산기로 만들기 위해 로직을 먼저 구상해보았다. 이후에 진행되는 과정이지만, 스스로 먼저 어떻게 구현할 수 있을지 생각해보는 것이 내 성장에 도움이 된다고 생각했다.</li>
</ol>
<h3 id="아쉬운-점은-무엇이-있을까"><a href="#아쉬운-점은-무엇이-있을까" class="headerlink" title="아쉬운 점은 무엇이 있을까?"></a>아쉬운 점은 무엇이 있을까?</h3><p>코드스테이츠 수업에서 조금 아쉬운 부분이라면 실시간 세션이 너무 짧다는 것이다. 오전에 수업자료로 우선 각자 공부하고 1-2시간 정도 라이브 강의에서 배운 내용을 복습하는데 처음 마크업을 배우는 사람 입장에서는 조금 어렵지 않을까라는 생각이 들었다.</p>
<p>스스로에게 아쉬운 점은 수업이 있는 시간 외에 따로 공부한 시간이 거의 없다는 것이다. 6시 이후로 공부하는 게 쉽지 않지만 누구보다 열정적으로 공부해야하는 걸 알기에 다음주엔 더 열심히 해야겠다 다짐했다.</p>
<h3 id="✅-다음-주에-해야-할-것들"><a href="#✅-다음-주에-해야-할-것들" class="headerlink" title="✅ 다음 주에 해야 할 것들"></a>✅ 다음 주에 해야 할 것들</h3><ul>
<li><input disabled="" type="checkbox"> 코드스테이츠 과정에 맞춰 자바스크립트 Deep Dive 개념 다시 복습하기. (잊지말자, 다른 사람에 설명할 수 있어야 내 것이 된 것이다✍🏻)</li>
<li><input disabled="" type="checkbox"> 계산기 기능 코드로 작성해보기</li>
<li><input disabled="" type="checkbox"> 리액트 공식문서 공부하기</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>[JavaScript] 변수(Variable)란?</title>
    <url>/2023/230220-archive/</url>
    <content><![CDATA[<p>변수와 데이터 타입에 대해서 배우는 시간이었는데, 변수에 대해서 조금 더 자세히 정리해보는 시간을 가졌다.</p>
<h2 id="🙋🏻‍♂️-변수란-무엇일까"><a href="#🙋🏻‍♂️-변수란-무엇일까" class="headerlink" title="🙋🏻‍♂️ 변수란 무엇일까?"></a>🙋🏻‍♂️ 변수란 무엇일까?</h2><p>: 변수란 <strong>값을 메모리에 저장하기 위해 확보한 메모리 공간</strong> 또는 <strong>어떠한 값을 구별해서 식별할 수 있는 고유한 이름</strong>을 의미한다.</p>
<p>즉, 값은 메모리 공간에 저장되어있다. 따라서 변수는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 한다.</p>
<h3 id="변수-이름을-식별자라고도-한다-식별자는-어떤-값을-구별해서-식별할-수-있는-고유한-이름을-말한다"><a href="#변수-이름을-식별자라고도-한다-식별자는-어떤-값을-구별해서-식별할-수-있는-고유한-이름을-말한다" class="headerlink" title="변수 이름을 식별자라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다."></a><strong><em>변수 이름을 식별자라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.</em></strong></h3><p>이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억해야 한다.</p>
<p>식별자는 <strong>메모리 주소에 붙인 이름</strong>이라고 할 수 있다.</p>
<h2 id="🙋🏻‍♀️-변수를-사용해야하는-이유는"><a href="#🙋🏻‍♀️-변수를-사용해야하는-이유는" class="headerlink" title="🙋🏻‍♀️ 변수를 사용해야하는 이유는?"></a>🙋🏻‍♀️ 변수를 사용해야하는 이유는?</h2><p>: <strong>재사용성</strong>을 위해서 변수를 사용한다.</p>
<p>예를 들면, 10 + 20을 더한 값을 다른 곳에서 사용하고 싶을 때 30이라는 평가된 값을 변수에 저장한 후 다른 곳에서도 사용하고 싶을 수 있다.</p>
<p>만약 연산 결과 30을 재사용하고 싶은데 변수라는 개념이 없었다면, 메모리 주소를 통해 연산 결과 30이 저장된 메모리 공간에 직접 접근하는 것 외에는 방법이 없다.</p>
<h2 id="💬-변수의-선언과-할당을-구분해서-생각하자"><a href="#💬-변수의-선언과-할당을-구분해서-생각하자" class="headerlink" title="💬 변수의 선언과 할당을 구분해서 생각하자."></a>💬 변수의 선언과 할당을 구분해서 생각하자.</h2><h3 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h3><p>: 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있도록 준비하는 것이다.</p>
<p>변수를 선언하게되면, 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호된다.</p>
<p><strong>변수를 선언하는 방법</strong><br> : var, let, const와 같은 키워드를 사용한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> course;</span><br></pre></td></tr></table></figure>

<p>변수를 선언하였지만, 아직 값을 할당하지 않았다. 이 상태에선 메모리 공간이 비어있는 것일까? 👉🏻 비어있을 것이라고 생각할 수 있지만, 메모리 공간에는 undefined라는 값이 암묵적으로 할당되어 초기화된다.</p>
<h2 id="🙋🏻‍♀️-변수-호이스팅이란"><a href="#🙋🏻‍♀️-변수-호이스팅이란" class="headerlink" title="🙋🏻‍♀️ 변수 호이스팅이란?"></a>🙋🏻‍♀️ 변수 호이스팅이란?</h2><p>: 변수 호이스팅이란 변수 선언문이 해당 스코프의 선두로 옮겨진 것처럼 동작하는 특성을 말한다.</p>
<p>ES5 이전엔 let, const 키워드가 없었기 때문에 변수를 선언하기 위해선 var 키워드만 사용할 수 있었다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ① undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ② 123</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ③ 456</span></span><br></pre></td></tr></table></figure>

<p>①에서 foo는 아직 선언되지 않았으므로 ReferenceError가 발생할 것을 기대했지만 undefined가 출력된다. 그 이유는 다른 언어와 달리 자바스크립트는 모든 선언문을 <strong>호이스팅</strong> 하기 때문이다.</p>
<h3 id="변수는-3단계에-걸쳐-생성된다"><a href="#변수는-3단계에-걸쳐-생성된다" class="headerlink" title="변수는 3단계에 걸쳐 생성된다."></a>변수는 3단계에 걸쳐 생성된다.</h3><p>선언 단계 ➡️ 초기화 단계 ➡️ 할당 단계</p>
<p><img src="https://poiemaweb.com/img/var-lifecycle.png"></p>
<p>var키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 따라서 변수 선언문 이전에 변수에 접근하여도 등록된 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅이라 한다.</p>
<h3 id="💡-그럼-let-const는-변수-호이스팅이-일어나지-않는걸까"><a href="#💡-그럼-let-const는-변수-호이스팅이-일어나지-않는걸까" class="headerlink" title="💡 그럼 let, const는 변수 호이스팅이 일어나지 않는걸까?"></a>💡 그럼 let, const는 변수 호이스팅이 일어나지 않는걸까?</h3><p><img src="https://velog.velcdn.com/images/kozel/post/aec01fe9-b458-4ca1-9015-cef821d84b2b/image.jpeg"><br>:let, const 키워드는 런타임 이전에 선언단계가 먼저 실행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조에러가 발생한다. 그렇기 때문에 호이스팅이 일어나지 않는다고 생각할 수 있지만, let, const 키워드도 호이스팅 된다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">1</span>; <span class="comment">// 전역 변수</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// 지역 변수</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 호이스팅이 되지 않는다면 <code>console.log(foo)</code>는 1을 출력해야한다. 하지만 호이스팅이 발생하기 떄문에 참조에러가 발생한다.</p>
<h2 id="🙋🏻-우리는-변수를-어떻게-사용해야할까"><a href="#🙋🏻-우리는-변수를-어떻게-사용해야할까" class="headerlink" title="🙋🏻 우리는 변수를 어떻게 사용해야할까?"></a>🙋🏻 우리는 변수를 어떻게 사용해야할까?</h2><p>: 네이밍 규칙을 준수해서 사용해야한다. 변수의 이름을 지을 땐, 자식의 이름을 짓는 것만큼 신중하게 지어야 한다는 말을 들은 적이 있다. 그만큼 변수 네이밍 하나가 프로그래밍에 영향을 미친다는 의미가 아닐까 싶다.</p>
<p>개발을 혼자하면 문제가 없겠지만, 여러 사람이 함께 개발을 하기 때문에 모두가 이해하기 쉬운 변수명을 사용해야 한다. 그렇게 되면 코드 리뷰 시 다른 사람의 소스 코드를 읽고 이해하는데 필요한 비용을 절약할 수 있다.</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>계산기 구현 로직 생각해보기 🔨</title>
    <url>/2023/230221-archive/</url>
    <content><![CDATA[<p>코드스테이츠 2주차 일정을 보니 이틀 뒤에 계산기 기능을 구현하는 시간이 있어 혼자서 미리 생각해보는 시간을 가져보았다.</p>
<h2 id="💬-계산기-기능-분석하기"><a href="#💬-계산기-기능-분석하기" class="headerlink" title="💬 계산기 기능 분석하기"></a>💬 계산기 기능 분석하기</h2><p>계산기에는 어떤 기능들이 있어야 할까?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 숫자는 <span class="number">0</span>부터 시작한다.</span><br><span class="line"><span class="number">2.</span> +/- 버튼을 누르면 숫자가 양수인 경우 -로 변환하고, 음수인 경우 +로 변환한다.</span><br><span class="line"><span class="number">3.</span> % 버튼을 누르면? 👉🏻 숫자를 퍼센트로 변환한다. (<span class="number">0</span>인 경우 무시한다.)</span><br><span class="line"><span class="number">4.</span> 숫자를 입력하면 숫자가 표시되어야 하는 부분이 나타난다.</span><br><span class="line">    a. 숫자를 입력하면 <span class="variable constant_">AC</span> 버튼이 C로 바뀌어야 한다.</span><br><span class="line">    b. C 버튼을 누르면 <span class="number">0</span>으로 초기화한다.</span><br><span class="line">    c. 숫자는 <span class="number">3</span>자리마다 ‘,’ 표시를 해줘야 한다.</span><br><span class="line">    d. 이 들어오면 그 이후부터는 ‘,’ 표시하지 않는다.</span><br><span class="line">    e. 연산 기호를 누르기 전까지는 하나의 숫자로 계속해서 연결해야 한다.</span><br><span class="line"><span class="number">5.</span> 연산 기호를 누르면? 👉🏻 <span class="variable constant_">CSS</span>를 변경시킨다. (배경색, 글자 색 반전) <span class="keyword">class</span> 동적 추가</span><br><span class="line"><span class="number">6.</span> 숫자 → 연산 기호 → 숫자 → = 기호순으로 클릭하면 👉🏻 값을 계산 후 결과를 보여준다.</span><br><span class="line"><span class="number">7.</span> 숫자 → 연산 기호 → = 기호순으로 클릭하면 👉🏻 동일한 숫자를 연산하여 결과를 보여준다.</span><br></pre></td></tr></table></figure>

<p>🙋🏻‍♂️ 저장해놔야 하는 값들이 있을까?</p>
<p>: 현재 값, 이전값, 연산자 그리고 화면에 출력되는 값을 변수로 선언해놓고 계속해서 변경해야 한다.</p>
<h2 id="고민을-하고-있는-부분-🤔"><a href="#고민을-하고-있는-부분-🤔" class="headerlink" title="고민을 하고 있는 부분 🤔"></a>고민을 하고 있는 부분 🤔</h2><p><code>상태가 변경되면 re-rendering을 한다</code> 라는 생각을 가지고 프로그래밍하고 싶은데 어떤 것을 상태로 관리해야 할 지 고민이 되었다. 저장해놔야 하는 값들이 모두 상태라면 너무 많은 리렌더링을 하는 것은 아닌가 싶고, 리렌더링을 해야 하는 시점이 결과를 연산한 값이라면 상태는 화면에 출력될 값밖에 없다는 뜻인데 그렇다면 이것을 상태로 관리해야 할까? 라는 생각이 들었다.</p>
<p>또 하나 고민을 해야 할 부분은 <code>함수는 하나의 역할만 해야 한다</code> 라는 것이다. 함수를 어떻게 분리할 것인지도 고민을 해야할 것 같다. 현재로서는</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 화면에 출력되는 값을 업데이트하는 함수</span></span><br><span class="line"><span class="comment">// AC 버튼을 눌렀을 때 모든 것을 초기화하는 함수</span></span><br><span class="line"><span class="comment">// operation을 설정하는 함수</span></span><br><span class="line"><span class="comment">// operation을 해제하는 함수</span></span><br><span class="line"><span class="comment">// 연산자와 피연산자를 받아서 결과를 계산하는 함수</span></span><br></pre></td></tr></table></figure>

<p>이렇게 만들어야하지 않을까 미리 생각해보았다. <em>(물론 코드를 짜기 시작하면 많은 것들이 변할테지만..🥲)</em></p>
<h2 id="🧮-생각해보면서-느꼈던-점"><a href="#🧮-생각해보면서-느꼈던-점" class="headerlink" title="🧮 생각해보면서 느꼈던 점"></a>🧮 생각해보면서 느꼈던 점</h2><p>알고리즘에서 의사코드를 작성하듯이 프로그래밍을 하기 전에 미리 큰 틀을 생각해보는 것도 좋은 것 같다. 당장 생각나는 것들부터 작성하기 시작하면 이후에 수정해야 할 부분들이 한 두가지가 아니라는 것을 경험했기 때문이다.</p>
<p>내일은 반복문과 조건문 연습문제를 페어와 함께 풀어야 하는 날이니까 계산기는 잠시 제쳐두고 페어에 집중해야지.</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>제어문</title>
    <url>/2023/230222-archive/</url>
    <content><![CDATA[<h2 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h2><h3 id="✅-제어문"><a href="#✅-제어문" class="headerlink" title="✅ 제어문"></a>✅ <strong>제어문</strong></h3><p>: 조건에 따라 <strong>코드 블록을 실행(조건문)하거나 반복 실행할 때(반복문)</strong> 사용</p>
<ul>
<li>일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다.</li>
<li>제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.</li>
<li>하지만 코드 실행 순서가 변경된다는 것<br>➡️ 단순히 위에서 아래로 순차적으로 진행하는 직관적인 코드의 흐름을 혼란스럽게 만든다.</li>
</ul>
<p>👉🏻 따라서 제어문은 코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점이 있다.</p>
<p><strong>가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 된다.</strong></p>
<ul>
<li>forEach, map, filter, reduce와 같은 고차함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력하자</li>
</ul>
<h2 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h2><h3 id="✅-블록문"><a href="#✅-블록문" class="headerlink" title="✅ 블록문"></a>✅ 블록문</h3><p>: <strong>0개 이상의 문</strong>을 <strong>중괄호</strong>로 묶은 것</p>
<ul>
<li>코드 블록 또는 블록으로 부르기도 한다.</li>
<li>자바스크립트 블록문을 하나의 실행 단위로 취급한다.</li>
</ul>
<p>블록문은 단독으로 사용할 수도 있으나, 일반적으로 제어문이나 함수를 정의할 때 사용하는 것이 일반적이다.</p>
<p><strong>🔥 블록문에는 세미콜론을 붙여야 할까?</strong></p>
<ul>
<li>문의 끝에는 <strong>세미콜론</strong>을 붙이는 것이 일반적이다.</li>
<li>하지만 블록문은 언제나 <strong>문의 종료를 의미하는 자체종결성</strong>을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다는 것에 주의하자.</li>
</ul>
<p>🙌🏻 블록문이 사용되는 다양한 예제다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 블록문</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제어문</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><h3 id="✅-조건문"><a href="#✅-조건문" class="headerlink" title="✅ 조건문"></a>✅ 조건문</h3><p>: 주어진 <strong>조건식의 평가 결과</strong>에 따라 <strong>코드블록의 실행을 결정</strong>한다.</p>
<ul>
<li>조건식 👉🏻 <strong>불리언 값으로 평가</strong>될 수 있는 표현식이다.</li>
<li>자바스크립트는 두 가지 조건문을 제공한다.<ul>
<li>if…else문</li>
<li>switch문</li>
</ul>
</li>
</ul>
<h3 id="1-if…else문"><a href="#1-if…else문" class="headerlink" title="1. if…else문"></a>1. if…else문</h3><p><strong>✅ if…else문</strong></p>
<p>: 주어진 조건식의 평가결과 즉 <strong>논리적 참 또 거짓</strong>에 따라 실행할 코드 블록을 결정한다.</p>
<ul>
<li>조건식의 평가 결과가 true일 경우 👉🏻 if문의 코드 블록이 실행</li>
<li>false일 경우 👉🏻 else문의 코드 블록이 실행</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식) &#123;</span><br><span class="line">  <span class="comment">// 조건식이 true일 경우 코드 블록이 실행</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식이 거짓이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>💡 <strong>if문의 조건식은 불리언 값으로 평가되어야 한다.</strong></p>
<ul>
<li>만약 if문의 조건식이 불리언 값이 아닌 값으로 평가되면? 👉🏻 자바스크립트 엔진에 의해 암묵적으로 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다. <code>👉 암묵적 타입 변환</code></li>
<li><strong>조건식을 추가</strong>하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면? 👉🏻 else if문을 사용</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식1이 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (조건식<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식2가 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>🖥 else if문과 else문은 옵션이다.</strong></p>
<ul>
<li>즉, 사용할 수도 있고 사용하지 않을 수도 있다.</li>
<li>if문과 else문은 2번 이상 사용할 수 없지만 else if 문은 여러번 사용할 수 있다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 문</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">&#x27;양수&#x27;</span>; <span class="comment">// 음수를 구별할 수 없다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kind); <span class="comment">// 양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else 문</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">&#x27;양수&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  kind = <span class="string">&#x27;음수&#x27;</span>; <span class="comment">// 0은 음수가 아니다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kind); <span class="comment">// 양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else if 문</span></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">&#x27;양수&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  kind = <span class="string">&#x27;음수&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  kind = <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>) kind = <span class="string">&#x27;양수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) kind = <span class="string">&#x27;음수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> kind = <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure>

<p>🖥 <strong>대부분의 if…else문은 삼항 조건 연산자로 바꿔쓸 수 있다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x가 짝수이면 result 변수에 문자열 &#x27;짝수&#x27;를 할당하고, 홀수이면 문자열 &#x27;홀수&#x27;를 할당한다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// 2 % 2는 0이다. 이때 0은 false로 암묵적 강제 변환된다.</span></span><br><span class="line">  result = <span class="string">&#x27;홀수&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  result = <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>🙌🏻 위 예제는 다음과 같이 삼항 조건 연산자로 바꿔쓸 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다.</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 짝수</span></span><br></pre></td></tr></table></figure>

<p>🙌🏻 만약 경우의 수가 세가지(양수, 음수, 0)이라면 다음과 같이 바꿔쓸 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다.</span></span><br><span class="line"><span class="keyword">var</span> kind = num ? (num &gt; <span class="number">0</span> ? <span class="string">&#x27;양수&#x27;</span> : <span class="string">&#x27;음수&#x27;</span>) : <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>num &gt; 0 ? &#39;양수&#39; : &#39;음수&#39;</code> 👉🏻 표현식</li>
<li>즉, 삼항 조건 연산자는 <strong>값으로 평가되는 표현식</strong>을 만든다.<br>➡️ 따라서 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다.</li>
<li>if…else문은? 👉🏻 <strong>표현식이 아닌 문</strong><br>➡️ if…else은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다.</li>
</ul>
<h3 id="2-switch문"><a href="#2-switch문" class="headerlink" title="2. switch문"></a>2. switch문</h3><p><strong>✅ switch문</strong></p>
<p>: 주어진 표현식을 평가하여 <strong>그 값과 일치하는 표현식을 갖는 case문</strong>으로 실행 흐름을 옮긴다.</p>
<ul>
<li>case문은 👉🏻 상황을 의미하는 표현식을 지정하고 콜론으로 마친다.</li>
<li>그 뒤에 실행할 문들을 위치시킨다.</li>
<li>switch문의 표현식과 일치하는 case문이 없다면? 👉🏻 실행 순서는 default문으로 이동<ul>
<li>default문: 선택사항, 사용할 수도 있고 사용하지 않을 수도 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(표현식) &#123;</span><br><span class="line">	<span class="keyword">case</span> 표현식<span class="number">1</span>:</span><br><span class="line">		<span class="keyword">switch</span>문의 표현식과 표현식 <span class="number">1</span>이 일치하면 실행될 문;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 표현식<span class="number">2</span>:</span><br><span class="line">		<span class="keyword">switch</span>문의 표현식과 표현식 <span class="number">2</span>가 일치하면 실행될 문;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="attr">default</span>:</span><br><span class="line">		<span class="keyword">switch</span>문의 표현식과 일치하는 <span class="keyword">case</span>문이 없을 때 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🤔 <strong>언제 if…else문을 사용하고 언제 switch문을 사용해야 할까?</strong></p>
<p>if…else문의 조건식은 <strong>불리언 값</strong>으로 평가되어야 하지만 switch문의 표현식은 불리언 값보다는 <strong>문자열이나 숫자 값</strong>인 경우가 많다.</p>
<ul>
<li>if…else문은 논리적 참, 거짓으로 실행할 코드 블록을 결정</li>
<li>switch문은 논리적 참, 거짓보다는 다양한 상황에 따라 코드 블록을 결정할 때 사용</li>
</ul>
<p><strong>🙌🏻 switch문 예제를 살펴보자</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 월을 영어로 변환한다. (11 → &#x27;November&#x27;)</span></span><br><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;January&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;February&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;March&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;April&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;May&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;June&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;July&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;August&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;September&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;October&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;November&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;December&#x27;</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;Invalid month&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(monthName); <span class="comment">// Invalid month</span></span><br></pre></td></tr></table></figure>

<ul>
<li>month 변수의 평가 결과인 숫자 11과 일치하는 case문으로 이동한다.</li>
<li>하지만 ‘November’가 출력되지 않고 ‘Invalid month’가 출력된다. 왜 그런걸까?</li>
</ul>
<p>➡️ 평가 결과와 일치하는 case문으로 실행 흐름이 이동하여 문을 실행한 것은 맞다.</p>
<p>➡️ 하지만 switch문을 탈출하지 않고 switch문이 끝날 때까지 이후의 모든 case문과 default문을 실행했기 때문이다. 👉🏻 **폴스루(fall through)**라고 한다.</p>
<ul>
<li>다시 말해, mothName 변수에 November가 할당된 후 → switch 문을 탈출하지 않고 연이어 December 재할당 → 마지막으로 Invalid month 재할당</li>
</ul>
<p>🔥 <strong>switch문을 탈출하려면 어떻게 해야할까? 👉🏻 break문 사용</strong></p>
<ul>
<li>break문은 break 키워드로 구성되어 있으며, 코드 블록에서 탈출하는 역할을 한다.</li>
<li>break문이 없다면? 👉🏻 case문의 표현식과 일치하지 않더라도 실행 흐름이 다음 case문으로 연이어 이동한다.</li>
</ul>
<p>🙌🏻 올바른 switch문의 예제를 살펴보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 월을 영어로 변환한다. (11 → &#x27;November&#x27;)</span></span><br><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;January&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;February&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;March&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;April&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;May&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;June&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;July&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;August&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;September&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;October&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;November&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;December&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    monthName = <span class="string">&#x27;Invalid month&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(monthName); <span class="comment">// November</span></span><br></pre></td></tr></table></figure>

<p>🔥 <strong>defualt문에는 break문을 생략하는 것이 일반적이다.</strong></p>
<p>default문은 switch문의 맨 마지막에 위치하므로 defualt문의 실행이 종료되면 switch문을 빠져나간다.</p>
<p>💡 <strong>break문을 생략한 폴스루가 유용한 경우도 있다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> year = <span class="number">2000</span>; <span class="comment">// 2000년은 윤년으로 2월이 29일이다.</span></span><br><span class="line"><span class="keyword">var</span> month = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> days = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    days = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    days = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// 윤년 계산 알고리즘</span></span><br><span class="line">    <span class="comment">// 1. 연도가 4로 나누어떨어지는 해(2000, 2004, 2008, 2012, 2016, 2020...)는 윤년이다.</span></span><br><span class="line">    <span class="comment">// 2. 연도가 4로 나누어떨어지더라도 연도가 100으로 나누어떨어지는 해(2000, 2100, 2200...)는 평년이다.</span></span><br><span class="line">    <span class="comment">// 3. 연도가 400으로 나누어떨어지는 해(2000, 2400, 2800...)는 윤년이다.</span></span><br><span class="line">    days = (year % <span class="number">4</span> === <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !== <span class="number">0</span>) || year % <span class="number">400</span> === <span class="number">0</span> ? <span class="number">29</span> : <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invalid month&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(days); <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>

<ul>
<li>switch 문은 case, default, break 등 다양한 키워드를 사용해야 하고 폴스루가 발생하는 등 문법도 복잡하다.</li>
<li>만약 if…else문으로 해결할 수 있다면? 👉🏻 switch문보단 if…else문을 사용하자.</li>
<li>조건이 너무 많다면? 👉🏻 switch문을 사용하자.</li>
</ul>
<h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><h3 id="반복문-1"><a href="#반복문-1" class="headerlink" title="반복문"></a>반복문</h3><p>: 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다. 조건식이 거짓일 때까지 반복한다.</p>
<p><strong>🖥 자바스크립트는 세가지 반복문을 제공한다.</strong></p>
<ol>
<li>for문</li>
<li>while문</li>
<li>do…while문</li>
</ol>
<h3 id="1-for문"><a href="#1-for문" class="headerlink" title="1. for문"></a>1. for문</h3><p>: 조건식이 거짓으로 평가될 때까지 코드 블록을 반복 실행한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(변수 선언문 또는 할당문; 조건식; 증감식) &#123;</span><br><span class="line">	조건식이 참인 경우 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🙌🏻 for문이 어떻게 동작하는지 알아보자</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 예제의 for문은 i 변수가 0으로 초기화된 상태에서 시작하여 i가 2보다 작을 때까지 코드 블록을 2번 반복 실행한다.</li>
</ul>
<p>🙌🏻 for문의 실행순서를 알아보자</p>
<p><img src="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2Fb48cb8aa-ccc2-48fa-9d2c-eb2bee2acebb%2Fimage.png" alt="https://velog.velcdn.com/images%2Fapril_5%2Fpost%2Fb48cb8aa-ccc2-48fa-9d2c-eb2bee2acebb%2Fimage.png"></p>
<ol>
<li>for문을 실행하면 👉🏻 먼저 변수 선언문 <code>var i = 0</code>이 실행된다.<ol>
<li><strong>변수 선언문은 단 한 번만 실행</strong>된다.</li>
</ol>
</li>
<li>변수 선언문의 실행이 종료되면? 👉🏻 조건식이 실행된다.<ol>
<li>현재 i변수의 값은 0이므로 조건식의 평가 결과는 true이다.</li>
</ol>
</li>
<li>조건식의 평가 결과가 true이므로 <strong>코드 블록이 실행</strong>된다.<ol>
<li>증감문으로 이동하는 것이 아니라 코드블록으로 실행 흐름이 이동하는 것에 주의하자</li>
</ol>
</li>
<li>코드 블록 실행이 종료되면 증감식 i++가 실행되어 i 변수의 값은 1이 된다.</li>
<li>증감식 실행이 종료되면? 👉🏻 조건식이 실행된다.<ol>
<li>변수 선언문은 단 한번만 실행되기 때문에 조건식이 실행된다는 점에 주의하자</li>
<li>현재 변수 i의 값은 1이므로 조건식의 평가 결과는 true이다.</li>
</ol>
</li>
<li>조건식의 평가 결과가 true이므로 코드 블록이 다시 실행된다.</li>
<li>코드 블록의 실행이 종료되면 증감식 i++가 실행되어 변수의 값은 2가 된다.</li>
<li>증감식 실행이 종료되면 다시 조건식이 실행된다.<ol>
<li>현재 i 변수의 값이 2이므로 조건식의 평가 결과는 false이다.</li>
<li>조건식의 평가 결과가 false이므로 for문의 실행이 종료된다.</li>
</ol>
</li>
</ol>
<p>🔥 <strong>for문의 변수 선언문, 조건식, 증감식은 모두 옵션이다.</strong></p>
<p>모두 옵션이므로 반드시 사용할 필요는 없다.</p>
<p>단, 어떤 식도 선언하지 않으면 무한 루프가 된다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>🖥 <strong>for문 내에 for문을 중첩해 사용할 수 있다. 👉🏻 중첩 for문</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 두 개의 주사위를 던졌을 때 두 눈의 합이 6이 되는 모든 경우의 수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + j === <span class="number">6</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`[<span class="subst">$&#123;i&#125;</span>, <span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-while문"><a href="#2-while문" class="headerlink" title="2. while문"></a>2. while문</h3><h3 id="✅-while문"><a href="#✅-while문" class="headerlink" title="✅ while문"></a>✅ while문</h3><p>: 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다.</p>
<ul>
<li>for문 👉🏻 반복횟수가 명확할 때 사용</li>
<li>while문 👉🏻 반복횟수가 불명확할 때 주로 사용</li>
</ul>
<p>🔥 <strong>while문은 조건문의 평가 결과가 거짓이 되면 코드 블록을 실행하지 않고 종료한다.</strong></p>
<p>만약 조건식의 평가 결과가 불리언 값이 아니면? 👉🏻 불리언 값으로 강제 변환하여 논리적 참, 거짓 구별</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 0 1 2</span></span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🖥 <strong>조건식의 평가 결과가 언제나 참이면? 👉🏻 무한루프가 된다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>무한루프에서 탈출하기 위해서는? 👉🏻 코드 블록 내에 if문으로 탈출 조건을 만들고 break문으로 코드 블록을 탈출한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  count++;</span><br><span class="line">  **<span class="comment">// count가 3이면 코드 블록을 탈출한다.</span></span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">3</span>) <span class="keyword">break</span>;**</span><br><span class="line">&#125; <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-do…while문"><a href="#3-do…while문" class="headerlink" title="3. do…while문"></a>3. do…while문</h3><h3 id="✅-do…while문"><a href="#✅-do…while문" class="headerlink" title="✅ do…while문"></a>✅ do…while문</h3><p>: 코드 블록을 먼저 실행하고 조건식을 평가한다.</p>
<p>➡️ 코드 블록은 무조건 한 번 이상 실행된다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; <span class="keyword">while</span> (count &lt; <span class="number">3</span>); <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>

<h2 id="break문"><a href="#break문" class="headerlink" title="break문"></a>break문</h2><p>break문은 코드 블록을 탈출한다.</p>
<p>➡️ 정확히 말하자면 break문은 레이블문, 반복문, swit h문의 코드 블록을 탈출한다.</p>
<p>레이블문, 반복문, switch문의 코드 블록 이외에 break문을 사용하면 문법 에러가 발생한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✨ <strong>레이블 문</strong></p>
<p>: 레이블 문은 <strong>식별자가 붙은 문</strong>을 말한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo라는 레이블 식별자가 붙은 레이블 문</span></span><br><span class="line"><span class="attr">foo</span>: <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>📚 <strong>레이블 문은 프로그램의 실행 순서를 제어하는 데 사용한다.</strong></p>
<ul>
<li>switch문의 <strong>case문과 default문</strong>도 레이블 문이다.</li>
<li>레이블 문을 탈출하려면? 👉🏻 <strong>break문에 레이블 식별자</strong>를 지정한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo라는 식별자가 붙은 레이블 문</span></span><br><span class="line"><span class="attr">foo</span>: [</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">break</span> foo; <span class="comment">// foo 레이블 블록문을 탈출한다.</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>중첩된 for문의 내부 for문에서 break문을 실행하면? 👉🏻 내부 for문을 탈출하여 외부 for문으로 진입</li>
<li>이때 내부 for문이 아닌 외부 for문을 탈출하려면 레이블문을 사용한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// outer라는 식별자가 붙은 레이블 for 문</span></span><br><span class="line"><span class="attr">outer</span>: <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="comment">// i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.</span></span><br><span class="line">    <span class="keyword">if</span> (i + j === <span class="number">3</span>) <span class="keyword">break</span> outer;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`inner [<span class="subst">$&#123;i&#125;</span>, <span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>레이블 문은 중첩된 for문 외부로 탈출할 때 유용하다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> input = <span class="title function_">prompt</span>(<span class="string">`(<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>)의 값`</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 여기서 멈춰서 아래쪽의 `완료!`가 출력되게 하려면 어떻게 해야 할까?</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;완료!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>➡️ <code>input</code> 아래에 평범한 break문을 사용하면 안쪽에 있는 반복문만 빠져나올 수 있다. 이것만으론 충분하지 않다. (중첩 반복문을 포함한 반복문 두 개 모두를 빠져나와야 하기 때문에)</p>
<p>반복문 안에서 레이블 문을 사용하면 레이블에 해당하는 반복문에서 빠져나올 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">outer</span>: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> input = <span class="title function_">prompt</span>(<span class="string">`(<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>)의 값`</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나온다.</span></span><br><span class="line">    <span class="keyword">if</span> (!input) <span class="keyword">break</span> outer; <span class="comment">// (*)</span></span><br><span class="line">    <span class="comment">// 입력받은 값을 가지고 무언가를 함</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;완료!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>위 예시에서 <code>break outer</code>는 <code>outer</code>라는 레이블이 붙은 반복문을 찾고, 해당 반복문을 빠져나오게 해준다.</p>
<p><strong>🔥 레이블은 마음대로 점프할 수 있게 해주지 않는다.</strong></p>
<p>레이블을 사용한다고 해서 원하는 곳으로 마음대로 점프할 수 있는 것은 아니다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> label; <span class="comment">// 아래 for 문으로 점프할 수 없다.</span></span><br><span class="line"><span class="attr">label</span>: <span class="keyword">for</span> (...)</span><br></pre></td></tr></table></figure>

<p><code>break</code>와 <code>continue</code>는 반복문 안에서만 사용할 수 있고, 레이블은 반드시 <code>break</code>이나 <code>continue</code> 지시자 위에 있어야 한다.</p>
<p>💡 <strong>레이블 문은 중첩된 for문 외부로 탈출할 때 유용하지만 그 밖의 경우에는 일반적으로 권장하지 않는다.</strong></p>
<p>레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다.</p>
<p>🖥 <strong>break문은 레이블문 뿐만 아니라 반복문, switch문에서도 사용할 수있다.</strong></p>
<p>이 경우에는 break문에 레이블 식별자를 정하지 않는다.</p>
<p>break문은 👉🏻 반복문을 더 이상 진행하지 않아도 될 때 불필요한 반복을 회피할 수 있어 유용하다.</p>
<p>🙌🏻 다음은 문자열에서 특정 문자의 인덱스를 검색하는 예다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> search = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> index;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 문자열의 개별 문자가 &#x27;l&#x27;이면</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] === search) &#123;</span><br><span class="line">    index = i;</span><br><span class="line">    **<span class="keyword">break</span>; <span class="comment">// 반복문을 탈출한다.**</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 참고로 String.prototype.indexOf 메서드를 사용해도 같은 동작을 한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">indexOf</span>(search)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="continue문"><a href="#continue문" class="headerlink" title="continue문"></a>continue문</h2><h3 id="✅-continue문"><a href="#✅-continue문" class="headerlink" title="✅ continue문"></a>✅ continue문</h3><p>: 반복문의 코드 블록 실행을 현 시점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.</p>
<p>break문처럼 반복문을 탈출하지는 않는다.</p>
<p>🙌🏻 다음은 문자열에서 특정 문자의 개수를 세는 예다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;Hello World.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> search = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열은 **유사배열**이므로 for 문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] !== search) <span class="keyword">continue</span>;</span><br><span class="line">  count++; <span class="comment">// continue 문이 실행되면 이 문은 실행되지 않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 참고로 String.prototype.match 메서드를 사용해도 같은 동작을 한다.</span></span><br><span class="line"><span class="keyword">const</span> regexp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(search, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">match</span>(regexp).<span class="property">length</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>위 예제의 for문은 다음 코드와 동일하게 동작한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이면 카운트를 증가시킨다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] === search) count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>실행해야 할 코드가 한 줄이라면 continue문을 사용했을 때보다 간편하고 가독성이 좋다.</li>
<li>하지만 if문 내에서 실행해야 할 코드가 많다면 들여쓰기가 한 단계 깊어지므로 continue문을 사용하는 편이 가독성이 더 좋다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// continue 문을 사용하지 않으면 if 문 내에 코드를 작성해야 한다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이면 카운트를 증가시킨다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] === search) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// continue 문을 사용하면 if 문 밖에 코드를 작성할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// &#x27;l&#x27;이 아니면 카운트를 증가시키지 않는다.</span></span><br><span class="line">  <span class="keyword">if</span> (string[i] !== search) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gallery</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DeepDive</tag>
      </tags>
  </entry>
  <entry>
    <title>innerText | textContent</title>
    <url>/2023/230223-archive/</url>
    <content><![CDATA[<h3 id="innerText와-textContent의-공통점은-무엇일까"><a href="#innerText와-textContent의-공통점은-무엇일까" class="headerlink" title="innerText와 textContent의 공통점은 무엇일까?"></a>innerText와 textContent의 공통점은 무엇일까?</h3><p>: 자바스크립트로 텍스트를 변경할 때 사용한다.</p>
<h2 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h2><p>Node.prototype.textContent 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로서 <strong>요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경한다.</strong></p>
<p>요소 노드의 textContent 프로퍼티를 참조하면 요소 노드의 시작 태그와 종료 태그 사이 내의 텍스트를 모두 반환한다. 다시 말해, childNodes 프로퍼티가 반환한 모든 노드들의 텍스트 노드의 값 즉, 텍스트를 모두 반환한다. 이때 HTML마크업은 모두 무시된다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>world! <span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#x27; &#x27;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">textContent</span>); <span class="comment">// Hello world!</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>요소 노드의 textContent 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 요소 노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 이떄 할당한 문자열에 HTML 마크업이 포함되어 있더라도 문자열 그대로 인식되어 텍스트로 취급된다. 즉, HTML 마크업이 파싱되지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>world! <span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#123;&#x27; &#x27;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">textContent</span> = <span class="string">&#x27;Hi &lt;span&gt;there!&lt;/span&gt;&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="innerText"><a href="#innerText" class="headerlink" title="innerText"></a>innerText</h2><p>HTMLElement.innerText 프로퍼티는 요소와 그 자손의 렌더링 된 텍스트 콘텐츠를 나타낸다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;원본 요소:&lt;/h3&gt;</span><br><span class="line">&lt;p id=&quot;source&quot;&gt;</span><br><span class="line">  &lt;style&gt;#source &#123; color: red; &#125;&lt;/style&gt;</span><br><span class="line">아래에서&lt;br&gt;이 글을&lt;br&gt;어떻게 인식하는지 살펴보세요.</span><br><span class="line">  **&lt;span style=&quot;display:none&quot;&gt;숨겨진 글&lt;/span&gt;**</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;h3&gt;textContent 결과:&lt;/h3&gt;</span><br><span class="line">&lt;textarea id=&quot;textContentOutput&quot; rows=&quot;6&quot; cols=&quot;30&quot; readonly&gt;...&lt;/textarea&gt;</span><br><span class="line">&lt;h3&gt;innerText 결과:&lt;/h3&gt;</span><br><span class="line">&lt;textarea id=&quot;innerTextOutput&quot; rows=&quot;6&quot; cols=&quot;30&quot; readonly&gt;...&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;source&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> textContentOutput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;textContentOutput&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> innerTextOutput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;innerTextOutput&#x27;</span>);</span><br><span class="line"></span><br><span class="line">textContentOutput.<span class="property">innerHTML</span> = source.<span class="property">textContent</span>;</span><br><span class="line">innerTextOutput.<span class="property">innerHTML</span> = source.<span class="property">innerText</span>;</span><br></pre></td></tr></table></figure>

<p>source.textContent와 source.innerText 두 개가 어떻게 보일까?</p>
<p>👉🏻 textContent는 <code>‘숨겨진 글’</code> 을 반환한다. 하지만 innerText는 반환하지 않는다.</p>
<p>👉🏻 textContent는 HTML 마크업이 포함되더라도 무시한다. 하지만 innerText는 <br>을 인식하고 한 줄을 개행한다.</p>
<h3 id="innerText는-렌더링-중인-요소를-반환하고"><a href="#innerText는-렌더링-중인-요소를-반환하고" class="headerlink" title="*innerText는 렌더링 중인 요소를 반환하고,"></a>*innerText는 렌더링 중인 요소를 반환하고,</h3><p>textContent는 텍스트 노드를 반환한다.*</p>
<h2 id="innterText와-textContent-중-무엇을-써야할까"><a href="#innterText와-textContent-중-무엇을-써야할까" class="headerlink" title="innterText와 textContent 중 무엇을 써야할까?"></a>innterText와 textContent 중 무엇을 써야할까?</h2><p>둘 다 유사한 동작을 하지만 innerText 프로퍼티는 다음과 같은 이유로 사용하지 않는 것이 좋다.</p>
<ul>
<li>innerText 프로퍼티는 CSS에 순종적이다. 예를 들어, innerText는 CSS에 의해 비표시 <code>(visibility: hidden)</code> 로 지정된 요소 노드의 텍스트를 반환하지 않는다.</li>
<li>innerText 프로퍼티는 CSS를 고려해야 하므로 textContent 프로퍼티보다 느리다.</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>크레인 인형뽑기 [2019 카카오 개발자 겨울 인턴십]</title>
    <url>/2022/221013-archive/</url>
    <content><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.<br>죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.</p>
<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png"></p>
<p>게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다.</p>
<p>모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다.</p>
<p>다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.</p>
<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png"></p>
<p>만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.</p>
<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif"></p>
<p>크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동 시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)</p>
<p>게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.</p>
<h2 id="제한-사항"><a href="#제한-사항" class="headerlink" title="제한 사항"></a>제한 사항</h2><p>board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.</p>
<p>board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.</p>
<p>0은 빈 칸을 나타냅니다.</p>
<p>1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나<br>타냅니다.</p>
<p>moves 배열의 크기는 1 이상 1,000 이하입니다.</p>
<p>moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.</p>
<h2 id="예제입력"><a href="#예제입력" class="headerlink" title="예제입력"></a>예제입력</h2><p>▣ 입력예제 1</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">][(<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>)]; <span class="comment">//board 배열 //moves 배열</span></span><br></pre></td></tr></table></figure>

<p>▣ 출력예제 1</p>
<p>4</p>
<hr>
<h3 id="🙌🏻-문제-이해하기"><a href="#🙌🏻-문제-이해하기" class="headerlink" title="🙌🏻 문제 이해하기"></a>🙌🏻 문제 이해하기</h3><p>문제를 해결하기 위해 어떤 방법을 사용해야하는지 생각해보자 :)</p>
<ol>
<li>인형을 스택이라는 바구니에 넣어야 한다. ➡️ 배열 생성</li>
<li>moves 배열을 하나씩 순회해야한다. ➡️ forEach 메서드</li>
<li>위치 1에 해당하는 board의 인덱스는 0이다.<ol>
<li>board 배열의 형태는 2차원 배열이며 위치 1에 해당하는 요소를 탐색하기 위해선</li>
<li>[0][1], [1][1], [2][1] 의 형태로 반복을 해야한다. ➡️ for문 [i][1]</li>
</ol>
</li>
<li>반복문으로 탐색을 하다가 값이 0이 아닌 요소를 만나면 인형을 꺼내야한다.</li>
<li>인형을 꺼냈다면 해당 위치의 배열 요소는 0으로 만들어줘야 한다.</li>
<li>꺼낸 인형을 스택에 push하자. 그 전에 체크를 해야하는데,<ol>
<li>만약 스택에 담겨있는 마지막 인형이 넣을 인형과 동일하다면? → push가 아니라 pop을 하면 된다. 그리고 answer +&#x3D; 2</li>
<li>동일하지 않다면? → 그 때 push하기</li>
</ol>
</li>
<li>터진 인형의 갯수를 구하는 문제이기 때문에 answer를 반환하면 된다.</li>
</ol>
<h3 id="✅-solution"><a href="#✅-solution" class="headerlink" title="✅ solution"></a>✅ solution</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">board, moves</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  moves.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; board.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// 순회하는 요소가 0이 아닐때만 stack에 값을 push할 수 있다.</span></span><br><span class="line">      <span class="keyword">if</span> (board[i][item - <span class="number">1</span>] !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// stack에 넣을 값을 임시 저장해놓기 (인형 꺼내기)</span></span><br><span class="line">        <span class="keyword">let</span> tmp = board[i][item - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 값을 선택했으니, 배열의 원소는 0으로 설정해놓기</span></span><br><span class="line">        board[i][item - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// stack에 push 하기 전에 먼저 체크</span></span><br><span class="line">        <span class="comment">// 1. 만약 tmp가 stack의 가장 마지막 요소와 같으면 pop하고 answer += 2</span></span><br><span class="line">        <span class="comment">// 2. tmp가 stack의 가장 마지막 요소와 일치하지 않으면 stack.push(tmp)</span></span><br><span class="line">        <span class="keyword">if</span> (tmp === stack[stack.<span class="property">length</span> - <span class="number">1</span>]) &#123;</span><br><span class="line">          stack.<span class="title function_">pop</span>();</span><br><span class="line">          answer += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> stack.<span class="title function_">push</span>(tmp);</span><br><span class="line">        <span class="comment">// 해당 포지션에선 작업을 끝냈기 때문에 for문에서 탈출</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title function_">solution</span>(</span><br><span class="line">    [</span><br><span class="line">      [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">      [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">      [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">      [<span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">      [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">    ],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="😎-Review"><a href="#😎-Review" class="headerlink" title="😎 Review"></a>😎 Review</h2><p>stack을 구현하고 배열을 하는 부분까지는 이제 어렵지 않다. 하지만 어느 시점에서 어떻게 자료를 빼낼건지에 대해서는 계속 공부를 하면서 익숙해져야할 것 같다…😢</p>
<p>예전엔 건들지도 못했던 내 자신과 비교하면 그래도 많이 늘었다! 게속 열심히 공부해보즈앗</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 2주차 주간회고</title>
    <url>/2023/230224-archive/</url>
    <content><![CDATA[<p>1주차엔 붕 뜬 마음이 가라앉지 않아 정신없이 공부했다면, 2주차는 어느정도 적응이 되었던 것 같다. 열심히 공부한 2주차 회고! 🏃🏻</p>
<h2 id="주간-회고"><a href="#주간-회고" class="headerlink" title="주간 회고"></a>주간 회고</h2><h3 id="2주차엔-뭘-배웠지"><a href="#2주차엔-뭘-배웠지" class="headerlink" title="2주차엔 뭘 배웠지?"></a>2주차엔 뭘 배웠지?</h3><p>지난 주엔 HTML과 CSS 기초에 대해서 배웠다면 2주차에는 자바스크립트를 시작했다. 변수와 데이터 타입, 제어문, 함수에 대해서 공부했다. 페어 시간에는 자바스크립트로 계산기를 구현하는 시간을 가졌다.</p>
<h3 id="잘한-점은-무엇이-있을까"><a href="#잘한-점은-무엇이-있을까" class="headerlink" title="잘한 점은 무엇이 있을까?"></a>잘한 점은 무엇이 있을까?</h3><p>뭔가 풀리지 않을 때에도 검색하지 않고 끝까지 내가 생각해보고 코드를 작성했다. 예전의 나는 기능 구현을 하려고 할 때 막히는 부분이 생기면 다른 사람의 코드를 보고 비슷하게 썼었다.</p>
<p>하지만 이렇게 구현하면 동작은 하겠지만, 내 지식이 아니게 된다. 내 성장을 위해선 안되더라도 끝까지 부딪혀봐야한다고 생각해서 나의 코드로 먼저 동작을 하도록 만들고 그 이후에 모범 코드를 확인했다.</p>
<h3 id="아쉬운-점은-무엇이-있을까"><a href="#아쉬운-점은-무엇이-있을까" class="headerlink" title="아쉬운 점은 무엇이 있을까?"></a>아쉬운 점은 무엇이 있을까?</h3><p>집중을 잘 하지 못했다.</p>
<p>분명 오늘 해야할 일들이 여러 개 있다는 것을 알면서도 쉽게 집중하지 못하는 시간이 많았던 것 같다. 이럴 때 어떻게 극복해야 하는지 해결방법을 찾지 못했다. 다음주에는 배열, 객체 코플릿 문제도 풀어야하고 클로저 개념도 배우니 자연스럽게 집중하지 않을까싶다.</p>
<h3 id="✅-다음-주에-해야-할-것들"><a href="#✅-다음-주에-해야-할-것들" class="headerlink" title="✅ 다음 주에 해야 할 것들"></a>✅ 다음 주에 해야 할 것들</h3><ul>
<li>계산기 구현 코드 정리해놓기(이번 주말까지)</li>
<li>DOM 내용 정리하기</li>
<li>클로저 개념 공부하기</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 3주차 주간회고</title>
    <url>/2023/230303-archive-1/</url>
    <content><![CDATA[<p>열심히 달려왔나…? 코드스테이츠 3주차 회고! 🏃🏻</p>
<h2 id="주간-회고"><a href="#주간-회고" class="headerlink" title="주간 회고"></a>주간 회고</h2><h3 id="3주차엔-뭘-배웠지"><a href="#3주차엔-뭘-배웠지" class="headerlink" title="3주차엔 뭘 배웠지?"></a>3주차엔 뭘 배웠지?</h3><p>자바스크립트의 자료구조인 배열과 객체, 스코프와 클로저에 대해서 공부했다.</p>
<h3 id="잘한-점은-무엇이-있을까"><a href="#잘한-점은-무엇이-있을까" class="headerlink" title="잘한 점은 무엇이 있을까?"></a>잘한 점은 무엇이 있을까?</h3><p>원시 자료형과 참조 자료형의 차이점에 대해서 정리하는 시간이 있었는데 이 개념을 모르는 사람도 이해할 수 있도록 쉽게 설명해보려고 했다. 다른 사람의 정리되어있는 글을 보고 그대로 적으면 머리속에 하나도 남지않는다는 걸 알면서도 나만의 언어로 정리하는 것에 어려움을 느껴 결국 정리된 글을 보면 책의 내용을 그대로 남겨놓을 때가 많다.</p>
<p>이번에 정리한 것처럼 글이 많이 부족해 보이고 어설퍼 보여도 내가 이해한만큼 적어놓는 것이 좋은 것 같다. 나중에 봤을 때 부족하다면 또 채워넣으면 되니까! 👍🏻</p>
<h3 id="아쉬운-점은-무엇이-있을까"><a href="#아쉬운-점은-무엇이-있을까" class="headerlink" title="아쉬운 점은 무엇이 있을까?"></a>아쉬운 점은 무엇이 있을까?</h3><p>일반 함수(함수 선언문, 함수 표현식), 화살표 함수는 확실한 차이점이 있다. 자바스크립트 딥다이브를 공부하면서도 봤던 내용인데 어렴풋이 기억만 나고 정확하게 설명을 하지 못한다. 이 부분에 대해서 ‘원시 자료형과 참조 자료형의 차이점’ 처럼 나의 언어로 정리를 해놓고 싶었는데 이번 주에 공부를 하지 못해 아쉽다.😢</p>
<p>지난주 회고를 작성하면서 다음주에 해야 할 공부 리스트를 적어놓았었는데, 이번 주에 지키지 못한 것들이 많다. 회고때 작성해놓은 공부는 어떻게든 지켜보도록 하자! 아자아자 👏🏻👏🏻</p>
<h3 id="✅-다음-주에-해야-할-것들"><a href="#✅-다음-주에-해야-할-것들" class="headerlink" title="✅ 다음 주에 해야 할 것들"></a>✅ 다음 주에 해야 할 것들</h3><ul>
<li>자바스크립트 Deep Dive 실행 컨텍스트, 클로저 다시 읽어보기</li>
<li>DOM 내용 정리하기</li>
<li>만들고 싶은 토이 프로젝트 생각해보기</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>커링(Currying) 함수에 대해서 정복해보자 🦖</title>
    <url>/2023/230303-archive/</url>
    <content><![CDATA[<h1 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h1><p>클로저를 공부하는데 커링이라는 개념이 나왔다.😱 커링이 도대체 뭐야…</p>
<p>여태 공부하면서 들어본 적 없는데 개념이라 정리를 해놔야겠다라는 생각이 들었다!</p>
<h2 id="🙋🏻‍♂️-커링-Currying-함수란"><a href="#🙋🏻‍♂️-커링-Currying-함수란" class="headerlink" title="🙋🏻‍♂️ 커링(Currying) 함수란?"></a>🙋🏻‍♂️ 커링(Currying) 함수란?</h2><p>간단하게 말하자면, 여러 개의 인자를 가지는 함수를 하나의 인자를 받는 함수로 분해하는 것.</p>
<p>함수의 인수를 부분적으로 적용할 수 있는 함수를 구성하는 방법이다. 즉, 함수가 예상하는 모든 인수를 전달하고 결과를 얻거나, <strong>인수의 하위 집합을 전달하고 나머지 인수를 기다리는 함수를 반환할 수 있다.</strong></p>
<p>Haskell and Scala과 같은 함수형 개념을 중심으로 구축된 언어에서는 기본적으로 내장되어 있지만, 자바스크립트는 내장되어있지 않다. 하지만 자바스크립트도 커링을 구현할 수 있다.</p>
<h2 id="🙋🏻-커링이-무엇인지-이해해보자"><a href="#🙋🏻-커링이-무엇인지-이해해보자" class="headerlink" title="🙋🏻 커링이 무엇인지 이해해보자."></a>🙋🏻 커링이 무엇인지 이해해보자.</h2><p>어떻게 작동하는지 이해하기 위해 누군가에게 인사하는 함수를 만들어보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greet = <span class="keyword">function</span> (<span class="params">greeting, name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;,&#x27;</span> + name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Jaerin&#x27;</span>); <span class="comment">// Hello, Jaerin</span></span><br></pre></td></tr></table></figure>

<p>👉🏻 이 함수가 제대로 동작하려면 이름과 인사말을 모두 인수로 전달해야한다.</p>
<p>간단한 중첩 커링을 사용하여 함수를 재작성하면 기본 함수에는 인사말만 필요하고 인사하려는 사람의 이름을 받는 다른 함수를 반환하도록 할 수 있다.</p>
<h3 id="First-Curry"><a href="#First-Curry" class="headerlink" title="First Curry"></a>First Curry</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> grretCurried = <span class="keyword">function</span> (<span class="params">greeting</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + <span class="string">&#x27;,&#x27;</span> + name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수를 작성하는 방식을 조금 조정하면 인사말 유형의 함수를 하나 만들고, 새 함수에 인사말을 건네고자 하는 이름을 전달할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greetHello = <span class="title function_">greetCurried</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="title function_">greetHello</span>(<span class="string">&#x27;Heidi&#x27;</span>); <span class="comment">//&quot;Hello, Heidi&quot;</span></span><br><span class="line"><span class="title function_">greetHello</span>(<span class="string">&#x27;Eddie&#x27;</span>); <span class="comment">//&quot;Hello, Eddie&quot;</span></span><br></pre></td></tr></table></figure>

<p>또한 각 매개변수를 괄호 안에 하나씩 전달하여 원래 <code>greetCurried</code> 함수를 호출할 수도 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">greetCurried</span>(<span class="string">&#x27;Hi there&#x27;</span>)(<span class="string">&#x27;Howard&#x27;</span>); <span class="comment">//&quot;Hi there, Howard&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Curry-All-the-Things"><a href="#Curry-All-the-Things" class="headerlink" title="Curry All the Things!"></a>Curry All the Things!</h3><p>멋진 점은 이제 인수를 처리하는 데 이 접근 방식을 사용하도록 기존 함수를 수정하는 방법을 배웠으므로 원하는 만큼의 인수를 사용하여 이 작업을 수행할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greetDeeplyCurried = <span class="keyword">function</span> (<span class="params">greeting</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">separator</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">emphasis</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + separator + name + emphasis);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>위 예제에서 네 개의 인자를 사용했다. 중첩된 횟수와 상관없이 <code>name</code> 파라미터를 바꿔 새 함수를 만들어 보자.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greetAwkwardly = <span class="title function_">greetDeeplyCurried</span>(<span class="string">&#x27;Hello&#x27;</span>)(<span class="string">&#x27;...&#x27;</span>)(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="title function_">greetAwkwardly</span>(<span class="string">&#x27;Heidi&#x27;</span>); <span class="comment">//&quot;Hello...Heidi?&quot;</span></span><br><span class="line"><span class="title function_">greetAwkwardly</span>(<span class="string">&#x27;Eddie&#x27;</span>); <span class="comment">//&quot;Hello...Eddie?&quot;</span></span><br></pre></td></tr></table></figure>

<p>curried 함수의 <code>()</code>안 파라미터들을 바꿔 함수를 커스터마이징할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHello = <span class="title function_">greetDeeplyCurried</span>(<span class="string">&#x27;Hello&#x27;</span>)(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;.&#x27;</span>)(<span class="string">&#x27;Heidi&#x27;</span>); <span class="comment">//&quot;Hello, Heidi.&quot;</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;.&#x27;</span>)(<span class="string">&#x27;Eddie&#x27;</span>); <span class="comment">//&quot;Hello, Eddie.&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> askHello = <span class="title function_">sayHello</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line"><span class="title function_">askHello</span>(<span class="string">&#x27;Heidi&#x27;</span>); <span class="comment">//&quot;Hello, Heidi?&quot;</span></span><br><span class="line"><span class="title function_">askHello</span>(<span class="string">&#x27;Eddie&#x27;</span>); <span class="comment">//&quot;Hello, Eddie?&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="🙋🏻‍♀️-커링을-사용하는-이유가-뭘까"><a href="#🙋🏻‍♀️-커링을-사용하는-이유가-뭘까" class="headerlink" title="🙋🏻‍♀️ 커링을 사용하는 이유가 뭘까?"></a>🙋🏻‍♀️ 커링을 사용하는 이유가 뭘까?</h2><p>어떤 함수를 호출할 때 대부분의 매개 변수가 항상 비슷할 때 유용하게 쓸 수 있다. 특히 매우 상세한 사용자 정의 함수를 많이 만들어야 하는 경우 유용하다!</p>
<p>그러나 유일한 문제는 구문. 이러한 <code>curried</code> 함수를 구축할 때 <strong>반환된 함수를 계속 중첩</strong>하고, 각각 독립된 인수를 포함하는 여러 괄호 집합이 필요한 <strong>새 함수를 사용하여 호출</strong>해야 하기 때문에 지저분해질 수 있다.</p>
<p>따라서 함수의 이름과 인자만 가지고 사용할 수 있는 currying 함수를 만들어 사용하면 된다. currying 함수는 사용되는 함수의 인자 목록을 추출해, 원본 함수에 커링한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curryIt = <span class="keyword">function</span>(<span class="params">uncurried</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> parameters = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> uncurried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, parametes.<span class="title function_">concat</span>(</span><br><span class="line">				<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">0</span>)</span><br><span class="line">			));</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>첫 번째 할 일은 지금까지 입력 받은 모든 인자를 복사하는 것이다.</p>
<p>Array#slice 메소드를 이용해 ,arguments의 사본을 <code>parameters</code>라는 변수에 저장한다. 또한 이 추가되는 인자를 parameters에 다시 저장해야 한다.</p>
<p><code>curryIt()</code> 함수 사용을 위해서는 <code>()</code> 내 함수 이름과 인자를 차례로 넣어 선언해야한다. 빠진 인자는 재 선언하여 출력할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeter = <span class="keyword">function</span> (<span class="params">greeting, separator, emphasis, name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting + separator + name + emphasis);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> greetHello = <span class="title function_">curryIt</span>(greeter, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;, &#x27;</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="title function_">greetHello</span>(<span class="string">&#x27;Heidi&#x27;</span>); <span class="comment">//&quot;Hello, Heidi.&quot;</span></span><br><span class="line"><span class="title function_">greetHello</span>(<span class="string">&#x27;Eddie&#x27;</span>); <span class="comment">//&quot;Hello, Eddie.&quot;</span></span><br></pre></td></tr></table></figure>

<p>원본 curring 함수에서 파생된 함수를 만들 때 인자의 사용은 자유롭다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greetGoodbye = <span class="title function_">curryIt</span>(greeter, <span class="string">&#x27;Goodbye&#x27;</span>, <span class="string">&#x27;, &#x27;</span>);</span><br><span class="line"><span class="title function_">greetGoodbye</span>(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>); <span class="comment">//&quot;Goodbye, Joe.&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Getting-Serious-about-Currying"><a href="#Getting-Serious-about-Currying" class="headerlink" title="Getting Serious about Currying"></a>Getting Serious about Currying</h3><p>작은 currying 함수는 누락되거나 선택적 매개 변수와 같은 모든 엣지 경우를 처리하지 못할 수도 있겠지만, 인자를 전달하는 구문은 매우 엄격함으로 수행하는데 문제가 없다.</p>
<p><strong>Ramda</strong>와 같은 일부 함수형 자바스크립트 라이브러리에는 함수에 필요한 매개 변수를 구분할 수있는 보다 유연한 커링 함수들이 있으며, 개별적으로 또는 그룹으로 전달하여 변형된 커링 함수를 만들 수 있다.</p>
<p>currying을 광범위하게 사용하려면 <strong>라이브러리를 사용하는 것이 좋다.</strong> <em>커링 함수에 일관된 네이밍 규칙을 적용하면, 코드 가독성이 높아진다.</em> 함수에서 파생된 또다른 함수들은 작동방식이 매우 명확해야하며, 어떤 인자가 들어오는지 알 수 있어야 한다.</p>
<h3 id="Argument-Order"><a href="#Argument-Order" class="headerlink" title="Argument Order"></a>Argument Order</h3><p>커링 함수에서 인자의 순서는 매우 중요하다. 인수의 순서를 미리 생각하면 커링 함수를 계획하고 적용하기가 더 수월해진다. 앞에 있는 인자일 수록 변동가능성이 적다. 반대로 뒤에 있는 인자일수록 변동가능성이 높다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>Currying은 함수형 자바스크립트에서 매우 유용한 기술이다. 일관성있고 사용하기 쉬운 코드는 이해도도 높기 때문에 커링함수로 작은 라이브러리도 구현해 볼 수 있다. 전체 코드에 currying을 도입함으로 함수 인자 네이밍과 처리하는 방법에 많은 도움이 될 것이다.</p>
<hr>
<h3 id="📚-참고자료"><a href="#📚-참고자료" class="headerlink" title="📚 참고자료"></a>📚 참고자료</h3><ul>
<li><a href="https://www.sitepoint.com/currying-in-functional-javascript/">https://www.sitepoint.com/currying-in-functional-javascript/</a></li>
<li><a href="https://ko.javascript.info/currying-partials">https://ko.javascript.info/currying-partials</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>fnm(Fast Node Manager) 환경 변수 에러 해결하기 (부제: 돌고돌아 원점으로🐋)</title>
    <url>/2023/230307-archive/</url>
    <content><![CDATA[<p>프로젝트 개발 환경 세팅하는 방법에 대해서 공부를 하고 있는데, node 버전 관리를 nvm 대신 fnm으로 세팅해보는 시간을 가졌다.</p>
<p>간단히 말하자면 둘 다 Ndoe.js의 버전 관리 도구이다.</p>
<ul>
<li>fnm은 Rust 기반으로 만들어져 성능이 더 빠르다. (Rust로 만들면 왜 더 빠른건지?)</li>
<li>nvm은 전역적으로 버전을 관리하고 fnm은 프로젝트마다 버전을 관리한다.</li>
<li>사용자 커뮤니티는 nvm이 더 큰 편. fnm은 상대적으로 최신기술이라 사용자 수가 적다.</li>
</ul>
<p>강의 내용을 따라가면서 fnm을 설치하고 ~&#x2F;.zshrc에 변수를 추가해주는 것까지는 문제가 없었는데..</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">brew install fnm</span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;$(fnm env)&quot;</span></span><br></pre></td></tr></table></figure>

<p>LTS를 설치하고 <code>fnm use lts-latest</code> 최신 LTS를 쓰겠다는 명령어를 입력하자마자 오류가 발생했다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">fnm install --lts</span><br><span class="line">fnm use lts-latest</span><br><span class="line">fnm <span class="keyword">default</span> $(fnm current)</span><br></pre></td></tr></table></figure>

<p><img src="/../img/230307/230306-1.png"></p>
<blockquote>
<p>error: We can’t find the necessary environment variables to replace the Node version. <em>You should setup your shell profile to evaluate <code>fnm env</code>, see <a href="https://github.com/Schniz/fnm#shell-setup">https://github.com/Schniz/fnm#shell-setup</a> on how to do this Check out our documentation for more information: <a href="https://fnm.vercel.app/">https://fnm.vercel.app</a></em></p>
</blockquote>
<p>👉🏻 필요한 환경 변수를 찾지 못한다는 에러 메세지</p>
<p>우리의 친절한 에러 메세지는</p>
<p>‘💬 <a href="https://github.com/Schniz/fnm#shell-setup">https://github.com/Schniz/fnm#shell-setup</a> 여기로 가서 shell-setup 한 번 해봐’ 라고 답해주었다.</p>
<p>이때부터 시작된 나의 삽질,,,</p>
<h3 id="첫-번째-시도"><a href="#첫-번째-시도" class="headerlink" title="첫 번째 시도"></a>첫 번째 시도</h3><p>하라면 일단 가보는 게 인지상정. 내용을 읽어보니,</p>
<p><img src="/../img/230307/230307-2.png" alt="스크린샷 2023-03-07 오후 5.20.26.png"></p>
<p>fnm을 사용하기 전에 환경 변수 세팅을 할 필요가 있다네..?</p>
<p>그래서 원래 작성한 코드 <code>eval “$(fnm env)”</code> 에서 <code>eval &quot;$(fnm env --use-on-cd)&quot;</code> 로 변경</p>
<p>다시 확인을 해봤는데..?!</p>
<p><img src="/../img/230307/230306-1.png"></p>
<p>여전히 동일한 에러를 띄운다😢</p>
<p>GitHub 페이지에서도 환경 변수 에러와 관련된 내용은 이것밖에 없는 것 같고, fnm을 사용하는 커뮤니티도 많이 없는 것 같았다. 아무리 구글링해도 나오지가 않아…</p>
<h3 id="두-번째-시도"><a href="#두-번째-시도" class="headerlink" title="두 번째 시도"></a>두 번째 시도</h3><p>나와 동일한 문제를 겪고 있는 사람이 GitHub Issue에 남겨놓지 않았을까..? 라는 마음으로 찾아봤다.</p>
<p><a href="https://github.com/Schniz/fnm/issues/803">https://github.com/Schniz/fnm/issues/803</a></p>
<p>정확하게 이해하진 못했지만, brew로 설치를 했다면 경로 설정이 필요하다는 답변이 달린 것을 보았다! (이거 나잖아..?)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">-# <span class="variable constant_">FNM</span></span><br><span class="line">-<span class="built_in">eval</span> <span class="string">&quot;$(fnm env --use-on-cd)&quot;</span></span><br><span class="line"></span><br><span class="line"># <span class="title class_">Homebrew</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span>=<span class="string">&quot;/opt/homebrew/bin:/opt/homebrew/sbin:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line">+# <span class="variable constant_">FNM</span></span><br><span class="line">+<span class="built_in">eval</span> <span class="string">&quot;$(fnm env --use-on-cd)&quot;</span></span><br></pre></td></tr></table></figure>

<p>똑같이 해본 결과는..?! 여전히 실패…🤦🏻‍♀️</p>
<h3 id="그런데-갑자기-머리를-스치듯-지나가는-생각-한-가지"><a href="#그런데-갑자기-머리를-스치듯-지나가는-생각-한-가지" class="headerlink" title="그런데 갑자기 머리를 스치듯 지나가는 생각 한 가지"></a>그런데 갑자기 머리를 스치듯 지나가는 생각 한 가지</h3><p>혹시.. 저장하고 iterm을 껐다키지 않아서 그런건가..?</p>
<p>바로 이전 상태로 되돌려놓고 프로그램 종료 후 다시 실행시켜보니</p>
<p><img src="/../img/230307/230307-1.png" alt="스크린샷 2023-03-07 오후 5.35.44.png"></p>
<p>아니 이게 왠걸.. 에러 없이 정상적으로 작동하는 것을 확인할 수 있었다.</p>
<p>항상 뭐가 안될 땐, 수정된 내용들이 정상적으로 반영이 되었는지 확인을 해보고 구글링을 해보자… 10분이면 끝날 작업을 2시간 동안 쩔쩔맸다.</p>
<p><img src="https://i.pinimg.com/originals/f0/4a/f5/f04af508057d51dd3875e0598f4ac4a5.png" alt="https://i.pinimg.com/originals/f0/4a/f5/f04af508057d51dd3875e0598f4ac4a5.png"></p>
<p>그래도 때려치고 누군가에게 물어보려고 하지 않고 스스로 해결했다는 점에서 스스로를 위안해본다!</p>
]]></content>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 4주차 주간회고 (부제: section1을 마치며👍🏻)</title>
    <url>/2023/230312-archive-1/</url>
    <content><![CDATA[<p>코드스테이츠 프론트엔드 코스를 수강한지 4주가 지났다. section1이 벌써 끝나다니..😱 시간이 너무 빠르게 흐르는 듯하다. 한 달동안의 나는 무엇을 얻었으며 무엇을 놓치고 있었나</p>
<p><img src="https://mblogthumb-phinf.pstatic.net/MjAxNzA1MDNfNyAg/MDAxNDkzNzkxNDAzOTgx.o3hAQgk7Vu8xkmb-FuEorJ_GFjUE33a6WOrDQOSDaPQg.aONcnNUb4UI0qRi0_PVGm0-UYKb2DgIeevnj7jbKs6Ug.JPEG.goodp2595/18157068_1985238571710653_5016494553600520577_n.jpg?type=w800" alt="image"></p>
<p>처음 시작할 때의 내 다짐이 뭐였는지 되돌아가보자. 나는 개발자가 되기 위해 무엇을 실천하려고 했었지?</p>
<blockquote>
<p><em>모르는 내용을 질문하는 것에 대해서 두려워하지 않기</em></p>
<p><em>공부하는 시간엔 공부에 집중하기</em></p>
<p><em>여러 사람과 이야기를 나누고 그 과정 속에서 어떻게 하면 더 좋은 의사소통을 할 수 있을지 고민하기</em></p>
</blockquote>
<p>그래서 실천 잘했나라고 스스로에게 물어본다면 하나도 못했다고 자신있게 얘기할 수 있을 것 같다.</p>
<h2 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h2><p>그래도 그나마 내가 잘해왔고 계속 해나갔으면 하는 것들이 무엇이 있을까 생각해보면,</p>
<ul>
<li>주말에 새벽알바를 하고 있는데 밤낮이 자주 바뀜에도 불구하고, 생활 패턴을 잘 지켰다.</li>
<li>내가 알고있는 지식을 공유하기 위해 스터디를 가입했다.</li>
<li>주간회고를 작성하는 것. 매주 무엇을 했는지 상기시키면서 한 번씩 정리한 내용을 볼 수 있는 장점이 있다.</li>
</ul>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><ul>
<li>집중을 너무 못했다.</li>
<li>최소 기준을 통과하면 더 이상 하고싶지 않아서 멈춘적이 많다.<ul>
<li>과제 Bare Minimum을 충족시키고 나면, Advanced Challenge를 해야하는데 더 나아가지 않고 멈추는 일이 많았다.🥲</li>
</ul>
</li>
</ul>
<h2 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h2><p>문제들을 해결하기 위해선 어떻게 해결해야할까?</p>
<ul>
<li>하루에 커밋 한개는 올려보자. 키보드에 손을 올리면 집중을 계속할 수 있지 않을까?</li>
<li>계속해서 어려운 부분에 부딪히자. 실력을 키우려면 고난과 역경을 마주해야한다는 거 잊지 말자.</li>
<li>누군가에게 개념에 대해서 알려줄 때 더 간결하게 말하는 연습을 하자.</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>메가테라 프론트엔드 생존코스 2주차 주간회고</title>
    <url>/2023/230318-1-archive/</url>
    <content><![CDATA[<h2 id="React에-대한-근-본을-이해하는-시간"><a href="#React에-대한-근-본을-이해하는-시간" class="headerlink" title="React에 대한 근-본을 이해하는 시간"></a>React에 대한 근-본을 이해하는 시간</h2><p>이번 주에는 React를 JSX 없이 만들어보는 시간이었다. 새롭게 알게 된 것은 리액트 이외에서도 JSX를 쓸 수 있다는 것이었다. 리액트에서만 봤으니까 리액트에서만 쓰는 건 줄 알았는데 내 지식의 폭이 한없이 좁고 얕다는 걸 또 한 번 깨달은 시간이다.</p>
<p>순수 자바스크립트로 리액트를 만들어보니 JSX의 소중함을 알게 되었다. JSX 없이 React.createElement로 코드를 작성하면 코드를 봤을 때 어떤 구조의 컴포넌트를 만들어낸건지 한 번에 이해하기가 너무 어려웠다. 여기서 왜 JSX가 Sytactic sugar로써 등장했는지 알 수 있었다. JSX를 사용하면 HTML과 비슷한 구조를 가지고 있기 때문에 무엇이 화면에 렌더링 되겠다가 한 눈에 보이는 마법을 경험했다. 역시 불편함을 먼저 겪어보고 편함을 경험해야 이게 왜 편한지를 알 수 있다. 2주차 강의는 정말 도움이 많이 되었는데, 그 이유는 내가 직접 만들고 비교를 해보면서 ‘선언적 API를 가능하게 한다’의 의미가 무엇인지 스스로 이해할 수 있기 때문이다.</p>
<h2 id="1주차에-계획했던-내용은-잘-지켰을까"><a href="#1주차에-계획했던-내용은-잘-지켰을까" class="headerlink" title="1주차에 계획했던 내용은 잘 지켰을까?"></a>1주차에 계획했던 내용은 잘 지켰을까?</h2><p>1주차 회고에 2주차엔 어떻게 살아야할지 목표를 적어놓은 것들이 있는데,</p>
<ul>
<li>나에게 시간은 너무 소중하다. 낭비하는 거 없이 잘 사용하자.</li>
<li>강의가 올라오면 데브노트를 작성하기 전에 먼저 강의를 전체적으로 보자. 흐름이 중요하니까</li>
<li>강의에서 나온 코드들을 보지 않고도 작성할 수 있을만큼 손으로 코드를 많이 작성해보자.</li>
</ul>
<p>이렇게 세 가지였다. 잘 지켰나? 되돌아보자.🤔</p>
<p>시간은 낭비하지 않고 잘 사용한 것 같다. 강의를 먼저 보고 그 다음에 데브노트 작성할 때 한 번 더 봤는데 반복해서 보니 첫 번째 봤던 것보다 더 많은 내용을 이해할 수 있었고 데브노트에 이해한 내용들을 작성할 수 있어서 좋았다. 지키지 못한 건 손으로 코드를 많이 작성해보고 싶었는데 조금밖에 하지 못한 것. 3회차엔 꼭 지킬 수 있도록 해야지.</p>
<p>회고를 쓰니 한 주를 잘 보내고 있는지, 부족했던 것과 잘 지켜나갔는지에 대해서 확인할 수 있어서 도움이 된다. 메가테라를 하면서 좋은 습관으로 만들고 싶다.</p>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>Megaptera</tag>
      </tags>
  </entry>
  <entry>
    <title>메가테라 프론트엔드 생존코스 1주차 주간회고</title>
    <url>/2023/230312-archive/</url>
    <content><![CDATA[<p><img src="https://megaptera.kr/preview.png?dc076017d09a6a13c8be433e235f414b" alt="megaptera"></p>
<h2 id="시작이-가장-어려운-법"><a href="#시작이-가장-어려운-법" class="headerlink" title="시작이 가장 어려운 법"></a>시작이 가장 어려운 법</h2><p>3월 8일부터 메가테라 프론트엔드 생존코스를 시작했다. 한 번 결정하면 실행속도가 빠르지만, 그 전까지 어떤 선택이든 신중하게 결정하려는 나로서는 이 코스를 시작하는데도 많은 고민을 했었다. 제일 크게 고민했던 부분은 ‘내가 이것까지 할 수 있는 체력이 있을까?’였는데 그 이유는 주말 알바도 하고 있고 이미 코드스테이츠 프론트엔드 부트캠프를 진행하고 있었기 때문이다.</p>
<p>일정 상 코드스테이츠는 초반에 신경써야할 부분들이 적고, 메가테라 코스가 끝나면 코드스테이츠도 리액트를 시작하는 일정이었기 때문에 나에게 도움이 될 것 같아서 문제가 없다고 판단했다. (아르바이트는 그만두기로 결정했다. 새벽 타임 알바인데 이렇게 살다간 한 달안에 죽겠다라는 느낌을 확실하게 받았다. 공부를 하기위해서 돈을 버는거였는데 돈을 버느라 공부를 놓치고 있구나라는 생각이 들었다.😢)</p>
<p>시작했으면 끝은 봐야하지 않겠는가. 메가테라에서 공부하는 동안에는 커넥to에서 공부했던 것처럼 스스로를 한계까지 몰아넣어보자. 6월의 한참 성장해있을 나를 상상하면서!</p>
<h2 id="데브노트-이렇게-써도-되나"><a href="#데브노트-이렇게-써도-되나" class="headerlink" title="데브노트, 이렇게 써도 되나?"></a>데브노트, 이렇게 써도 되나?</h2><p>1주차에서 가장 힘든 부분이 데브노트였다. 혼자 공부하면서 강의 정리를 해본 적은 있지만 GitBook에 강의 내용을 정리하고, 강의를 보다가 모르는 개념에 대해서 더 깊게 공부하고 정리한 경험은 전무했다. 어떤 방식으로 정리를 해야할지 감이 오지 않아서 시간을 많이 잡아먹었던 것 같다.</p>
<p>쓸 때마다 계속해서 든 생각은‘이렇게 써도 되나?’였다. 데브노트를 제출하고 누군가는 내 정리한 내용을 본다고 생각해서 그랬던 것 같다. 그러다 문득 ‘데브노트는 내가 보려고 쓰는거 아닌가? 내가 나중에 봤을 때 이해하기 쉽게 정리하는게 맞지!’ 이런 생각을 하게 됐고 그 때부터 속도가 붙었다. 잘못된 길을 가고있다면 바로 잡아줄 사람들이 있으니까 일단 써보자.</p>
<h2 id="1주차엔-무엇을-배웠나"><a href="#1주차엔-무엇을-배웠나" class="headerlink" title="1주차엔 무엇을 배웠나"></a>1주차엔 무엇을 배웠나</h2><p>1주차는 개발 환경 세팅하는 방법에 대해서 배웠다. 생각해보면 다른 사람이 만들어놓은 레포지토리를 가져와서 사용해봤지 내가 스스로 환경을 세팅해본 적은 없다는걸 깨달았다. 이번 기회를 통해서 어떻게 모듈이 실행되는지 테스팅 도구들은 어떻게 사용하는지에 대해서 배울 수 있었다.</p>
<p>또한 타입스크립트 개념에 대해서 배우는 시간이었다. 물론 하나하나 자세히 보지는 못했지만 하나씩 공부해나가야지.</p>
<p>1주차 과제는 계속해서 사용할 수 있는 개발 환경 설정 문서를 만드는 것이었는데, 강의 내용대로 하면 되겠지 싶었는데 CI 테스트에서 계속 실패하면서 이거 생각보다 어렵구나 생각했다. 린트 설정에서만 5번 실패했다.<br><img src="/../img/230312/230312-1.png" alt="."><br>여러 번의 시도 끝에 통과한 건 좀 아쉽지만, 오류가 났을 때 이게 무슨 오류이고 어떻게 해결해야하는지에 대해서 배운 것 같아서 뿌듯하다.</p>
<h2 id="2주차에는-어떻게-살아야할까"><a href="#2주차에는-어떻게-살아야할까" class="headerlink" title="2주차에는 어떻게 살아야할까"></a>2주차에는 어떻게 살아야할까</h2><ul>
<li>나에게 시간은 너무 소중하다. 낭비하는 거 없이 잘 사용하자.</li>
<li>강의가 올라오면 데브노트를 작성하기 전에 먼저 강의를 전체적으로 보자. 흐름이 중요하니까</li>
<li>강의에서 나온 코드들을 보지 않고도 작성할 수 있을만큼 손으로 코드를 많이 작성해보자.</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>Megaptera</tag>
      </tags>
  </entry>
  <entry>
    <title>클래스(Class)</title>
    <url>/2023/230318-2-archive/</url>
    <content><![CDATA[<p>자바스크립트는 ES5 이전에도 클래스 키워드 없이 상속을 구현할 수 있었다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 생성자 함수</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Person</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 생성자 함수</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메서드</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수 변환</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Person</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line">me.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>ES6에서 클래스를 도입했지만 내부 동작은 크게 다르지 않다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi! My name is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> you = <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line">you.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>console.dir로 me와 you를 확인해보면</p>
<p><img src="/../img/230318/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-03-15%20%EC%98%A4%EC%A0%84%2010.47.55.png" alt="스크린샷 2023-03-15 오전 10.47.55.png"></p>
<p><img src="/../img/230318/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202023-03-15%20%EC%98%A4%EC%A0%84%2010.48.17.png" alt="스크린샷 2023-03-15 오전 10.48.17.png"></p>
<p>생김새가 거의 유사하다는걸 볼 수 있다.</p>
<p>큰 차이점이라면 constructor가 생성자 함수이냐 클래스이냐의 차이가 존재한다.</p>
<h3 id="그렇다면-클래스라는게-특별한게-아니라-프로토타입을-좀-더-쉽게-쓰기-위해서-만들어놓은-문법적-설탕-Syntax-Sugar-인건가"><a href="#그렇다면-클래스라는게-특별한게-아니라-프로토타입을-좀-더-쉽게-쓰기-위해서-만들어놓은-문법적-설탕-Syntax-Sugar-인건가" class="headerlink" title="그렇다면 클래스라는게 특별한게 아니라 프로토타입을 좀 더 쉽게 쓰기 위해서 만들어놓은 문법적 설탕(Syntax Sugar)인건가?"></a>그렇다면 클래스라는게 특별한게 아니라 프로토타입을 좀 더 쉽게 쓰기 위해서 만들어놓은 문법적 설탕(Syntax Sugar)인건가?</h3><p>그러나 클래스에는 다른 내용이 존재한다.</p>
<ol>
<li>new 연산자 없이 호출하면 에러가 발생한다.</li>
<li>extends와 super 키워드를 제공한다.</li>
<li>호이스팅이 발생하지 않는 것처럼 동작한다. (하지만 호이스팅은 발생한다. TDZ에 걸리는 것뿐)</li>
<li>모든 코드에는 암묵적으로 strict mode가 지정되어 실행된다.</li>
<li>클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다. 👉🏻 즉, 열거되지 않는다.</li>
</ol>
<h3 id="클래스-정의하는-방법"><a href="#클래스-정의하는-방법" class="headerlink" title="클래스 정의하는 방법"></a>클래스 정의하는 방법</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>클래스는 함수다. 즉 값처럼 사용할 수 있는 일급 객체다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 클래스 선언문</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// name 프로퍼티는 public하다.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메서드</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 정적 메서드</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 프로퍼티 참조</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">name</span>); <span class="comment">// Lee</span></span><br><span class="line"><span class="comment">// 프로토타입 메서드 호출</span></span><br><span class="line">me.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is Lee</span></span><br><span class="line"><span class="comment">// 정적 메서드 호출</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sayHello</span>(); <span class="comment">// Hello!</span></span><br><span class="line">me.<span class="title function_">sayHello</span>();</span><br></pre></td></tr></table></figure>

<p>프로토타입 메서드와 정적 메서드의 차이는?</p>
<p><code>console.dir(Person)</code> 을 열어보면 sayHi 메서드는 prototype에 들어가있고, sayHello는 Person의 프로퍼티로 들어가있는 것을 볼 수 있다.</p>
<p>그렇다는 말은 me.sayHi는 호출이 가능하지만 me.sayHello는 호출이 되지 않는다는 말과 동일하다. 👉🏻 <code>Person.sayHello()</code> 로 호출해야한다.</p>
<p>그럼 정적 메서드는 언제 사용할까?</p>
<p>클래스 내에서 메서드가 필요한 경우가 있다. 이때는 인스턴스를 생성하기 전에 메서드를 사용하는 것이기 때문에 프로토타입 메서드로 만들지 않아도 된다. 이럴 때 정적 메서드를 사용한다.</p>
<p>생성자 함수는 new 없이도 실행이 가능하다. new 없이 실행하면 일반함수로 실행된다.</p>
<h3 id="하지만-클래스는-new-없이-실행하려고-하면-에러가-발생한다"><a href="#하지만-클래스는-new-없이-실행하려고-하면-에러가-발생한다" class="headerlink" title="하지만 클래스는 new 없이 실행하려고 하면 에러가 발생한다."></a>하지만 클래스는 new 없이 실행하려고 하면 에러가 발생한다.</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스를 new 연산자 없이 호출하면 타입 에러가 발생한다.</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="클래스-메서드"><a href="#클래스-메서드" class="headerlink" title="클래스 메서드"></a>클래스 메서드</h3><p>클래스 메서드 👉🏻 constructor, prototype method, static method</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>: 인스턴스를 생성하고 초기화하기 위한 특수한 메서드</p>
<ul>
<li><p>클래스는 평가되어 함수 객체가 된다.</p>
</li>
<li><p>모든 함수 객체는 prototype 프로퍼티를 가지고 있다. 이 prototype 프로퍼티가 가리키는 객체 안의 constructor 프로퍼티는 클래스 자신을 가리키고 있다. 👉🏻 즉, 클래스가 인스턴스를 생성하는 생성자 함수다.</p>
</li>
<li><p>new 연산자를 호출하면 클래스는 인스턴스를 생성한다.</p>
</li>
<li><p>클래스 내부에는 한 개의 constructor만 존재해야한다.</p>
</li>
<li><p>constructor를 생략하면 빈 객체의 인스턴스가 생성된다.</p>
</li>
<li><p>별도의 반환문을 갖지 말아야한다. <strong>return문 반드시 생략</strong></p>
<ul>
<li>명시적으로 객체를 반환하면 return 문에 명시한 객체가 반환된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 명시적으로 다른 객체를 반환하면 빈 객체 반환</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 대신에 빈 객체가 반환된다.</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="prototype-method"><a href="#prototype-method" class="headerlink" title="prototype method"></a>prototype method</h3><p>생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// me 객체의 프로토타입은 Person.prototype이다.</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(me) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// -&gt; true</span></span><br><span class="line">me <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.prototype의 프로토타입은 Object.prototype이다.</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// -&gt; true</span></span><br><span class="line">me <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// me 객체의 constructor는 Person 클래스다.</span></span><br><span class="line">me.<span class="property">constructor</span> === <span class="title class_">Person</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h3 id="static-method"><a href="#static-method" class="headerlink" title="static method"></a>static method</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 정적 메서드</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>우리는 정적메서드를 본 적이 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표준 빌트인 객체의 메서드</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title class_">Stringify</span>(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;); <span class="comment">// &quot;&#123; &quot;a&quot; : 1 &#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>Math 함수는 this를 사용해서 뭔가를 계산하는 것이 아니라 인수로 받은 값들을 가지고 처리한다. <em>(사실상 함수와 다름없다.)</em></p>
<h3 id="클래스에서-정의한-메서드의-특징"><a href="#클래스에서-정의한-메서드의-특징" class="headerlink" title="클래스에서 정의한 메서드의 특징"></a>클래스에서 정의한 메서드의 특징</h3><ol>
<li>function 키워드를 생략한 <strong>메서드 축약 표현</strong>을 사용한다. 👉🏻 내부적으로 constructor를 갖지 않는 non-constructor이다. <em>(5번 참고)</em></li>
<li>객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 <strong>콤마가 필요 없다.</strong></li>
<li>암묵적으로 strict mode로 실행된다.</li>
<li>열거 가능 여부를 나타내며 불리언 값을 갖는 프로퍼티 어트리뷰트 <strong>[[Enumerable]]의 값이 false</strong>이다.</li>
<li>내부 메소드 [[Construct]]를 갖지 않는 non-constructor이다.<ol>
<li>따라서 new 연산자와 함께 호출할 수 없다.</li>
</ol>
</li>
</ol>
<h3 id="클래스의-인스턴스-생성-과정"><a href="#클래스의-인스턴스-생성-과정" class="headerlink" title="클래스의 인스턴스 생성 과정"></a>클래스의 인스턴스 생성 과정</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Person &#123;&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="variable language_">this</span>) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. this에 바인딩되어 있는 인스턴스를 초기화한다.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h3><h3 id="인스턴스-프로퍼티"><a href="#인스턴스-프로퍼티" class="headerlink" title="인스턴스 프로퍼티"></a>인스턴스 프로퍼티</h3><ul>
<li>인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.</li>
<li>constructor 내부에서 정의한 모든 프로퍼티는 public하다.</li>
</ul>
<h3 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h3><ul>
<li>getter, setter 함수</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="comment">// 데이터 프로퍼티</span></span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Ungmo&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fullName은 접근자 함수로 구성된 접근자 프로퍼티다.</span></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 배열 디스트럭처링 할당: &quot;36.1. 배열 디스트럭처링 할당&quot; 참고</span></span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">firstName</span>, <span class="variable language_">this</span>.<span class="property">lastName</span>] = name.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.firstName&#125;</span> <span class="subst">$&#123;person.lastName&#125;</span>`</span>); <span class="comment">// Ungmo Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span></span><br><span class="line">person.<span class="property">fullName</span> = <span class="string">&#x27;Heegun Lee&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;firstName: &quot;Heegun&quot;, lastName: &quot;Lee&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">fullName</span>); <span class="comment">// Heegun Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName은 접근자 프로퍼티다.</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&#x27;fullName&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="클래스-필드-정의"><a href="#클래스-필드-정의" class="headerlink" title="클래스 필드 정의"></a>클래스 필드 정의</h3><p>자바스크립트는 constructor 내부에서 프로퍼티를 정의하기 때문에 모든 프로퍼티가 public하다. 하지만 Java와 같은 언어에선 클래스 필드에서 프로퍼티를 정의할 수 있다.</p>
<p>ES2022부터는 자바스크립트도 클래스 필드에서 정의할 수 있게 되었다.</p>
<ul>
<li>단, 필드에서 정의할 때에는 this를 사용하면 안된다.</li>
<li>참조하는 경우에는 this를 반드시 사용해야 한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line">	name;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>메서드를 화살표함수로 썼을 때의 장점</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;button class=&quot;btn&quot;&gt;0&lt;/button&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increase 메서드를 이벤트 핸들러로 등록</span></span><br><span class="line">    <span class="comment">// 이벤트 핸들러 increase 내부의 this는 DOM요소를 가리킨다.</span></span><br><span class="line">    <span class="comment">// 하지만 increase 함수는 화살표함수로 정의되어 있으므로</span></span><br><span class="line">    <span class="comment">// increase 내부의 this는 인스턴스를 가리킨다.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">onClick</span> = <span class="variable language_">this</span>.<span class="property">increase</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 만약 increase가 화살표 함수가 아니라면 bind를 이용해야한다.</span></span><br><span class="line">    <span class="comment">// this.$button.onClick = this.increase.bind(this);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 인스턴스 메서드</span></span><br><span class="line">  <span class="comment">// 화살표 함수의 this는 언제나 상위 컨텍스트의 this를 가리킨다.</span></span><br><span class="line">  increase = <span class="function">() =&gt;</span> (<span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">textContent</span> = ++<span class="variable language_">this</span>.<span class="property">count</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 화살표 함수가 아니면?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;button class=&quot;btn&quot;&gt;0&lt;/button&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">onClick</span> = <span class="variable language_">this</span>.<span class="property">increase</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">increase</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">textContent</span> = ++<span class="variable language_">this</span>.<span class="property">count</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">App</span>();</span><br></pre></td></tr></table></figure>

<p>클릭했을 때 <code>Cannot set properties of undefined (setting ‘textContent’)</code> 라는 에러가 발생함</p>
<ul>
<li>이유는? 👉🏻 this.increase를 실행했을 때 $button이라는 요소가 undefined이기 때문</li>
<li>왜 undefined인거지? 👉🏻 this 바인딩이 달라졌다는 의미</li>
</ul>
<p>그렇다면 this엔 무엇이 바인딩되었을까?</p>
<ul>
<li>this.increase를 넘긴게 onClick에 콜백함수로 넘긴 것</li>
<li>메서드로 넘어간 게 아니라 <code>this.$button.textContent = ++this.count;</code> 의 내용만 넘어감.</li>
<li><code>this.$button.onClick = **this.increase**;</code> 여기서의 this는 event 객체의 currentTarget, 즉 <code>&lt;button&gt;</code>을 가리키게 된다.</li>
<li>button 태그에 $button이 없기 때문에 undefined가 나올 수밖에 없는 것</li>
</ul>
<p>이전엔 이런 문제를 해결하기 위해 bind를 사용했다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;button class=&quot;btn&quot;&gt;0&lt;/button&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">onClick</span> = <span class="variable language_">this</span>.<span class="property">increase</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 인스턴스 메서드</span></span><br><span class="line">  <span class="comment">// 화살표 함수의 this는 언제나 상위 컨텍스트의 this를 가리킨다.</span></span><br><span class="line">  increase = <span class="function">() =&gt;</span> (<span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">textContent</span> = ++<span class="variable language_">this</span>.<span class="property">count</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this 바인딩을 하지 않는 화살표함수를 사용하면?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="string">`&lt;button class=&quot;btn&quot;&gt;0&lt;/button&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">onClick</span> = <span class="variable language_">this</span>.<span class="property">increase</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  increase = <span class="function">() =&gt;</span> (<span class="variable language_">this</span>.<span class="property">$button</span>.<span class="property">textContent</span> = ++<span class="variable language_">this</span>.<span class="property">count</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>처음 인스턴스를 생성할 때 그 자체가 this가 된다.</p>
<p>인스턴스에 있는 $button에 접근하기 때문에 문제 없이 클릭이벤트가 동작한다.</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking in React 내 마음대로 이해하기🌱 </title>
    <url>/2023/230318-3-archive/</url>
    <content><![CDATA[<blockquote>
<p><em>React can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces called components. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, we’ll guide you through the thought process of building a searchable product data table with React.</em></p>
</blockquote>
<p>React는 <strong>디자인을 바라보는 방식</strong>과 <strong>앱을 빌드하는 방식</strong>을 바꿀 수 있습니다. React로 사용자 인터페이스를 빌드할 때는 먼저 컴포넌트라고하는 조각으로 분해합니다. 그런 다음 각 컴포넌트에 대해 서로 다른 시각적 상태를 설명합니다. 마지막으로 컴포넌트를 서로 연결해 데이터가 흐르도록 합니다. 이 튜토리얼에서는 React로 검색 가능한 데이터 테이블을 구축하는 사고 과정을 안내합니다.</p>
<h2 id="Start-with-the-mockup"><a href="#Start-with-the-mockup" class="headerlink" title="Start with the mockup"></a>Start with the mockup</h2><p>JSON API와 디자이너의 목업이 있다고 가정해보자</p>
<p>JSON API는 다음과 같이 일부 데이터를 반환함</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Fruits&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;stocked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apple&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Fruits&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;stocked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Dragonfruit&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Fruits&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;stocked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Passionfruit&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vegetables&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;stocked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Spinach&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vegetables&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$4&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;stocked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Pumpkin&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vegetables&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;stocked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Peas&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>The mockup looks like this:</p>
<p><img src="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui.png" alt="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui.png"></p>
<p>To implement a UI in React, you will usually follow the same five steps.</p>
<p><em>React에서 UI를 구현하려면 일반적으로 동일한 5단계를 따른다.</em></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Step</span> <span class="number">1</span>: <span class="title class_">Break</span> the <span class="variable constant_">UI</span> into a component hierarchy****</span><br><span class="line"><span class="title class_">Step</span> <span class="number">2</span>: <span class="title class_">Build</span> a <span class="keyword">static</span> version <span class="keyword">in</span> <span class="title class_">React</span></span><br><span class="line"><span class="title class_">Step</span> <span class="number">3</span>: <span class="title class_">Find</span> the minimal but complete representation <span class="keyword">of</span> <span class="variable constant_">UI</span> state</span><br><span class="line"><span class="title class_">Step</span> <span class="number">4</span>: <span class="title class_">Identify</span> where your state should live</span><br><span class="line"><span class="title class_">Step</span> <span class="number">5</span>: <span class="title class_">Add</span> inverse data flow</span><br></pre></td></tr></table></figure>

<br>

<h3 id="Step-1-Break-the-UI-into-a-component-hierarchy"><a href="#Step-1-Break-the-UI-into-a-component-hierarchy" class="headerlink" title="Step 1: Break the UI into a component hierarchy"></a>Step 1: Break the UI into a component hierarchy</h3><p><em>UI 컴포넌트를 계층구조로 나누기</em></p>
<p>목업의 모든 컴포넌트와 하위 컴포넌트 주위에 상자를 그리고 이름을 지정하기. 디자이너와 같이 일한다면 컴포넌트의 이름이 이미 있을 수도 있다.</p>
<p>여러가지 방식으로 컴포넌트를 분할하는 것을 고려할 수 있는데:</p>
<ul>
<li>Programming - 새로운 함수나 객체를 생성할 때에도 동일한 기법 사용하기.<ul>
<li>이러한 기법 중 하나는 <a href="https://www.notion.so/Thinking-in-React-3dc21d2691dd4302957bed94a7e7b582">단일 책임 원칙(single responsibility principle)</a></li>
<li>컴포넌트는 한 가지 일만 수행해야 한다.</li>
<li>컴포넌트가 커지면 더 작은 하위 컴포넌트로 분해해야 한다.</li>
</ul>
</li>
<li>CSS - 클래스 선택자를 어디에 사용할 지 생각하기</li>
<li>Design - 디자인의 레이어를 어떻게 구성할지 생각하기</li>
</ul>
<p>JSON이 잘 구조화되어 있으면 UI 컴포넌트 구조에 자연스럽게 매핑되는 것을 발견할 수 있다. 동일한 형태를 가지고 있는 경우가 많기 때문.</p>
<p>UI를 컴포넌트로 분리하고 각 컴포넌트가 데이터 모델의 한 부분과 일치하도록 해보자</p>
<p><img src="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui_outline.png" alt="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui_outline.png"></p>
<ul>
<li><code>FilterableProductTable</code> 은 전체 app을 포함</li>
<li><code>SearchBar</code> 는 user input을 받음</li>
<li><code>ProductTable</code> 는 사용자 입력에 따라 리스트를 표시하고 필터링 함</li>
<li><code>ProductCategoryRow</code> 는 각 카테고리에 대한 제목을 표시</li>
<li><code>ProductRow</code> 는 각 제품에 대한 행을 표시</li>
</ul>
<p><code>ProductTable</code>을 보면 Name과 Price를 포함하고 있는 헤더가 자체 구성 요소가 아님을 알 수 있다. 👉🏻 <strong>선호도의 문제</strong></p>
<ul>
<li><code>ProductTable</code> 의 목록 안에 표시되므로 <code>ProductTable</code> 의 일부</li>
<li>헤더가 복잡해지는 경우에는 컴포넌트로 따로 분리할 수도 있다.</li>
</ul>
<p>mockup in the hierarchy:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">FilterableProductTable</span><br><span class="line">	SearchBar</span><br><span class="line">	ProductTable</span><br><span class="line">		ProductCategoryRow</span><br><span class="line">		ProductRow</span><br></pre></td></tr></table></figure>

<h3 id="Step-2-Build-a-static-version-in-React"><a href="#Step-2-Build-a-static-version-in-React" class="headerlink" title="Step 2: Build a static version in React"></a>Step 2: Build a static version in React</h3><p><em>React에서 정적 버전 빌드하기</em></p>
<p>정적 버전을 빌드하려면 다른 컴포넌트를 재사용하고 props를 사용하여 데이터를 전달하는 컴포넌트를 빌드하는 것이 좋다.</p>
<ul>
<li>props는 <strong>부모에서 자식으로 데이터를 전달하는 방법</strong></li>
</ul>
<p>계층 구조에서 상위 컴포넌트로부터 빌드하는 “top down” 빌드 또는 하위 컴포넌트부터 작업하는 “bottom up” 중 하나를 선택할 수 있다.</p>
<ul>
<li>간단한 예제에서는 하향식으로 작성하는 것이 더 쉽고, 대규모 프로젝트에서는 상향식으로 작성하는 것이 쉽다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ProductCategoryRow</span>(<span class="params">&#123; category &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>(</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				&#123;category&#125;</span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProductRow</span>(<span class="params">&#123; product &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> name = product.<span class="property">stocked</span> ? product.<span class="property">name</span> :</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">			&#123;product.name&#125;</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProductTable</span>(<span class="params">&#123; products &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> rows = [];</span><br><span class="line">	<span class="keyword">let</span> lastCategory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	products.<span class="title function_">forEach</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(product.<span class="property">category</span> !== lastCategory) &#123;</span><br><span class="line">			rows.<span class="title function_">push</span>(</span><br><span class="line">				<span class="language-xml"><span class="tag">&lt;<span class="name">ProductCategoryRow</span> <span class="attr">category</span>=<span class="string">&#123;product.category&#125;</span> <span class="attr">key</span>=<span class="string">&#123;product.category&#125;</span> /&gt;</span></span></span><br><span class="line">			);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rows.<span class="title function_">push</span>(</span><br><span class="line">			<span class="language-xml"><span class="tag">&lt;<span class="name">ProductRow</span> <span class="attr">product</span>=<span class="string">&#123;product&#125;</span> <span class="attr">key</span>=<span class="string">&#123;product.category&#125;</span> /&gt;</span></span></span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">		lastCategory = product.<span class="property">category</span>;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span>&#123;rows&#125;<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span> // rows 배열을 전달</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SearchBar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				&#123;&#x27; &#x27;&#125;</span></span><br><span class="line"><span class="language-xml">	      Only show products in stock</span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  );</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">// 가장 상위 컴포넌트에서부터 products 객체를 받아야 한다.</span></span><br><span class="line"><span class="language-xml">function FilterableProductTable(&#123; products &#125;) &#123;</span></span><br><span class="line"><span class="language-xml">	return (</span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">SearchBar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">ProductTable</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	);</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const PRODUCTS = [</span></span><br><span class="line"><span class="language-xml">  &#123;category: &quot;Fruits&quot;, price: &quot;$1&quot;, stocked: true, name: &quot;Apple&quot;&#125;,</span></span><br><span class="line"><span class="language-xml">  &#123;category: &quot;Fruits&quot;, price: &quot;$1&quot;, stocked: true, name: &quot;Dragonfruit&quot;&#125;,</span></span><br><span class="line"><span class="language-xml">  &#123;category: &quot;Fruits&quot;, price: &quot;$2&quot;, stocked: false, name: &quot;Passionfruit&quot;&#125;,</span></span><br><span class="line"><span class="language-xml">  &#123;category: &quot;Vegetables&quot;, price: &quot;$2&quot;, stocked: true, name: &quot;Spinach&quot;&#125;,</span></span><br><span class="line"><span class="language-xml">  &#123;category: &quot;Vegetables&quot;, price: &quot;$4&quot;, stocked: false, name: &quot;Pumpkin&quot;&#125;,</span></span><br><span class="line"><span class="language-xml">  &#123;category: &quot;Vegetables&quot;, price: &quot;$1&quot;, stocked: true, name: &quot;Peas&quot;&#125;</span></span><br><span class="line"><span class="language-xml">];</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">export default function App() &#123;</span></span><br><span class="line"><span class="language-xml">	return <span class="tag">&lt;<span class="name">FilterableProductTable</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/0jfw74?file=/App.js&utm_medium=sandpack">https://codesandbox.io/s/0jfw74?file=/App.js&utm_medium&#x3D;sandpack</a></p>
<p>컴포넌트를 빌드하고 나면 데이터 모델을 렌더링하는 재사용 가능한 컴포넌트 라이브러리를 갖게 된다. 이 앱은 정적 앱이므로 컴포넌트는 JSX만 반환함.</p>
<p>계층 구조의 맨 위에 있는 컴포넌트(FilterableProductTable)는 데이터 모델을 소품으로 사용.</p>
<p>데이터가 최 상위 컴포넌트에서 트리 하단에 있는 컴포넌트로 흘러내림 👉🏻 <strong>단방향 데이터 흐름</strong></p>
<h3 id="Step-3-Find-the-minimal-but-complete-representation-of-UI-state"><a href="#Step-3-Find-the-minimal-but-complete-representation-of-UI-state" class="headerlink" title="Step 3: Find the minimal but complete representation of UI state"></a>Step 3: Find the minimal but complete representation of UI state</h3><p><em>최소한이지만 UI 상태 표현 완성하기</em></p>
<p>UI 대화형으로 만들려면 사용자가 기본 데이터 모델을 변경할 수 있도록 해야함 👉🏻 <strong>이를 위해 state를 사용</strong></p>
<ul>
<li>상태(state): 앱이 기억해야하는 최소한의 변경 데이터 집합</li>
<li>상태를 구조화할 때 가장 중요한 원칙<br>: 반복하지 않는 것</li>
</ul>
<p>애플리케이션에 필요한 최소한의 상태 표현을 파악하고, 그 외의 모든 것들은 요청 시에 계산한다.</p>
<p>예를 들어 쇼핑 목록을 만드는 경우,</p>
<ul>
<li>항목 👉🏻 상태 배열로 저장</li>
<li>목록에 있는 항목의 개수를 표시하려면 다른 상태 값으로 저장하지 말고 배열의 길이를 읽으면 된다.</li>
</ul>
<p>예제 애플리케이션의 모든 데이터 조각들을 생각해보기</p>
<ol>
<li>원래 제품 목록</li>
<li>사용자가 입력한 검색 텍스트</li>
<li>체크박스의 값</li>
<li>필터링된 제품 목록</li>
</ol>
<p>여기서 상태는 무엇인가? 상태가 아닌 것들을 판별해보자.</p>
<ul>
<li>시간이 지나도 변하지 않는가? 👉🏻 상태 X</li>
<li>부모로부터 props를 통해 전달받는가? 👉🏻 상태 X</li>
<li>컴포넌트의 기존 state나 props를 기반으로 계산할 수 있는가? 👉🏻 상태 X</li>
</ul>
<p>이 외의 나머지는 모두 상태이다.</p>
<p>예제 데이터를 보면서 살펴보자.</p>
<ol>
<li>원래 제품 목록: props로 전달되었기 때문에 상태 X</li>
<li>사용자가 입력한 검색 텍스트: 시간이 지남에 따라 변경되고 아무것도 계산할 수 없으므로 상태 O</li>
<li>체크박스의 값: 시간이 지남에 따라 변경되고 계산이 어려우므로 상태 O</li>
<li>필터링된 제품 목록: 원래 제품 목록을 가져와서 검색 텍스트 및 확인란 값에 따라 필터링하여 계산할 수 있으므로 상태 X</li>
</ol>
<h3 id="Step-4-Identify-where-your-state-should-live"><a href="#Step-4-Identify-where-your-state-should-live" class="headerlink" title="Step 4: Identify where your state should live"></a>Step 4: Identify where your state should live</h3><p><em>상태가 어디서 살아있어야하는지 식별하기</em></p>
<p>앱의 최소 상태 데이터를 식별했다면 이제는 <strong>상태를 소유하는 컴포넌트를 식별</strong>해야한다.</p>
<p><strong>리액트는 단방향 데이터 흐름을 사용하며, 부모 컴포넌트가 자식 컴포넌트로 컴포넌트 계층 구조를 따라 데이터를 전달한다는 것을 기억하자.</strong></p>
<ol>
<li>해당 상태를 기반으로 무언갈르 렌더링하는 모든 컴포넌트를 식별한다.</li>
<li>가장 가까운 공통 상위 컴포넌트, 즉 계층 구조에서 모든 컴포넌트 위에 있는 컴포넌트를 찾는다.</li>
<li>상태가 어디에 위치해야할 지 결정한다.<ol>
<li>종종 상태를 공통 부모에 직접 넣을 수 있다.</li>
<li>상태를 공통 부모 위에 있는 컴포넌트에 넣을 수 있다.</li>
<li>상태를 소유하기에 적합한 컴포넌트를 찾을 수 없는 경우 상태를 보유하기 위한 컴포넌트를 새로 만들어 공통 부모 컴포넌트 위에 추가한다.</li>
</ol>
</li>
</ol>
<p>우리는 이전 단계에서 검색 입력 텍스트와 체크박스 확인 값이라는 두 가지 상태를 찾아놓음.</p>
<p>이 상태에 대한 전략을 실행해보자.</p>
<ol>
<li>상태를 사용하는 컴포넌트 식별하기:<ol>
<li>ProductTable은 해당 상태를 기준으로 제품 목록을 필터링해야한다.</li>
<li>SearchBar는 해당 상태를 표시해야 한다.</li>
</ol>
</li>
<li>공통 부모 찾기: 두 컴포넌트가 공유하는 첫 번째 상위 컴포넌트는 FilterableProductTable</li>
<li>상태를 어디에 있게할지 결정하기: 필터 텍스트와 체크된 상태 값은 FilterableProductTable에 있어야 한다.</li>
</ol>
<p>따라서 상태 값은 FilterableProductTable에 저장한다.</p>
<p><code>useState()</code> Hook으로 컴포넌트에 state를 추가하기</p>
<p>FilterableProductTable의 상단에 상태 변수 두 개를 추가하고 애플리케이션의 초기 상태를 지정:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FilterableProductTable</span>(<span class="params">&#123; products &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> [filterText, setFilterText] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">	<span class="keyword">const</span> [inStockOnly, setInStockOnly] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>filterText와 inStockOnly를 ProductTable과 SearchBar 컴포넌트에 props로 전달하기</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">SearchBar</span> <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span> <span class="attr">inStockOnly</span>=<span class="string">&#123;inStockOnly&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ProductTable</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span> <span class="attr">inStockOnly</span>=<span class="string">&#123;inStockOnly&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>이제 애플리케이션이 어떻게 동작하는지 확인할 수 있다.</p>
<p><a href="https://codesandbox.io/s/n3gc1j?file=/App.js&utm_medium=sandpack">https://codesandbox.io/s/n3gc1j?file=/App.js&utm_medium&#x3D;sandpack</a></p>
<p>폼을 편집하는 것은 아직 동작하지 않음. 그 이유는?</p>
<p>👉🏻 onChange 핸들러가 없는 양식 필드에 Value 프로퍼티를 제공. 이렇게 되면 읽기 전용 필드가 렌더링된다.</p>
<p>ProductTable과 SearchBar는 filterText 및 inStockOnly prop을 읽어 테이블, input, 체크박스를 렌더링한다. 예를 들어, SearchBar가 입력 값을 채우는 방식은 다음과 같다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchBar</span>(<span class="params"> &#123; filterText, inStockOnly &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		&lt;form&gt;</span><br><span class="line">			<span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> **<span class="attr">value</span>=<span class="string">&#123;filterText&#125;**</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Step-5-Add-inverse-data-flow"><a href="#Step-5-Add-inverse-data-flow" class="headerlink" title="Step 5: Add inverse data flow"></a>Step 5: Add inverse data flow</h3><p><em>역데이터 흐름 추가하기</em></p>
<p>현재 애플리케이션은 프로퍼티와 상태가 계층 구조 아래로 흐르면서 올바르게 렌더링된다.</p>
<dl><dt>그러나 사용자 입력에 따라 상태를 변경하려면 👉🏻 다른 방향으로 데이터가 흐르도록 해야 한다</dt><dd>form 컴포넌트가 FilterableProductTable 상태를 업데이트 해야한다.</dd></dl><p>위 예시에서 입력하거나 확인란을 선택하려고 하면 리액트가 입력을 의도적으로 무시한다.</p>
<p><code>&lt;input value=&#123;filterText&#125; /&gt;</code>를 작성함으로써, 입력 값 prop이 항상 FilterableProductTable에서 전달된 filterText 상태와 같도록 만들어 놓았기 때문.</p>
<p>즉, filterText 상태가 설정되지 않으므로 입력은 변경되지 않는다.</p>
<p>input이 변경될 때마다 변경 사항을 반영해서 상태가 업데이트 되도록 만들고 싶다면</p>
<ul>
<li>상태는 FilterableProductTable가 가지고 있으므로 FilterableProductTable 함수만이 setFilterText와 setInStockOnly 를 호출할 수 있음</li>
</ul>
<p>SearchBar가 FilterableProductTable의 상태를 업데이트하도록 하려면</p>
<ul>
<li>setFilterText와 같은 함수를 SearchBar에 전달해야한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FilterableProductTable</span>(<span class="params">&#123; products &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [inStockOnly, setInStockOnly] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">SearchBar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">inStockOnly</span>=<span class="string">&#123;inStockOnly&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onFilterTextChange</span>=<span class="string">&#123;setFilterText&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onInStockOnlyChange</span>=<span class="string">&#123;setInStockOnly&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>SearchBar 내부에는 onChange 이벤트 핸들러를 추가하고 이 핸들러에서 상위 상태를 설정한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=&#123;filterText&#125; placeholder=<span class="string">&quot;Search...&quot;</span> onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="title function_">onFilterTextChange</span>(e.<span class="property">target</span>.<span class="property">value</span>)&#125; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FilterableProductTable</span>(<span class="params">&#123; products &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [inStockOnly, setInStockOnly] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SearchBar</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">inStockOnly</span>=<span class="string">&#123;inStockOnly&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onFilterTextChange</span>=<span class="string">&#123;setFilterText&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onInStockOnlyChange</span>=<span class="string">&#123;setInStockOnly&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductTable</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span> <span class="attr">inStockOnly</span>=<span class="string">&#123;inStockOnly&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProductCategoryRow</span>(<span class="params">&#123; category &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">colSpan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>&#123;category&#125;<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProductRow</span>(<span class="params">&#123; product &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = product.<span class="property">stocked</span> ? product.<span class="property">name</span> : <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &#x27;<span class="attr">red</span>&#x27; &#125;&#125;&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProductTable</span>(<span class="params">&#123; products, filterText, inStockOnly &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rows = [];</span><br><span class="line">  <span class="keyword">let</span> lastCategory = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  products.<span class="title function_">forEach</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (product.<span class="property">name</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(filterText.<span class="title function_">toLowerCase</span>()) === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inStockOnly &amp;&amp; !product.<span class="property">stocked</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (product.<span class="property">category</span> !== lastCategory) &#123;</span><br><span class="line">      rows.<span class="title function_">push</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ProductCategoryRow</span> <span class="attr">category</span>=<span class="string">&#123;product.category&#125;</span> <span class="attr">key</span>=<span class="string">&#123;product.category&#125;</span> /&gt;</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rows.<span class="title function_">push</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">ProductRow</span> <span class="attr">product</span>=<span class="string">&#123;product&#125;</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span> /&gt;</span></span>);</span><br><span class="line">    lastCategory = product.<span class="property">category</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span>&#123;rows&#125;<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SearchBar</span>(<span class="params">&#123; filterText, inStockOnly, onFilterTextChange, onInStockOnlyChange &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;filterText&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> onFilterTextChange(e.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&#123;inStockOnly&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> onInStockOnlyChange(e.target.checked)&#125; /&gt; Only</span></span><br><span class="line"><span class="language-xml">        show products in stock</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PRODUCTS</span> = [</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Apple&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Dragonfruit&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$2&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">&#x27;Passionfruit&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$2&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Spinach&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$4&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">&#x27;Pumpkin&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Peas&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">FilterableProductTable</span> <span class="attr">products</span>=<span class="string">&#123;PRODUCTS&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="단일-책임-원칙-single-responsibility-principle"><a href="#단일-책임-원칙-single-responsibility-principle" class="headerlink" title="단일 책임 원칙(single responsibility principle)"></a><a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">단일 책임 원칙(single responsibility principle)</a></h3><ul>
<li>객체 지향 프로그래밍에서 중요한 원칙 중 하나</li>
<li>‘클래스나 모듈은 하나의 액터에게만 책임을 져야한다.’는 컴퓨터 프로그래밍 원칙</li>
<li>액터라는 용어는 모듈을 변경해야하는 그룹을 의미 (한 명 이상의 이해관계자 또는 사용자로 구성됨)<ul>
<li><em>The term actor refers to a group (consisting of one or more stakeholders or users) that requires a change in the module.</em></li>
</ul>
</li>
<li>로버트 C. 마틴은 이 원칙을 ‘클래스를 변경할 이유가 하나만 있어야 한다.’라고 표현</li>
<li>“원인(이유)”이라는 단어 때문에 혼란이 생겨 그는 “원칙은 사람에 관한 것이다”라고 명확히 함.</li>
<li>주문 클래스 👉🏻 주문을 처리하는 책임만 가지고 있어야 한다.<ul>
<li>결제나 배송과 같은 책임은 다른 클래스에서 처리되어야 함</li>
<li>이렇게 되면 주문 클래스는 주문과 관련된 기능만을 가지고 있고 코드의 복잡도가 감소하여 유지보수가 쉬워진다.</li>
</ul>
</li>
<li>단일 책임 원칙을 지키면 클래스 간 의존성이 감소하고, 결합도가 낮아져 시스템의 유연성과 확장성이 향상된다.</li>
</ul>
<p><strong>History</strong></p>
<ul>
<li>로버트 C. 마틴이 객체 지향 설계의 원칙의 일부인 “OOD의 원칙”이라는 글에서 소개</li>
</ul>
<h3 id="Props-vs-State"><a href="#Props-vs-State" class="headerlink" title="Props vs State"></a>Props vs State</h3><ul>
<li>Props는 함수에 전달하는 arguments와 같다.<ul>
<li>부모 컴포넌트가 자식 컴포넌트에 데이터를 전달</li>
<li>ex) form은 버튼에 색상 프로퍼티를 전달할 수 있다.</li>
</ul>
</li>
<li>State는 컴포넌트의 메모리와 같다.<ul>
<li>컴포넌트가 일부 정보를 추적하고 상호작용에 반응하여 변경할 수있게 해줌</li>
<li>ex) 버튼은 isHovered 상태를 추적할 수 있다.</li>
</ul>
</li>
</ul>
<p>props와 state는 다르지만 함께 작동한다. 부모 컴포넌트는 일부 정보를 state에 보관하고 이를 자식 컴포넌트에 프로퍼티로 전달하는 경우가 있다.</p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 5주차 주간회고</title>
    <url>/2023/230318-archive/</url>
    <content><![CDATA[<p>5주차 주간 회고 가보자고!</p>
<p><img src="/../img/230318/2023-03-18-15-05-24.png"></p>
<h2 id="주간-회고"><a href="#주간-회고" class="headerlink" title="주간 회고"></a>주간 회고</h2><h3 id="시간은-전력질주-중"><a href="#시간은-전력질주-중" class="headerlink" title="시간은 전력질주 중"></a>시간은 전력질주 중</h3><p>나의 속도는 빠른 걸음 걷기인데 시간은 전력으로 달리고 있는 것 같다. 해야할 일들은 계속해서 쌓여 나가고 있지만 하루에 학습할 수 있는 시간은 한계가 있다. 부트캠프는 장거리 마라톤과 같다고 생각하는데 시간이 너무 오버페이스로 달리고 있는 것 같아 걱정된다. 조금만 천천히 가줘…</p>
<p>이번 주엔 클래스와 프로토타입, 고차함수에 대해서 공부했다. 이 많은 개념들을 일주일에 공부한다고? 생각했는데 되돌아보니 공부를 하긴 했다.. 이해를 했는가?에 대한 부분은 넘어가도록 하자. 한 번 공부한다고 해서 모두 이해가 되는게 아니라는 걸 잘 알고 있다. 전에 공부했을 때보다 훨씬 많은 내용을 이해했다.</p>
<p>클래스에 대해서 간단하게 설명해보면, 다른 언어에서 말하는 클래스와는 내부 동작이 다르다는 것. 프로토타입 기반의 생성자 함수를 class라는 키워드를 사용해서 조금 더 직관적으로 구현한 것이다. 결국 클래스도 프로토타입 기반이다. <em>(자세한 내용은 블로그에 클래스라는 주제로 정리해서 올려야겠다.)</em></p>
<h3 id="리액트-반갑다"><a href="#리액트-반갑다" class="headerlink" title="리액트 반갑다!"></a>리액트 반갑다!</h3><p>코드스테이츠에서 다음 주부터 리액트를 배운다. 틈틈이 공식문서를 읽긴했지만 실습을 해본 적은 없어서 이해를 다 하면서 따라갈 수 있을지 걱정이 된다. 하지만 메가테라에서도 공부를 하고 있으니까 걱정할 필요는 없을 것 같다. 코드스테이츠에서 리액트를 배우기 시작해도 순수 자바스크립트로 작성해보는 연습도 계속해야지.</p>
<p>리액트도 JSX 없이는 결국은 자바스크립트라는 것 잊지 말자.👏🏻</p>
<h3 id="아쉬운-점은-무엇이-있을까"><a href="#아쉬운-점은-무엇이-있을까" class="headerlink" title="아쉬운 점은 무엇이 있을까?"></a>아쉬운 점은 무엇이 있을까?</h3><p>자바스크립트 내장 메서드를 직접 구현해보는 Underbar 과제를 Bare Minimum까지밖에 풀지 못했다는 점이 가장 아쉽다. 집중이 안되는 것도 있었지만, 어떻게 구현해야할지 바로바로 떠오르지 않아 빨리 해결하지 못했다. (이 정도의 실력이라는 거지.😢) 다음 번에도 과제를 할 때 집중이 되지 않는다면 페어 분께 양해를 구하고서라도 장소를 옮기자.</p>
<p>나의 수준을 빨리 인정하고 어떻게 해야 정해진 시간 안에서 최대한 성장할 수 있는 방법을 찾자.</p>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>레이저로 쇠막대기 자르기 </title>
    <url>/2022/221017-archive/</url>
    <content><![CDATA[<h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.</p>
<ul>
<li>쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.<ul>
<li>각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.</li>
<li>레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다.</li>
</ul>
</li>
</ul>
<p>아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.</p>
<p><img src="https://s1.md5.ltd/image/949e163bd665c6f711dbab3329b755a2.png" alt="https://s1.md5.ltd/image/949e163bd665c6f711dbab3329b755a2.png"></p>
<p>이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.</p>
<ol>
<li>레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반 드시 레이저를 표현한다.</li>
<li>쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다.</li>
</ol>
<p>위 예의 괄호 표현은 그림 위에 주어져 있다.</p>
<p>쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다.</p>
<p>쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.</p>
<h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>한 줄에 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 공백없이 주어진다. 괄호 문자의 개수는 최대 100,000이다.</p>
<h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.</p>
<h3 id="예제입력"><a href="#예제입력" class="headerlink" title="예제입력"></a>예제입력</h3><p>▣ 입력예제 1</p>
<p>()(((()())(())()))(())</p>
<p>▣ 출력예제 1<br>17</p>
<p>▣ 입력예제 2<br>(((()(()()))(())()))(()())</p>
<p>▣ 출력예제 2<br>24</p>
<hr>
<h2 id="🙌🏻-문제-이해하기"><a href="#🙌🏻-문제-이해하기" class="headerlink" title="🙌🏻 문제 이해하기"></a>🙌🏻 문제 이해하기</h2><ul>
<li>문제는? 👉🏻쇠막대기와 레이저의 배치를 나타내는 괄호가 주어졌을 때, 레이져로 잘린 쇠막대기 조각의 총 개수를 출력해라</li>
<li><strong>괄호 문제가 나오면 stack으로 접근하기</strong></li>
<li>주어진 문자열을 하나씩 순회</li>
<li>여는 괄호를 만날 경우 👉🏻 모두 stack에 push</li>
<li>닫는 괄호를 만날 경우<ul>
<li>레이저인가? 👉🏻 바로 전 인덱스 요소가 여는 괄호였다면 레이저</li>
<li>막대기의 끝인가? 👉🏻 바로 전 인덱스 요소가 여는 괄호가 아니라면 막대기의 끝</li>
</ul>
</li>
<li>레이저라면 stack.pop (여는 괄호 빼기) ➡️ stack.length를 더해주기<ul>
<li>stack.length는 막대기의 잘려진 갯수</li>
</ul>
</li>
<li>막대기의 끝이면 answer +&#x3D; 1 (쇠 막대 한개가 완성되면, 레이져로 잘리고 남은 쇠조각 1개만 남기 때문에 +1을 해주는 것)</li>
<li>for문이 종료되면 answer 반환하기</li>
</ul>
<h2 id="✅-solution"><a href="#✅-solution" class="headerlink" title="✅ solution"></a>✅ solution</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solution</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> answer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) stack.<span class="title function_">push</span>(s[i]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (s[i - <span class="number">1</span>] === <span class="string">&#x27;(&#x27;</span>) answer += stack.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">else</span> answer += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">solution</span>(<span class="string">&#x27;()(((()())(())()))(())&#x27;</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 6주차 주간회고</title>
    <url>/2023/230325-1-archive/</url>
    <content><![CDATA[<p><img src="https://oopy.lazyrockets.com/api/rest/cdn/image/5ea7b8f9-fe5e-49b6-ad61-40007a25805b.png" alt="."></p>
<h1 id="Fact"><a href="#Fact" class="headerlink" title="Fact"></a>Fact</h1><ul>
<li>Promise, async&#x2F;await에 대한 개념을 다시 공부했다.</li>
<li>fetch 함수를 사용해서 데이터를 받아오고 데이터를 가공하는 연습을 했다.</li>
<li>create-react-app을 통해 간단한 개발용 React 앱을 만들어봤다.</li>
<li>JSX 문법에 대해서 배웠다.</li>
<li>React Router에 대해 배우고 Router를 통해 SPA를 구현하는 연습을 했다.</li>
</ul>
<h1 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h1><ul>
<li>비동기가 막연하게 느껴지는 개념이라고 생각해서 어렵다라는 생각을 가지고 있었던 것 같다. 유튜브 제로초님 영상 중 비동기 콜백함수와 프로미스 개념에 관한 영상을 보고 자바스크립트 딥다이브를 다시 읽어보니 생각보다 별거 없네?라는 생각이 들었다.</li>
<li><code>npx create-react-app</code> 명령어를 통해 리액트 앱을 만들고 JSX 문법을 사용해 브라우저에 띄우는 실습하는 주간이었다. 코드스테이츠에서는 JSX문법에 대해서만 간단하게 배웠지만 한 주 전에 메가테라에서 JSX문법이 어떻게 자바스크립트 코드로 변환되는지 깊게 배웠기 때문에 내용들이 쉽게 느껴졌다.</li>
<li>Router에 대한 개념을 배우고 나니 이전에 바닐라 자바스크립트로 SPA를 구현했던 코드가 생각이 났었다. 설정한 URL이외의 주소로 접근하면 404 에러 페이지를 띄워줘야할 때 정규표현식을 사용해서 확인했었다. 코드가 너무 복잡해서 알아보기 어렵다는 아쉬움이 있었는데 리액트를 사용하니 이런 부분에서 쉽게 처리할 수 있다는 것을 알게 되었다. 리액트 만세</li>
</ul>
<h1 id="Finding"><a href="#Finding" class="headerlink" title="Finding"></a>Finding</h1><ul>
<li>새로운 기술들이 나옴에 있어서 두려워하지말자. 결국 새로운 기술은 이전 기술보다 더 사용하기 쉽게 나올 것이다. 그래야 많은 사용자들이 기존에 쓰던 기술을 버리고 갈아탈테니까.</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>원시 자료형과 참조 자료형</title>
    <url>/2023/230302-archive/</url>
    <content><![CDATA[<h3 id="🙋🏻‍♂️-원시-자료형과-참조-자료형에-대해서-설명해주실-수-있을까요"><a href="#🙋🏻‍♂️-원시-자료형과-참조-자료형에-대해서-설명해주실-수-있을까요" class="headerlink" title="🙋🏻‍♂️ 원시 자료형과 참조 자료형에 대해서 설명해주실 수 있을까요?"></a>🙋🏻‍♂️ 원시 자료형과 참조 자료형에 대해서 설명해주실 수 있을까요?</h3><p>라는 질문에 정확히 대답할 수 있냐라고 물어보면, 뭔지는 아는데 정확하게 설명하기 어려워 두 개념에 대해서 정리해보는 시간을 가지게 되었다.</p>
<h2 id="원시-자료형"><a href="#원시-자료형" class="headerlink" title="원시 자료형"></a>원시 자료형</h2><ul>
<li>원시 자료형은 <strong>변경 불가능</strong>한 값이다.</li>
<li>값을 변경할 수 없다는 것은 구체적으로 값에 대한 진술이다. 변수에 할당한 값을 다른 값으로 변경할 수 있지만 즉, 변수 값은 변경이 가능하지만 원시 값 자체를 변경할 수 없다는 것이다.</li>
<li>원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다.</li>
<li>원시 자료형에는 number, string, boolean, undefined, null, symbol 6개의 데이터 타입이 있다.</li>
</ul>
<h2 id="참조-자료형"><a href="#참조-자료형" class="headerlink" title="참조 자료형"></a>참조 자료형</h2><ul>
<li>참조 자료형은 <strong>변경 가능한 값</strong>이다.</li>
<li>참조 값을 변수에 할당하면 변수에는 원본의 주소 값이 저장된다.</li>
<li>원시 자료형이 아닌 모든 데이터 타입을 참조 자료형으로 구분하는데 대표적으로 배열, 객체가 있다.</li>
</ul>
<h3 id="원시-자료형은-값에-의한-전달-참조-자료형은-참조에-의한-전달이라고-정리할-수-있다"><a href="#원시-자료형은-값에-의한-전달-참조-자료형은-참조에-의한-전달이라고-정리할-수-있다" class="headerlink" title="원시 자료형은 값에 의한 전달, 참조 자료형은 참조에 의한 전달이라고 정리할 수 있다."></a>원시 자료형은 <span style="color:red ">값에 의한 전달</span>, 참조 자료형은 <span style="color:red">참조에 의한 전달</span>이라고 정리할 수 있다.</h3><h3 id="✅-값에-의한-전달"><a href="#✅-값에-의한-전달" class="headerlink" title="✅ 값에 의한 전달"></a>✅ 값에 의한 전달</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">var</span> copy = score;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// 80</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// 80</span></span><br><span class="line"></span><br><span class="line">score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score); <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>👉🏻 score에 80이라는 값을 할당하고, copy 변수에 score를 할당했다. 그 후 score 변수에 새로운 숫자 값 100을 재할당하면 copy 변수의 값은 어떻게 될까?</p>
<p>변수에 변수를 할당했을 때, 무엇이 어떻게 전달되는지를 알아야 한다.</p>
<p><code>copy = score</code> 에서 score는 변수 값 80으로 평가되므로 copy에는 80이 할당된다. 이 때 새로운 숫자 값 80이 생성되어 copy 변수에 할당된다. 이처럼 변수에 원시 값을 갖는 변수를 할당하면 할당되는 변수의 원시 값이 복사되어 전달된다.</p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/7e6OS/btrdo862oUX/lnv8cYKhqCsKU6NBs3mKV0/img.jpg" alt="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https://blog.kakaocdn.net/dn/7e6OS/btrdo862oUX/lnv8cYKhqCsKU6NBs3mKV0/img.jpg"></p>
<p>변수가 할당되는 값을 <strong>가리키고 있다</strong> 라고 생각하면 이해하기 쉽다. 숫자 값 80을 가리키고 있는 것은 동일하지만, 다른 메모리 공간에 저장되어 있기 때문에 별개의 값이다.</p>
<p>그렇기 때문에 copy의 값을 변경하면,</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> copy = score;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score, copy); <span class="comment">// 80  80</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score === copy); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.</span></span><br><span class="line"><span class="comment">// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.</span></span><br><span class="line">score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score, copy); <span class="comment">// 100  80</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(score === copy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>score와 copy는 다른 별개의 메모리 공간에 저장되어 있었기 때문에 score에 다른 값을 할당하여도 copy 변수 값에는 어떠한 영향을 주지 않는다.</p>
<h3 id="✅-참조에-의한-전달"><a href="#✅-참조에-의한-전달" class="headerlink" title="✅ 참조에 의한 전달"></a>✅ 참조에 의한 전달</h3><p>객체를 원시 값처럼 복사해서 생성하게 되면 무슨 일이 일어날까? 명확하고 신뢰성이 확보되겠지만 복사해서 생성하는 비용이 많이든다. 객체는 이러한 구조적 단점에 따른 부작용이 있다. 원시 값과는 다르게 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.</p>
<p>여러개 식별자가 하나의 객체를 공유할 수 있다는 것이 무엇을 의미할까?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 참조값을 복사(얕은 복사)</span></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br></pre></td></tr></table></figure>

<p>객체를 가리키는 변수를 다른 변수에 할당했다. 이때 원본의 <strong>참조 값이 복사되어 전달</strong>된다. 즉, person이라는 변수의 메모리 공간 주소와 copy 변수의 메모리 공간 주소는 다르지만, 동일한 참조 값을 가지고 있다.</p>
<p><img src="https://velog.velcdn.com/images/kozel/post/31738528-08ce-43c4-bb41-3ae672590f92/image.jpeg" alt="https://velog.velcdn.com/images/kozel/post/31738528-08ce-43c4-bb41-3ae672590f92/image.jpeg"></p>
<p>이것은 두 개의 식별자가 하나의 객체를 공유한다는 것의 의미한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 참조값을 복사(얕은 복사) copy와 person은 동일한 참조 값을 갖는다.</span></span><br><span class="line"><span class="keyword">var</span> copy = person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy와 person은 동일한 객체를 참조한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy === person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy를 통해 객체를 변경한다.</span></span><br><span class="line">copy.<span class="property">name</span> = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person을 통해 객체를 변경한다.</span></span><br><span class="line">person.<span class="property">address</span> = <span class="string">&#x27;Seoul&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy와 person은 동일한 객체를 가리킨다.</span></span><br><span class="line"><span class="comment">// 따라서 어는 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy); <span class="comment">// &#123;name: &quot;Kim&quot;, address: &quot;Seoul&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="✍🏻-Review"><a href="#✍🏻-Review" class="headerlink" title="✍🏻 Review"></a>✍🏻 Review</h2><p>이번 기회에 원시 자료형과 참조 자료형에 대해서 정리하면서 ‘값에 의한 전달’과 ‘참조에 의한 전달’ 이라는 용어에 대해서 다시 한 번 정리해볼 수 있었던 것 같다.</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>프로미스(Promise) 쉽게 이해하기🤯 (with 제로초)</title>
    <url>/2023/230321-archive/</url>
    <content><![CDATA[<blockquote>
<p>프로미스의 장점은 실행됐는데 결과값을 나중에 쓸 수 있는 것</p>
</blockquote>
<h2 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>); <span class="comment">// 비동기 콜백</span></span><br><span class="line"></span><br><span class="line">콜백은 비동기가 아니다. 비동기 콜백이 비동기일뿐</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculator</span>(<span class="params">callback, a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">callback</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">calculator</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x, y;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  <span class="number">5</span></span><br><span class="line">); <span class="comment">// 동기 콜백</span></span><br></pre></td></tr></table></figure>

<p>콜백의 한 가지 아쉬운 점 → 조건이 달성되면 바로 실행해버림</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resove</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>이 코드는 setTimeout으로만 작성된 코드와 차이점이 무엇일까?</p>
<p>setTimeout은 1초 뒤에 태스크 큐로 넘어가고 콜스택이 비면 바로 실행된다.</p>
<p>프로미스를 사용하면 나중에 결과값을 사용하고 싶을 때 promise.then을 사용해서 사용할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 신나게 딴 짓</span></span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">결괏값</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = axios.<span class="title function_">get</span>(<span class="string">&#x27;서버주소1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = axios.<span class="title function_">get</span>(<span class="string">&#x27;서버주소2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = axios.<span class="title function_">get</span>(<span class="string">&#x27;서버주소3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>콜백의 단점: 데이터를 바로 받아야한다.</p>
<p>콜백헬이 왜 안좋은가? 가독성 측면에서 보기 안좋은 것도 있지만,</p>
<h3 id="근본적인-원인은-결과값을-바로-받아야한다는-것이다"><a href="#근본적인-원인은-결과값을-바로-받아야한다는-것이다" class="headerlink" title="근본적인 원인은 결과값을 바로 받아야한다는 것이다."></a>근본적인 원인은 결과값을 바로 받아야한다는 것이다.</h3><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>프로미스의 단점: 하나라도 실패하면 catch로 넘어간다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>p1, p2가 제대로 들어와도 p3에서 데이터가 제대로 들어오지 않으면 바로 catch 구문으로 넘어간다.</p>
<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><p>이를 해결하기 위해서 allSettled가 나옴</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([p1, p2, p3]).<span class="title function_">then</span>(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise.allSettled는 모든 처리결과를 반환한다. results는 배열로 반환하기 때문에 filter를 사용해서 실패한 것만 필터링해서 다시 시도할 수 있는 장점이 있다.</p>
<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p>비동기 함수가 어떻게 동작하는지 원리는 알고 있었지만 쉽게 사용하지 못했었는데 제로초 프로미스 영상을 보고 프로미스가 왜 탄생하게 된건지, 프로미스를 사용하면 어떤 장점이 있는지에 대해서 알게되었다. <em>(제로초님 폼 미쳤다!)</em></p>
<hr>
<p>+) 영상 링크</p>
<p><a href="https://www.youtube.com/watch?v=0f-jNhnN0Qc">프로미스의 최고 장점을 아십니까</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking in React - React State🚀</title>
    <url>/2023/230327-archive/</url>
    <content><![CDATA[<h1 id="React-State"><a href="#React-State" class="headerlink" title="React State"></a>React State</h1><p><strong>Step 3: Find the minimal but complete representation of UI state</strong></p>
<p><strong>Step 4: Identify where your state should live</strong></p>
<p><strong>Step 5: Add inverse data flow</strong></p>
<p>리액트에는 state라는 개념이 있고 state가 바뀌면 해당 컴포넌트와 하위 컴포넌트가 다시 렌더링하게 된다.</p>
<h3 id="React-State의-조건은"><a href="#React-State의-조건은" class="headerlink" title="React State의 조건은?"></a>React State의 조건은?</h3><ul>
<li><p>변경되지 않는건 state로 다룰 가치가 없다.</p>
</li>
<li><p>props로 전달받았다면 state가 아니다.</p>
</li>
<li><p>계산 가능하면 state가 아니다.</p>
</li>
</ul>
<h3 id="상태는-누가-관리해야할까"><a href="#상태는-누가-관리해야할까" class="headerlink" title="상태는 누가 관리해야할까?"></a>상태는 누가 관리해야할까?</h3><p>현재 관리해야하는 상태는? 👉🏻 체크박스 on, off</p>
<p>체크박스는 누가 관리하는 게 좋을까? 상태를 여러 컴포넌트에 넘겨줘야하는 상황이라면 하위 컴포넌트를 가지고 있는 공통 조상 컴포넌트가 관리하는 것이 좋다. 이것을 <strong>Lifting State Up</strong>이라고 한다.</p>
<br />

<h3 id="checkbox를-클릭하면-stocked가-true인-제품의-목록만-나오도록-만들기"><a href="#checkbox를-클릭하면-stocked가-true인-제품의-목록만-나오도록-만들기" class="headerlink" title="checkbox를 클릭하면 stocked가 true인 제품의 목록만 나오도록 만들기"></a>checkbox를 클릭하면 stocked가 true인 제품의 목록만 나오도록 만들기</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">CheckBoxFieldProps</span> = &#123;</span><br><span class="line">  <span class="attr">label</span>: string,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">CheckBoxField</span>(<span class="params">&#123; label &#125;: CheckBoxFieldProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="title function_">useRef</span>(<span class="string">`checkbox-<span class="subst">$&#123;label&#125;</span>`</span>.<span class="title function_">replace</span>(<span class="regexp">/ /g</span>, <span class="string">&#x27;-&#x27;</span>).<span class="title function_">toLowerCase</span>());</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&#123;id.current&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&#123;id.current&#125;</span>&gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>상태를 관리하려면? <strong>useState</strong> 사용</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [inStockOnly, setInStockOnly] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<br />

<p><strong>체크박스를 클릭했을 때 inStockOnly의 값을 변경하는 방법</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CheckBoxFieldProps</span> = &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">CheckBoxField</span>(<span class="params">&#123; label &#125;: CheckBoxFieldProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="title function_">useRef</span>(<span class="string">`checkbox-<span class="subst">$&#123;label&#125;</span>`</span>.<span class="title function_">replace</span>(<span class="regexp">/ /g</span>, <span class="string">&#x27;-&#x27;</span>).<span class="title function_">toLowerCase</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [inStockOnly, setInStockOnly] = useState&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setInStockOnly</span>(!inStockOnly);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">id</span>=<span class="string">&#123;id.current&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">checked</span>=<span class="string">&#123;inStockOnly&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&#123;id.current&#125;</span>&gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CheckBoxField</code> 컴포넌트를 누가 사용하지? <code>ProductInCategory</code> 컴포넌트</p>
<p>inStockOnly가 true가 되면 <code>ProductInCategory</code> 컴포넌트에서 제품 목록 필터링을 해야한다.</p>
<p><code>CheckBoxField</code> 와 <code>ProductInCategory</code> 컴포넌트를 모두 가지고 있는 조상 컴포넌트를 찾으면?</p>
<p>👉🏻 <code>FilterableProductTable</code> 컴포넌트, 즉 inStockOnly가 있어야 하는 곳이다.</p>
<h3 id="TextField-컴포넌트-만들기"><a href="#TextField-컴포넌트-만들기" class="headerlink" title="TextField 컴포넌트 만들기"></a>TextField 컴포넌트 만들기</h3><p><img src="/../img/230327/230327-1.png" alt="스크린샷 2023-03-24 오후 2.27.05.png"></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TextFieldProps</span> = &#123;</span><br><span class="line">  <span class="attr">placeholder</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">TextField</span>(<span class="params">&#123; placeholder &#125;: TextFieldProps</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FilterableProductTable-컴포넌트가-가져야-할-state"><a href="#FilterableProductTable-컴포넌트가-가져야-할-state" class="headerlink" title="FilterableProductTable 컴포넌트가 가져야 할 state"></a>FilterableProductTable 컴포넌트가 가져야 할 state</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ProductTable</span> <span class="keyword">from</span> <span class="string">&#x27;./ProductTable&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SearchBar</span> <span class="keyword">from</span> <span class="string">&#x27;./SearchBar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&#x27;../types/Product&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FilterableProductTableProps</span> = &#123;</span><br><span class="line">  <span class="attr">products</span>: <span class="title class_">Product</span>[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">FilterableProductTable</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  products,</span></span><br><span class="line"><span class="params">&#125;: FilterableProductTableProps</span>) &#123;</span><br><span class="line">  <span class="comment">// inStockOnly가 있어야 하는 곳</span></span><br><span class="line">  <span class="comment">// filterText가 있어야 하는 곳</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SearchBar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductTable</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>검색어라는 상태를 관리하고 싶다면</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">TextField</span>(<span class="params">&#123; placeholder &#125;: TextFieldProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span> <span class="attr">value</span>=<span class="string">&#123;filterText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>키를 입력할 때마다 무엇을 입력했는 지 확인하려면 onChange 이벤트를 사용한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">TextField</span>(<span class="params">&#123; placeholder &#125;: TextFieldProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">event: React.ChangeEvent</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = event.<span class="property">target</span>;</span><br><span class="line">    <span class="title function_">setFilterText</span>(value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;filterText&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/230327/230327-2.png" alt="스크린샷 2023-03-24 오후 3.25.39.png"></p>
<p>👉🏻 target을 얻었는데 불분명해서 나오는 에러. 현재 타겟은 input element이므로 <HTMLInputElement>로 타입을 지정해준다.</p>
<p><img src="/../img/230327/230327-3.png" alt="스크린샷 2023-03-24 오후 3.30.17.png"></p>
<p>FilterableProductTable 컴포넌트로 작성한 state를 옮겨준다.</p>
<blockquote>
<p>즉, state가 필요한 컴포넌트에서 먼저 작성하고 공통 조상 컴포넌트로 옮기는 방법이 Lifting State Up</p>
</blockquote>
<p><img src="/../img/230327/230327-4.png" alt="스크린샷 2023-03-24 오후 3.42.17.png"></p>
<p>그리고 SearchBar 컴포넌트에 props로 넘겨주기</p>
<p>SerachBar 컴포넌트에서는?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">CheckBoxField</span> <span class="keyword">from</span> <span class="string">&#x27;./CheckBoxField&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TextField</span> <span class="keyword">from</span> <span class="string">&#x27;./TextField&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SearchBarProps</span> = &#123;</span><br><span class="line">  <span class="attr">filterText</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">SearchBar</span>(<span class="params">&#123; filterText &#125;: SearchBarProps</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;seach-bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TextField</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span> <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CheckBoxField</span> <span class="attr">label</span>=<span class="string">&quot;Only Show products in stock&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>props으로 받아왔기 때문에 SearchBarProps로 타입을 지정해주고, TextField 컴포넌트에 props로 다시 전달해주기</p>
<p>TextField 컴포넌트에서는?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">TextFieldProps</span> = &#123;</span><br><span class="line">  <span class="attr">filterText</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">placeholder</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">TextField</span>(<span class="params">&#123; filterText, placeholder &#125;: TextFieldProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">event: React.ChangeEvent&lt;HTMLInputElement&gt;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = event.<span class="property">target</span>;</span><br><span class="line">    <span class="title function_">setFilterText</span>(value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;filterText&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TextFieldProps에 filterText prop 타입 지정하기</p>
<p>이제 useState는 더 이상 필요 없기 때문에 지워도 된다.</p>
<h3 id="문제는-setFilterText"><a href="#문제는-setFilterText" class="headerlink" title="문제는 setFilterText"></a>문제는 setFilterText</h3><p>데이터를 위에서 아래로 보내는 건 문제 없는데, 함수를 아래서 위로 보내야 하는 상황</p>
<p>이럴 때는 하위 컴포넌트의 props로 함수를 전달한다. (콜백 함수)</p>
<p><img src="/../img/230327/230327-5.png" alt="스크린샷 2023-03-24 오후 3.52.11.png"></p>
<p><img src="/../img/230327/230327-6.png" alt="스크린샷 2023-03-24 오후 3.53.42.png"></p>
<p><img src="/../img/230327/230327-7.png" alt="스크린샷 2023-03-24 오후 3.55.23.png"></p>
<h3 id="filterText-prop을-ProductTable-컴포넌트로-넘겨주기"><a href="#filterText-prop을-ProductTable-컴포넌트로-넘겨주기" class="headerlink" title="filterText prop을 ProductTable 컴포넌트로 넘겨주기"></a>filterText prop을 ProductTable 컴포넌트로 넘겨주기</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ProductTable</span> products=&#123;products&#125; filterText=&#123;filterText&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>이렇게 넘겨주는 방법이 있지만, 또 다른 한 가지 방법은</p>
<p>filterText 값에 해당하는 products만 넘겨주기. (prop을 한개만 넘겨줘도 되는 장점이 있다.)</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">FilterableProductTable</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  products,</span></span><br><span class="line"><span class="params">&#125;: FilterableProductTableProps</span>) &#123;</span><br><span class="line">  <span class="comment">// inStockOnly가 있어야 하는 곳</span></span><br><span class="line">  <span class="comment">// filterText가 있어야 하는 곳</span></span><br><span class="line">  <span class="keyword">const</span> [filterText, setFilterText] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> query = filterText.<span class="title function_">trim</span>().<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">const</span> filteredProducts = !query.<span class="property">length</span></span><br><span class="line">    ? products</span><br><span class="line">    : products.<span class="title function_">filter</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> product.<span class="property">name</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">includes</span>(query));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SearchBar</span> <span class="attr">filterText</span>=<span class="string">&#123;filterText&#125;</span> <span class="attr">setFilterText</span>=<span class="string">&#123;setFilterText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductTable</span> <span class="attr">products</span>=<span class="string">&#123;filteredProducts&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>inStockOnly, setInStockOnly도 동일하게 리팩토링하기</p>
</blockquote>
]]></content>
      <tags>
        <tag>Megaptera</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Thinking in React - React Component🚀</title>
    <url>/2023/230326-archive/</url>
    <content><![CDATA[<h2 id="React-Component"><a href="#React-Component" class="headerlink" title="React Component"></a>React Component</h2><p><strong>Step 1: Break the UI into a component hierarchy</strong></p>
<p><strong>Step 2: Build a static version in React</strong></p>
<p>리액트로 컴포넌트를 만들기 전에 가지고 있어야 하는 것 → JSON API &amp; mockup</p>
<p>데이터 → 백엔드에서 JSON 형태로 데이터를 돌려주는 API를 제공한다고 가정</p>
<ul>
<li>대부분은 REST API 또는 GraphQL</li>
</ul>
<h3 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h3><ul>
<li>fetch API를 이용해서 GET, POST, PUT&#x2F;PATCH, DELETE 요청 (CRUD 구현) ⇒ Resource 중심</li>
</ul>
<h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><ul>
<li>Graph 자료구조를 이용</li>
<li>Query에서 얻고자 하는 것을 지정<ul>
<li>포스트만 가져올건지, 포스트에 딸려있는 댓글까지 가져올건지</li>
</ul>
</li>
<li>Query(Read), Mutation(Command: Create, Update, Delete), Subscription(이벤트를 인지하는 용도)</li>
</ul>
<p>REST API와 GraphQL 둘 다 JSON 형태로 돌려주고 형태는 이런 식</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Apple&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Dragonfruit&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$2&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">&#x27;Passionfruit&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$2&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Spinach&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$4&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">false</span>, <span class="attr">name</span>: <span class="string">&#x27;Pumpkin&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>, <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>, <span class="attr">stocked</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&#x27;Peas&#x27;</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<ul>
<li>실제 JSON에는 key로 사용할 수 있는 것들을 넣어준다.</li>
<li>F&#x2F;E는 이런 데이터를 사용자가 볼 수 있도록 UI를 구성.</li>
<li>React는 선언형으로 UI를 구성할 수 있다. (DSL을 사용, HTML과 유사한 모양)</li>
</ul>
<h3 id="컴포넌트-계층-구조"><a href="#컴포넌트-계층-구조" class="headerlink" title="컴포넌트 계층 구조"></a>컴포넌트 계층 구조</h3><ul>
<li>React의 강력한 특징 중 하나</li>
<li>Component-Based</li>
<li>간단한 컴포넌트의 조립으로 복잡한 UI를 구성한다.<ul>
<li>반대로 말하면 컴포넌트 하나하나는 복잡하지 않아야 한다.</li>
</ul>
</li>
</ul>
<h3 id="간단한-컴포넌트의-기준은"><a href="#간단한-컴포넌트의-기준은" class="headerlink" title="간단한 컴포넌트의 기준은?"></a>간단한 컴포넌트의 기준은?</h3><ul>
<li>SRP(단일 책임 원칙)</li>
<li>CSS → 이미 알고 있는 기준을 재활용.</li>
<li>Design’s Layer</li>
<li>Information Architecture (JSON Schema의 영향) → 실제로 엄청 많이 쓰게 됨. 자연스러운 SRP를 위해서 사실상 강제됨.</li>
</ul>
<p><code>작은 컴포넌트 = 부품</code>을 만들어서 조립. 조합은 가지수를 폭발적으로 늘릴 수 있는 가장 전형적인 방법.</p>
<blockquote>
<p><em><a href="https://bradfrost.com/blog/post/atomic-web-design/">Atomic Design</a>은 우리가 잘 알고 있는 계층형 구조를 몇 가지 카테고리로 묶은 방법.</em></p>
</blockquote>
<p><img src="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui_outline.png" alt="https://beta.reactjs.org/images/docs/s_thinking-in-react_ui_outline.png"></p>
<h2 id="Build-a-static-version-in-React-정적인-것-먼저-만들기"><a href="#Build-a-static-version-in-React-정적인-것-먼저-만들기" class="headerlink" title="Build a static version in React (정적인 것 먼저 만들기)"></a>Build a static version in React (정적인 것 먼저 만들기)</h2><ul>
<li>검색, 체크박스<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;search-bar&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;only-stock&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;only-stock&quot;</span>&gt;</span>Only Show products in stock<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li>테이블<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;table className=<span class="string">&quot;products-tables&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>카테고리<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>Dragonfruit<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<br />

<h3 id="🚀-실제-데이터로-화면에-렌더링하기"><a href="#🚀-실제-데이터로-화면에-렌더링하기" class="headerlink" title="🚀 실제 데이터로 화면에 렌더링하기"></a>🚀 실제 데이터로 화면에 렌더링하기</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;table className=<span class="string">&quot;products-tables&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;products[0].category&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;products.map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ))&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/230326/230326-1.png" alt="."></p>
<dl><dt><code>‘key’ prop</code> 이 필요한 이유</dt><dd>무언가 변경되었을 때 각각을 구분할 수 있는 것이 key의 역할. 그렇기 때문에 key는 unique해야 한다.</dd></dl><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  products.<span class="title function_">map</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<p>카테고리가 2개이기 때문에 카테고리에 맞게 상품 리스트가 보여야 한다.</p>
<ul>
<li><p>카테고리만 가지고 있는 배열을 하나 만들기 (reduce 함수 사용)</p>
<ul>
<li>acc가 category를 갖고 있으면 추가X</li>
<li>category를 갖고 있지 않다면 추가하기</li>
</ul>
</li>
</ul>
 <br />

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> categories = products.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc, product</span>) =&gt;</span></span><br><span class="line">      acc.<span class="title function_">includes</span>(product.<span class="property">category</span>) ? acc : [...acc, product.<span class="property">category</span>],</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생략...</span></span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">className</span>=<span class="string">&quot;products-tables&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;categories[0]&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;products</span></span><br><span class="line"><span class="language-xml">        .filter((product) =&gt; product.category === categories[0])</span></span><br><span class="line"><span class="language-xml">        .map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;categories[1]&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;products</span></span><br><span class="line"><span class="language-xml">        .filter((product) =&gt; product.category === categories[1])</span></span><br><span class="line"><span class="language-xml">        .map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />
코드에 빨간 줄이 가있는 이유

<p><img src="/../img/230326/230326-2.png" alt="스크린샷 2023-03-22 오전 12.12.08.png"></p>
<blockquote>
<p><em>Type ‘string[]’ is missing the following properties from type ‘{ category: string; price: string; stocked: boolean; name: string; }’: category, price, stocked, name</em></p>
</blockquote>
<p>👉🏻 타입이 없다는 얘기</p>
<br />

<p>1️⃣ 첫 번째 해결 방법</p>
<p>: 기본 값을 설정할 때 타입 지정</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> categories = products.<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">acc, product</span>) =&gt;</span> (acc.<span class="title function_">includes</span>(product.<span class="property">category</span>) ? acc : [...acc, product.<span class="property">category</span>]),</span><br><span class="line">  [] <span class="keyword">as</span> string[]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2️⃣ 두 번째 해결 방법</p>
<p>: 매개변수에서 타입 지정</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> categories = products.<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">acc: string[], product</span>) =&gt;</span></span><br><span class="line">    acc.<span class="title function_">includes</span>(product.<span class="property">category</span>) ? acc : [...acc, product.<span class="property">category</span>],</span><br><span class="line">  []</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>3️⃣ 세 번째 해결 방법</p>
<p>: Type or Interface</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="attr">category</span>: string;</span><br><span class="line">	<span class="attr">price</span>: string;</span><br><span class="line">	<span class="attr">stocked</span>: boolean;</span><br><span class="line">	<span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">products</span>: <span class="title class_">Product</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Dragonfruit&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> categories = products.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc: string[], product: Product</span>) =&gt;</span> (acc.<span class="title function_">includes</span>(product.<span class="property">category</span>) ? acc : [...acc, product.<span class="property">category</span>]),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>가장 좋은 방법은 interface.</p>
<p>products에서 name 하나가 빠져있는 상황일 때 오류를 발생시킨다.</p>
<br />

<h2 id="Extract-Fuction"><a href="#Extract-Fuction" class="headerlink" title="Extract Fuction"></a>Extract Fuction</h2><blockquote>
<p><a href="https://refactoring.com/catalog/extractFunction.html">Extract Function</a></p>
</blockquote>
<blockquote>
<p><a href="https://refactoring.com/catalog/inlineFunction.html">Inline Function</a></p>
</blockquote>
<p>아주 흔히 쓰이는 SRP를 위한 수단. 변화의 크기(영향 범위)를 제약한다.</p>
<p>일단 길게 코드를 작성하고, 적절히 자를 수 있는 부분이 보일 때 “함수로 추출”한다. 또는 코드를 작성하기 어려운 상황에 직면했을 때 함수로 추출. 바로 다른 파일을 만들어야 한다고 생각하지 않아도 됨. 컴포넌트 나누는 기준이 애매하면 다시 하나의 컴포넌트로 합쳤다가(Inline Method) 다시 나눠줘도 된다.</p>
<p>현재 App.tsx는 너무 많은 일을 하고 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="attr">category</span>: string;</span><br><span class="line">  <span class="attr">price</span>: string;</span><br><span class="line">  <span class="attr">stocked</span>: boolean;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">products</span>: <span class="title class_">Product</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Apple&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Dragonfruit&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Fruits&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$2&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Passionfruit&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$2&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Spinach&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$4&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Pumpkin&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">category</span>: <span class="string">&#x27;Vegetables&#x27;</span>,</span><br><span class="line">    <span class="attr">price</span>: <span class="string">&#x27;$1&#x27;</span>,</span><br><span class="line">    <span class="attr">stocked</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Peas&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> categories = products.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc: string[], product: Product</span>) =&gt;</span></span><br><span class="line">      acc.<span class="title function_">includes</span>(product.<span class="property">category</span>) ? acc : [...acc, product.<span class="property">category</span>],</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(categories);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;filterable-product-table&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;seach-bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;only-stock&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;only-stock&quot;</span>&gt;</span>Only Show products in stock<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">table</span> <span class="attr">className</span>=<span class="string">&quot;product-table&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;products[0].category&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;products</span></span><br><span class="line"><span class="language-xml">            .filter((product) =&gt; product.category === categories[0])</span></span><br><span class="line"><span class="language-xml">            .map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;categories[1]&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;products</span></span><br><span class="line"><span class="language-xml">            .filter((product) =&gt; product.category === categories[1])</span></span><br><span class="line"><span class="language-xml">            .map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SRP 원칙을 위반하고 있는 상태.</li>
<li>재사용할 수 있도록 컴포넌트 분리하기</li>
</ul>
<h3 id="🚀-분리할-컴포넌트-👉🏻-상품이름-가격을-나타내는-부분"><a href="#🚀-분리할-컴포넌트-👉🏻-상품이름-가격을-나타내는-부분" class="headerlink" title="🚀 분리할 컴포넌트 👉🏻 상품이름, 가격을 나타내는 부분"></a>🚀 분리할 컴포넌트 👉🏻 상품이름, 가격을 나타내는 부분</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;categories[1]&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line">&lt;/tr&gt;;</span><br><span class="line">&#123;</span><br><span class="line">  products</span><br><span class="line">    .<span class="title function_">filter</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> product.<span class="property">category</span> === categories[<span class="number">1</span>])</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">product</span>) =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProductInCategory</span>(<span class="params">&#123; category, products &#125;: ProductsInCategoryProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> productsInCategory = products.<span class="title function_">filter</span>(</span><br><span class="line">    <span class="function">(<span class="params">product</span>) =&gt;</span> product.<span class="property">category</span> === category</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;products[0].category&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;productsInCategory.map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>컴포넌트를 사용하려면?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ProductInCategory</span> category=&#123;categories[<span class="number">0</span>]&#125; products=&#123;products&#125; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;table className=<span class="string">&quot;product-table&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ProductInCategory</span> <span class="attr">category</span>=<span class="string">&#123;categories[0]&#125;</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ProductInCategory</span> <span class="attr">category</span>=<span class="string">&#123;categories[1]&#125;</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>ProductInCategory 컴포넌트가 반복되고 있으므로 map 함수를 사용한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  categories.<span class="title function_">map</span>(<span class="function">(<span class="params">category</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ProductInCategory</span> <span class="attr">key</span>=<span class="string">&#123;category&#125;</span> <span class="attr">category</span>=<span class="string">&#123;category&#125;</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> /&gt;</span></span></span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProductInCategory-컴포넌트-외부로-추출하기"><a href="#ProductInCategory-컴포넌트-외부로-추출하기" class="headerlink" title="ProductInCategory 컴포넌트 외부로 추출하기"></a>ProductInCategory 컴포넌트 외부로 추출하기</h3><p><img src="/../img/230326/230326-3.png" alt="스크린샷 2023-03-23 오전 10.08.32.png"></p>
<p>👉🏻 type이 없다는 오류</p>
<p>이전에 썼던 interface Product는 App에서도 쓰고 있고, ProductInCategory 컴포넌트에서도 사용해야 한다.</p>
<p>이때 여러 타입을 관리할 수 있도록 types라는 폴더에 넣어놓는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="attr">category</span>: string;</span><br><span class="line">  <span class="attr">price</span>: string;</span><br><span class="line">  <span class="attr">stocked</span>: boolean;</span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Product</span>;</span><br></pre></td></tr></table></figure>

<p>ProductInCategory에 있는 product.name과 product.price도 컴포넌트로 처리할 수 있다.</p>
<p><img src="/../img/230326/230326-4.png" alt="스크린샷 2023-03-23 오전 10.26.06.png"></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&#x27;../types/Product&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProductRow</span>(<span class="params">&#123; product &#125;: &#123; product: Product &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&#123; product: Product &#125;</code> 이 부분도 따로 빼주기</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">type <span class="title class_">ProductRowProps</span> = &#123;</span><br><span class="line">  <span class="attr">product</span>: <span class="title class_">Product</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProductRow</span>(<span class="params">&#123; product &#125;: ProductRowProps</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;product.price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Category-컴포넌트-만들기-👉🏻-상품-카테고리-정보를-가지고-있는-컴포넌트"><a href="#Category-컴포넌트-만들기-👉🏻-상품-카테고리-정보를-가지고-있는-컴포넌트" class="headerlink" title="Category 컴포넌트 만들기 👉🏻 상품 카테고리 정보를 가지고 있는 컴포넌트"></a>Category 컴포넌트 만들기 👉🏻 상품 카테고리 정보를 가지고 있는 컴포넌트</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Category</span> category=&#123;category&#125; /&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Category</span>(<span class="params">&#123; category &#125;: &#123; category: string &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">colSpan</span>=<span class="string">&#123;2&#125;</span>&gt;</span>&#123;category&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+) 우리가 데이터를 한 번 정리할 수 있다면 다른 방식으로 컴포넌트를 만들 수 있다.데이터를 받아온 그대로 사용하고 있는데 데이터를 가공해서 사용할 수 있다.</p>
<ul>
<li>category가 products를 가지고 있게 되면?</li>
</ul>
<h3 id="ProductTable-컴포넌트-만들기"><a href="#ProductTable-컴포넌트-만들기" class="headerlink" title="ProductTable 컴포넌트 만들기"></a>ProductTable 컴포넌트 만들기</h3><p><img src="/../img/230326/230326-5.png" alt="스크린샷 2023-03-23 오전 10.59.45.png"></p>
<p><code>.filterable-product-table</code> 부분에선 category를 쓰고 있지 않으니 categories를 ProductTable 컴포넌트 안으로 넣는다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ProductTable</span>(<span class="params">&#123; products &#125;: &#123; products: Product[] &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> categories = products.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">acc: string[], product: Product</span>) =&gt;</span></span><br><span class="line">      acc.<span class="title function_">includes</span>(product.<span class="property">category</span>) ? acc : [...acc, product.<span class="property">category</span>],</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">className</span>=<span class="string">&quot;product-table&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;categories.map((category) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ProductInCategory</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">key</span>=<span class="string">&#123;category&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">category</span>=<span class="string">&#123;category&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">products</span>=<span class="string">&#123;products&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          /&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="products-filter-함수-부분을-따로-추출하는-예제"><a href="#products-filter-함수-부분을-따로-추출하는-예제" class="headerlink" title="products.filter() 함수 부분을 따로 추출하는 예제:"></a><code>products.filter()</code> 함수 부분을 따로 추출하는 예제:</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ProductInCategory</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  category,</span></span><br><span class="line"><span class="params">  products,</span></span><br><span class="line"><span class="params">&#125;: ProductsInCategoryProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> productsInCategory = products.<span class="title function_">filter</span>(</span><br><span class="line">    <span class="function">(<span class="params">product</span>) =&gt;</span> product.<span class="property">category</span> === category</span><br><span class="line">  ); <span class="comment">// -&gt; 이 부분을 따로 추출하기</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Category</span> <span class="attr">category</span>=<span class="string">&#123;category&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;productsInCategory.map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ProductCategoryRow</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span> <span class="attr">product</span>=<span class="string">&#123;product&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>utils &gt; select.ts 생성</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">select</span>(<span class="params">items: any[], field: string, value: any</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> items.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item[field] === value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> productsInCategory = products.<span class="title function_">filter</span>(</span><br><span class="line">  <span class="function">(<span class="params">product</span>) =&gt;</span> product.<span class="property">category</span> === category</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">⬇️</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> productsInCategory = <span class="title function_">selectProducts</span>(products, <span class="string">&#x27;category&#x27;</span>, category);</span><br></pre></td></tr></table></figure>

<h3 id="SearchBar-컴포넌트-추출"><a href="#SearchBar-컴포넌트-추출" class="headerlink" title="SearchBar 컴포넌트 추출"></a>SearchBar 컴포넌트 추출</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">SearchBar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;seach-bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;only-stock&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;only-stock&quot;</span>&gt;</span>Only Show products in stock<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FilterableProductTable-컴포넌트-추출"><a href="#FilterableProductTable-컴포넌트-추출" class="headerlink" title="FilterableProductTable 컴포넌트 추출"></a>FilterableProductTable 컴포넌트 추출</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ProductTable</span> <span class="keyword">from</span> <span class="string">&#x27;./ProductTable&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">SearchBar</span> <span class="keyword">from</span> <span class="string">&#x27;./SearchBar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&#x27;../types/Product&#x27;</span>;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">FilterableProductTableProps</span> = &#123;</span><br><span class="line">  <span class="attr">products</span>: <span class="title class_">Product</span>[],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">FilterableProductTable</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  products,</span></span><br><span class="line"><span class="params">&#125;: FilterableProductTableProps</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SearchBar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductTable</span> <span class="attr">products</span>=<span class="string">&#123;products&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App 컴포넌트가 굉장히 깔끔해진 것을 볼 수 있다.</p>
<p><img src="/../img/230326/230326-6.png" alt="스크린샷 2023-03-23 오후 9.54.44.png"></p>
<br />

<blockquote>
<p>🔥 Props를 개별적으로 넘겨줄 수 있는 방법도 있다.</p>
</blockquote>
<p>예를 들어, <code>ProductInCategory</code> 컴포넌트에서 <code>product=&#123;product&#125;</code> 로 넘겨주는 것이 아니라 개별적으로 넘겨줄 수도 있다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Category</span> <span class="attr">category</span>=<span class="string">&#123;category&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;productsInCategory.map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductCategoryRow</span> <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span> <span class="attr">product</span>=<span class="string">&#123;product&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    ))&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------------------------------------------ */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Category</span> <span class="attr">category</span>=<span class="string">&#123;category&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;productsInCategory.map((product) =&gt; (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ProductCategoryRow</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">key</span>=<span class="string">&#123;product.name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&#123;product.name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">price</span>=<span class="string">&#123;product.price&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    ))&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>하지만 typeScript를 사용할 땐 전체를 넘겨주는 것이 더 강력하기 때문에 추천한다.</p>
<p>예를 들어 products 요소에 isStocked라는 속성이 하나 더 추가된다고 가정해보자. 이때 props를 개별적으로 넘겨줬다면 interface 뿐만 아니라 props도 수정을 해야하는 번거로움이 생긴다.</p>
<h3 id="CheckBoxField-컴포넌트-추출하기"><a href="#CheckBoxField-컴포넌트-추출하기" class="headerlink" title="CheckBoxField 컴포넌트 추출하기"></a>CheckBoxField 컴포넌트 추출하기</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CheckBoxField</span>(<span class="params">&#123; label &#125;: &#123; label: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="string">`checkbox-<span class="subst">$&#123;label&#125;</span>`</span>.<span class="title function_">replace</span>(<span class="regexp">/ /g</span>, <span class="string">&#x27;-&#x27;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&#123;id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&#123;id&#125;</span>&gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">SearchBar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;seach-bar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CheckBoxField</span> <span class="attr">label</span>=<span class="string">&quot;Only Show products in stock&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const id = </code>checkbox-${label}<code>.replace(/ /g, &#39;-&#39;).toLowerCase();</code> 와 같은 코드는 React에선 useRef를 사용한다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="title function_">useRef</span>(<span class="string">`checkbox-<span class="subst">$&#123;label&#125;</span>`</span>.<span class="title function_">replace</span>(<span class="regexp">/ /g</span>, <span class="string">&#x27;-&#x27;</span>).<span class="title function_">toLowerCase</span>());</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&#123;id.current&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&#123;id.current&#125;</span>&gt;</span>&#123;label&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Megaptera</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>REST API가 무엇인가 (부제: 그런 REST API로 괜찮은가)</title>
    <url>/2023/230329-archive/</url>
    <content><![CDATA[<p>REST API가 어떤 배경에서 나온건지부터 알아보자</p>
<h2 id="WEB-1991-어떻게-인터넷에서-정보를-공유할-것인가"><a href="#WEB-1991-어떻게-인터넷에서-정보를-공유할-것인가" class="headerlink" title="WEB (1991) - 어떻게 인터넷에서 정보를 공유할 것인가?"></a>WEB (1991) - 어떻게 인터넷에서 정보를 공유할 것인가?</h2><p>정보들을 하이퍼텍스트로 연결한다!</p>
<ul>
<li>표현형식: HTML</li>
<li>식별자: URI</li>
<li>전송방법: HTTP</li>
</ul>
<h2 id="HTTP-x2F-1-0-1994-1996"><a href="#HTTP-x2F-1-0-1994-1996" class="headerlink" title="HTTP&#x2F;1.0 (1994-1996)"></a>HTTP&#x2F;1.0 (1994-1996)</h2><p>이미 HTTP는 W3C의 전송 프로토콜로 이용이 되고 있었고, 웹은 급속도로 성장중인 시점</p>
<p>당시 대학원생이었던 Roy T.Fielding은 HTTP를 정립하고 명서에 기능을 더하고 고쳐야하는 상황에 모이게 됨</p>
<p>💬 기존에 이미 구축되어있는 웹을 망가뜨리지 않고 HTTP를 개선할 수 있을까?</p>
<p>해결책: HTTP Object Model</p>
<h2 id="REST-1998"><a href="#REST-1998" class="headerlink" title="REST (1998)"></a>REST (1998)</h2><p>Roy T.Fielding, Microsoft Research에서 발표</p>
<h2 id="REST-2000"><a href="#REST-2000" class="headerlink" title="REST (2000)"></a>REST (2000)</h2><p>Roy T.Fielding, 2년 뒤에 박사 논문으로 발표</p>
<ul>
<li>우리가 알고 있는 REST를 정의하고 있는 논문</li>
<li>“Architectural Styles and the Design of Network-based Software Architectures”</li>
</ul>
<h3 id="한편-인터넷-상에-API라는-것이-만들어지기-시작했다"><a href="#한편-인터넷-상에-API라는-것이-만들어지기-시작했다" class="headerlink" title="한편.. 인터넷 상에 API라는 것이 만들어지기 시작했다."></a>한편.. 인터넷 상에 API라는 것이 만들어지기 시작했다.</h3><h2 id="XML-RPC-1998"><a href="#XML-RPC-1998" class="headerlink" title="XML-RPC (1998)"></a>XML-RPC (1998)</h2><p>by Microsoft</p>
<p>이후에 SOAP이라는 이름으로 바뀜</p>
<h2 id="Salesforce-API-2000-02"><a href="#Salesforce-API-2000-02" class="headerlink" title="Salesforce API (2000. 02)"></a>Salesforce API (2000. 02)</h2><p>Salesforce라는 회사에서 API를 공개</p>
<ul>
<li>인터넷에서 최초로 공개된 API</li>
<li>당시에 SOAP을 사용해서 API를 만듦</li>
<li>너무 복잡에서 장사가 잘 안됨</li>
</ul>
<h2 id="flickr-API-2004-08"><a href="#flickr-API-2004-08" class="headerlink" title="flickr API (2004. 08)"></a>flickr API (2004. 08)</h2><ul>
<li>다양한 형태로 API를 만듦</li>
<li>SOAP 형태 + REST 형태 <em>(사실 REST는 2000년에 나왔지만 사람들은 새롭게 느낌)</em></li>
</ul>
<p>사람들이 느끼는 SOAP과 REST 형태</p>
<p>SOAP</p>
<ul>
<li>복잡하다</li>
<li>규칙이 많다</li>
<li>어렵다</li>
</ul>
<p>REST</p>
<ul>
<li>단순하다</li>
<li>규칙이 적다</li>
<li>쉽다</li>
</ul>
<h3 id="결국"><a href="#결국" class="headerlink" title="결국"></a>결국</h3><ul>
<li>2006년, AWS가 자사 API 사용량의 85%가 REST임을 밝힘</li>
<li>2010년, Salesforce.com도 REST API 추가</li>
</ul>
<h3 id="REST의-승리로-해피엔딩인줄-알았는데"><a href="#REST의-승리로-해피엔딩인줄-알았는데" class="headerlink" title="REST의 승리로 해피엔딩인줄 알았는데.."></a>REST의 승리로 해피엔딩인줄 알았는데..</h3><h2 id="CMIS-2008"><a href="#CMIS-2008" class="headerlink" title="CMIS (2008)"></a>CMIS (2008)</h2><ul>
<li>CMS를 위한 표준</li>
<li>EMC, IBM, Microsoft 등이 함께 작업</li>
<li>REST 바인딩 지원</li>
</ul>
<p>하지만 Roy T.Fielding은 ‘CMIS에는 REST가 없다’라고 말함</p>
<h2 id="Microsoft-REST-API-Guidlines-2016"><a href="#Microsoft-REST-API-Guidlines-2016" class="headerlink" title="Microsoft REST API Guidlines (2016)"></a>Microsoft REST API Guidlines (2016)</h2><ul>
<li>url은 https:&#x2F;&#x2F;{serviceRoot}&#x2F;{collection}&#x2F;{id} 형식이어야 한다.</li>
<li>GET, PUT, DELETE, POST, PATCH, HEAD, OPTIONS를 지원해야 한다.</li>
<li>API 버저닝은 Major.minor로 하고 uri에 버전 정보를 포함시킨다.</li>
</ul>
<p>사람들이 보기엔 합리적인 이야기처럼 보임.</p>
<p>하지만 Roy T.Fielding은 ‘이건 REST API가 아님, HTTP API라고 해야함’이라고 말함</p>
<h3 id="‘REST-API는-반드시-HyperText-driven이어야-한다’"><a href="#‘REST-API는-반드시-HyperText-driven이어야-한다’" class="headerlink" title="‘REST API는 반드시 HyperText-driven이어야 한다’"></a>‘REST API는 반드시 HyperText-driven이어야 한다’</h3><h3 id="‘REST-API를-위한-최고의-버저닝-전략은-버저닝을-하지-않는-것’"><a href="#‘REST-API를-위한-최고의-버저닝-전략은-버저닝을-하지-않는-것’" class="headerlink" title="‘REST API를 위한 최고의 버저닝 전략은 버저닝을 하지 않는 것’"></a>‘REST API를 위한 최고의 버저닝 전략은 버저닝을 하지 않는 것’</h3><p>사람들이 알고있던 REST하고 REST를 만들었던 Roy T.Fielding이 말하는 REST와의 차이가 점점 생기는 것 같은데? 문제가 무엇일까? REST API를 따져보자</p>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>REST 아키텍쳐 스타일을 따른 API</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>분산 하이퍼미디어 시스템(웹)을 위한 아키텍쳐 스타일</p>
<h2 id="아키텍쳐-스타일"><a href="#아키텍쳐-스타일" class="headerlink" title="아키텍쳐 스타일"></a>아키텍쳐 스타일</h2><p>제약 조건의 집합</p>
<p>(사실 REST는 아키텍쳐 스타일이면서 동시에 하이브리드 아키텍쳐 스타일이라고 말한다. 아키텍쳐 스타일인데 동시에 아키텍쳐 스타일의 집합이기 때문) 👉🏻 무슨말?</p>
<h3 id="REST를-구성하는-스타일"><a href="#REST를-구성하는-스타일" class="headerlink" title="REST를 구성하는 스타일"></a>REST를 구성하는 스타일</h3><ul>
<li>client-server</li>
<li>stateless</li>
<li>cache</li>
<li><strong>uiform interface</strong></li>
<li>layered system</li>
<li>code-on-demand (optional) ➡️ 서버에서 코드를 클라이언트한테 보내서 실행할 수 있어야한다.<em>(자바스크립트)</em></li>
</ul>
<p>HTTP API만 지켜도 대부분의 아키텍쳐 스타일을 지킬 수 있지만 uinform interface를 잘 지키지 못함</p>
<h2 id="Uniform-Interface의-제약-조건"><a href="#Uniform-Interface의-제약-조건" class="headerlink" title="Uniform Interface의 제약 조건"></a>Uniform Interface의 제약 조건</h2><ul>
<li>리소스가 URI로 식별되면 된다.</li>
<li>리소스를 만들거나 업데이트하거나 삭제할 때 HTTP 메세지에 표현을 담아서 전송을 해야한다.</li>
<li><strong>self-descriptive messages</strong></li>
<li><strong>hypermedia as the engine of application state (HATEOAS)</strong></li>
</ul>
<p>👉🏻 나머지 두 개는 거의 지켜지지 못한다.</p>
<h3 id="self-descriptive-messages"><a href="#self-descriptive-messages" class="headerlink" title="self-descriptive messages"></a><strong>self-descriptive messages</strong></h3><p>메세지는 스스로를 설명해야 한다.</p>
<p>이 HTTP 요청 메세지는 뭔가 빠져있어서 self-descriptive하지 못하다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span> / <span class="number">1.1</span>;</span><br></pre></td></tr></table></figure>

<p>목적지가 빠져있음</p>
<p>목적지를 추가하면? self-descriptive 함</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span> / <span class="number">1.1</span>;</span><br><span class="line"><span class="attr">HOST</span>: www.<span class="property">example</span>.<span class="property">org</span>;</span><br></pre></td></tr></table></figure>

<p>아래는 왜 self-descriptive 하지 못할까?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/a/b/c&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<p>클라이언트가 이 응답을 받고 해석해야하는데 어떤 문법으로 작성되었는지 모르기 때문에 self-descriptive하지 못하다고 말함</p>
<p>우선 Content-Type이 반드시 들어가야 한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/a/b/c&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json.<span class="property">patch</span>+json</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/a/b/c&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<h3 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h3><p>애플리케이션 상태는 Hyperlink를 이용해 전이되어야 한다.</p>
<p>하나의 게시판 애플리케이션을 떠올려보자.</p>
<p>글 목록 보기를 클릭하면 글 목록이 있는 페이지가 보여지고, 글 쓰기 버튼을 누르면 글 쓰기 페이지, 저장 버튼을 누르면 글 저장완료 안내 페이지가 나온다.</p>
<p>이것을 <code>애플리케이션 상태의 전이</code>라고 하는데 이 상태의 전이 마다 해당 페이지에 있던 링크를 따라가기 때문에 HATEOAS가 된다고 말할 수 있다.</p>
<h2 id="왜-Uniform-Interface를-해야하는가"><a href="#왜-Uniform-Interface를-해야하는가" class="headerlink" title="왜 Uniform Interface를 해야하는가?"></a>왜 Uniform Interface를 해야하는가?</h2><h3 id="독립적-진화를-하기-위해서"><a href="#독립적-진화를-하기-위해서" class="headerlink" title="독립적 진화를 하기 위해서"></a>독립적 진화를 하기 위해서</h3><ul>
<li>서버와 클라이언트가 각각 독립적으로 진화한다.</li>
<li>서버의 기능이 변경되어도 클라이언트를 업데이트할 필요가 없다.</li>
<li>이것이 바로 REST를 만들게 된 계기: “How do I imporve HTTP without breaking the Web”</li>
</ul>
<h2 id="실제로-REST가-잘-지켜지고-있는가"><a href="#실제로-REST가-잘-지켜지고-있는가" class="headerlink" title="실제로 REST가 잘 지켜지고 있는가?"></a>실제로 REST가 잘 지켜지고 있는가?</h2><p>잘 지켜지고 있는 사례로는 웹이 있다.</p>
<h3 id="웹"><a href="#웹" class="headerlink" title="웹"></a>웹</h3><ul>
<li>웹페이지를 변경했다고 브라우저를 업데이트할 필요는 없다.</li>
<li>웹 브라우저를 업데이트했다고 웹 페이지를 변경할 필요도 없다.</li>
<li>HTTP 명세가 변경되어도 웹은 잘 동작한다.</li>
<li>HTML 명세가 변경되어도 웹은 잘 동작한다.</li>
</ul>
<h3 id="이건-진짜-피땀흘려-노력한-결과다"><a href="#이건-진짜-피땀흘려-노력한-결과다" class="headerlink" title="이건 진짜 피땀흘려 노력한 결과다."></a>이건 진짜 피땀흘려 노력한 결과다.</h3><ul>
<li>HTML5 첫 초안에서 권고안 나오는데까지 6년</li>
<li>HTTP&#x2F;1.1 명세 개정판 작업하는데 7년</li>
</ul>
<h3 id="왜-이렇게-오래걸림-상호운용성에-대한-집착"><a href="#왜-이렇게-오래걸림-상호운용성에-대한-집착" class="headerlink" title="왜 이렇게 오래걸림? 상호운용성에 대한 집착"></a>왜 이렇게 오래걸림? 상호운용성에 대한 집착</h3><p>하위 호환성을 지키기 위해 수정할 수 없는 것들</p>
<ul>
<li>Referer 오타지만 못 고침</li>
<li>charset 잘못 지은 이름이지만 못 고침</li>
<li>HTTP 상태 코드 416 포기</li>
<li>HTTP&#x2F;0.9 아직도 지원함(크롬, 파이어폭스)</li>
</ul>
<p>그런 노력이 없으면? 웹도 지원하지 않는다는 경고창을 볼 수 있다.</p>
<h3 id="REST가-웹의-독립적-진화에-도움을-주었나"><a href="#REST가-웹의-독립적-진화에-도움을-주었나" class="headerlink" title="REST가 웹의 독립적 진화에 도움을 주었나?"></a>REST가 웹의 독립적 진화에 도움을 주었나?</h3><ul>
<li>HTTP에 지속적으로 영향을 줌</li>
<li>HOST 헤더 추가</li>
<li>길이 제한을 다루는 방법이 명시</li>
<li>URI에서 리소스의 정의가 추상적으로 변경됨: “식별하고자 하는 무언가”</li>
<li>기타 HTTP와 URI에 많은 영향을 줌</li>
</ul>
<h3 id="그럼-REST는-성공했는가"><a href="#그럼-REST는-성공했는가" class="headerlink" title="그럼 REST는 성공했는가"></a>그럼 REST는 성공했는가</h3><ul>
<li>REST는 웹의 독립적 진화를 위해 만들어졌다.</li>
<li>웹은 독립적으로 진화하고 있다.</li>
</ul>
<p>그럼 성공!</p>
<h2 id="그런데-REST-API는"><a href="#그런데-REST-API는" class="headerlink" title="그런데 REST API는?"></a>그런데 REST API는?</h2><ul>
<li>REST API는 REST 아키텍쳐 스타일을 따라야한다.</li>
<li>오늘날 스스로 REST API라고 하는 API들이 REST 아키텍쳐 스타일을 따르지 않는다.</li>
</ul>
<h2 id="REST-API도-제약-조건들을-다-지켜야-하는가"><a href="#REST-API도-제약-조건들을-다-지켜야-하는가" class="headerlink" title="REST API도 제약 조건들을 다 지켜야 하는가?"></a>REST API도 제약 조건들을 다 지켜야 하는가?</h2><p>꼭 다 지켜야 하는건가? 👉🏻 로이 필딩: 지켜야 함 ㅇㅅㅇ</p>
<p>SOAP이 규칙이 어렵고 REST는 쉬운 줄 알았는데 REST도 어려운거였네?</p>
<h3 id="꼭-REST-API여야-하는건가"><a href="#꼭-REST-API여야-하는건가" class="headerlink" title="꼭 REST API여야 하는건가?"></a>꼭 REST API여야 하는건가?</h3><p>로이 필딩: 꼭 지켜야 하는 것은 아님. 시스템 전체를 통제할 수 있다고 생각하거나, 진화에 관심이 없다면 REST에 대해 따지느라 시간을 낭비하지 마라.</p>
<h2 id="그럼-이제-어떻게-할까"><a href="#그럼-이제-어떻게-할까" class="headerlink" title="그럼 이제 어떻게 할까?"></a>그럼 이제 어떻게 할까?</h2><ol>
<li>REST API를 구현하고 REST API라고 부른다.</li>
<li>REST API 구현을 포기하고 HTTP API라고 부른다.</li>
<li>REST API가 아니지만 REST API라고 부른다.</li>
</ol>
<p>당신의 선택은?</p>
<p>현재 상태는 3번이 대부분이다.</p>
<h2 id="도전-REST-API를-구현해보자"><a href="#도전-REST-API를-구현해보자" class="headerlink" title="도전, REST API를 구현해보자."></a>도전, REST API를 구현해보자.</h2><h3 id="일단-왜-API는-REST가-잘-안되는걸까"><a href="#일단-왜-API는-REST가-잘-안되는걸까" class="headerlink" title="일단 왜 API는 REST가 잘 안되는걸까?"></a>일단 왜 API는 REST가 잘 안되는걸까?</h3><p>일반적인 웹과 비교를 해보면 웹은 기계와 사람이 커뮤니케이션하는 것이지만 API는 기계와 기계가 커뮤니케이션을 한다.</p>
<p>그러므로 Media Type 또한 웹 페이지는 HTML을 사용하지만 API는 JSON을 사용한다.</p>
<p><img src="/../img/230329/2023-03-29-14-54-38.png" alt="스크린샷.png"></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Self-descriptive"><a href="#Self-descriptive" class="headerlink" title="Self-descriptive"></a>Self-descriptive</h3><ol>
<li>응답 메세지의 Content-Type을 보고 media type을 확인</li>
<li>HTTP 명세에 media type은 IANA에 등록되어 있다고 하므로 application&#x2F;json의 설명을 찾음</li>
<li>명세에 json 문서를 파싱하는 방법이 명시되어 있으므로 성공적으로 파싱. <strong>하지만 “id”가 무엇을 의미하고, “title”이 무엇을 의미하는지 알 방법이 없음</strong></li>
</ol>
<h3 id="HATEOAS-1"><a href="#HATEOAS-1" class="headerlink" title="HATEOAS"></a>HATEOAS</h3><p>다음 상태로 전이할 링크가 없다.</p>
<h2 id="Self-decriptive와-HATEOAS가-독립적-진화에-어떻게-도움이-된다는-걸까"><a href="#Self-decriptive와-HATEOAS가-독립적-진화에-어떻게-도움이-된다는-걸까" class="headerlink" title="Self-decriptive와 HATEOAS가 독립적 진화에 어떻게 도움이 된다는 걸까?"></a>Self-decriptive와 HATEOAS가 독립적 진화에 어떻게 도움이 된다는 걸까?</h2><ul>
<li>서버나 클라이언트가 변경되더라도 오고가는 메세지는 언제나 해석이 가능하다.</li>
<li>어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서 전이될 수 있는 상태가 결정된다. 즉, 링크를 마음대로 바꿀 수 있다. ‘</li>
</ul>
<h2 id="그럼-REST-API로-고쳐보자"><a href="#그럼-REST-API로-고쳐보자" class="headerlink" title="그럼 REST API로 고쳐보자"></a>그럼 REST API로 고쳐보자</h2><h2 id="Self-descriptive-1"><a href="#Self-descriptive-1" class="headerlink" title="Self-descriptive"></a>Self-descriptive</h2><h3 id="방법-1-Media-type"><a href="#방법-1-Media-type" class="headerlink" title="방법 1. Media type"></a>방법 1. Media type</h3><ol>
<li>미디어 타입을 하나 정의한다.</li>
<li>미디어 타입 문서를 작성한다. 이 문서에 id가 뭐고 title이 뭔지 의미를 정의한다.</li>
<li>IANA에 미디어 타입을 등록한다. 이 때 만든 문서를 미디어 타입의 명세로 등록한다.</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line">**<span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/vnd.<span class="property">todos</span>+json**</span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>단점: 매번 media type을 정의해야한다.</p>
<h3 id="방법-2-Profile"><a href="#방법-2-Profile" class="headerlink" title="방법 2. Profile"></a>방법 2. Profile</h3><ol>
<li>id가 뭐고 title이 뭔지 의미를 정의한 명세를 작성한다.</li>
<li>Link 헤더에 profile relation으로 해당 명세를 링크한다.</li>
<li>이제 메시지를 보는 사람은 명세를 찾아갈 수 있으므로 이 문서의 의미를 온전히 해석할 수 있다.</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/json</span><br><span class="line"><span class="title class_">Link</span>: <span class="language-xml">&lt;https://example.org/docs/todos&gt;</span> rel=<span class="string">&quot;profile&quot;</span></span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>단점: Content negotiation을 할 수 없다. (링크로 만들어놨기 때문)</p>
<h2 id="HATEOAS-2"><a href="#HATEOAS-2" class="headerlink" title="HATEOAS"></a>HATEOAS</h2><h3 id="방법1-data로"><a href="#방법1-data로" class="headerlink" title="방법1. data로"></a>방법1. data로</h3><p>data에 다양한 방법으로 하이퍼링크를 표현한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/json</span><br><span class="line"><span class="title class_">Link</span>: <span class="language-xml">&lt;https://example.org/docs/todos&gt;</span> rel=<span class="string">&quot;profile&quot;</span></span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;link&quot;</span> : <span class="string">&quot;https://example.org/todos/&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>단점: 링크를 표현하는 방법을 직접 정의해야한다.</p>
<h3 id="방법2-HTTP-헤더로"><a href="#방법2-HTTP-헤더로" class="headerlink" title="방법2. HTTP 헤더로"></a>방법2. HTTP 헤더로</h3><p>Link, Location을 추가로 넣어준다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/json</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;title&quot;</span>: <span class="string">&quot;점심 약속&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">204</span> <span class="title class_">No</span> <span class="title class_">Content</span></span><br><span class="line"><span class="title class_">Location</span>: <span class="regexp">/todos/</span><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>오늘날의 대부분 “REST API”는 사실 REST를 따르고 있지 않다.</li>
<li>REST 제약 조건 중에서 Self-descriptive와 HATEOAS를 잘 만족하지 못한다.</li>
<li>REST는 긴 수년간 진화하는 웹 애플리케이션을 위한 것</li>
<li>REST를 따를 것인지는 API를 설계하는 이들이 스스로 판단하여 결정해야 한다.</li>
<li>REST를 따르겠다면 Self-descriptive와 HATEOAS를 만족시켜야 한다.</li>
<li>따르지 않겠다면 REST API를 뭐라고 부를지 결정하자.</li>
</ul>
<hr>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>5년 전 컨퍼런스 영상이지만 이것만큼 REST API에 대해 잘 설명해주는 영상이 없는 것 같아 영상을 보면서 스스로 정리해보는 시간을 가졌다.</p>
<p>REST가 무엇인지 그래서 오늘날의 REST API는 REST한지에 대해서 다시 한 번 생각해보는 시간을 가지게 되었다.</p>
<h2 id="Referrence"><a href="#Referrence" class="headerlink" title="Referrence"></a>Referrence</h2><p><a href="https://www.youtube.com/watch?v=RP_f5dMoHFc">그런 REST API로 괜찮은가</a></p>
]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>컴포넌트 합성(Compoistion) 사용법 알려드립니다. 🚗</title>
    <url>/2023/230330-1-archive/</url>
    <content><![CDATA[<h1 id="Composition-vs-Inheritance"><a href="#Composition-vs-Inheritance" class="headerlink" title="Composition vs Inheritance"></a>Composition vs Inheritance</h1><p>🚀 리액트에서 컴포넌트를 어떻게 구성해서 사용하는지 <strong>두 가지 방법</strong>에 대해 비교하면서 공부하기</p>
<h2 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h2><p>: 여러 개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것을 의미</p>
<p>👉🏻 구성이라는 뜻 보단 합성이라는 뜻에 가까움</p>
<br />

<p><img src="/../img/230330/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%203.png" alt="스크린샷.png"></p>
<p>A라는 컴포넌트와 B라는 컴포넌트가 반복된다. 하나의 페이지 자체도</p>
<p>페이지 자체도 컴포넌트로 구성되어있다.</p>
<p>결국 컴포넌트 A와 컴포넌트 B를 합쳐 페이지 컴포넌트를 만든 것.</p>
<p>👉🏻 즉, Composition을 사용</p>
<br />

<p>리액트로 개발하다보면 여러개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 일이 많다. 그래서 합성은 리액트 전반에 걸쳐 많이 사용함</p>
<p>composition이라고 해서 무작정 컴포넌트를 여러개 붙이는 것이 아니라 어떻게 컴포넌트를 조합할 것인가?에 대한 고민이 필요하다.</p>
<br />

<h2 id="Composition에도-사용기법이-있다"><a href="#Composition에도-사용기법이-있다" class="headerlink" title="Composition에도 사용기법이 있다."></a>Composition에도 사용기법이 있다.</h2><h3 id="Containment"><a href="#Containment" class="headerlink" title="Containment"></a>Containment</h3><p>방지, 견제라는 뜻. 하지만 여기에서는 contain(담다, 포함하다)의 의미를 가지고 있음</p>
<blockquote>
<p><strong>하위 컴포넌트를 포함</strong>하는 형태의 합성 방법</p>
</blockquote>
<p>보통 Sidebar나 Dialog 같은 박스 형태의 컴포넌트는 자신의 하위 컴포넌트를 미리 알 수 없다.</p>
<p>예를 들어 2개의 쇼핑몰 사이트를 만들어야 하는데 동일한 Sidebar 컴포넌트를 사용하는 쇼핑몰이 있다고 가정해보자. 의류 쇼핑몰에는 의류와 관련된 메뉴가 8개 있고, 다른 쇼핑몰에는 식료품과 관련된 메뉴가 10개 있다.</p>
<p>Sidebar 컴포넌트: 뭐가 올지 나는 모르는데? ㅇㅅㅇ</p>
<p>해당 컴포넌트를 사용하는 개발자가 어떤 것을 넣느냐에 따라 하위 컴포넌트가 달라지기 때문이다. 그렇기 때문에 Containment 방법을 사용하여 Composition을 사용한다.</p>
<br />

<p><strong>Containment를 사용하는 방법</strong></p>
<p>: 리액트 컴포넌트 props에 기본적으로 들어있는 children 속성을 사용</p>
<p>children prop을 사용한 FancyBorder 컴포넌트 예시:</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FancyBorder</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">FancyBorder</span> <span class="attr">FancyBorder-</span>&#x27; + <span class="attr">props.color</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>props.children</code> 을 사용하면 해당 컴포넌트의 하위 컴포넌트가 children이라는 prop으로 들어오게 된다. (리액트에서 기본적으로 제공)</p>
<p>React.createElement 문법을 생각해보면 세 번째로 들어가는 파라미터가 children이 들어간다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="keyword">type</span>, [props], [...children]);</span><br></pre></td></tr></table></figure>

<details>
  <summary>💬 배열로 들어가는 이유는?</summary>
  <div markdown="1">
    여러개의 하위 컴포넌트를 가질 수 있기 때문
  </div>
</details>

<br />

<p>FancyBorder 컴포넌트 활용 예제:</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">WelcomeDialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span>어서오세요<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span>사이트에 방문하신 것을 환영합니다!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>WelcomeDialog</code>는 <code>FancyBorder</code> 컴포넌트를 사용</li>
<li>FancyBorder 컴포넌트로 감싸진 부분 안에는 h1, p 태그로 구성</li>
</ul>
<p>이 두개의 태그는 FancyBorder의 children이라는 이름의 props로 전달됨. 결과적으로 파란색 테두리로 모두 감싸지는 결과가 나옴</p>
<br />

<h3 id="그렇다면-여러-개의-children-집합이-필요한-경우는-어떻게-할까"><a href="#그렇다면-여러-개의-children-집합이-필요한-경우는-어떻게-할까" class="headerlink" title="그렇다면 여러 개의 children 집합이 필요한 경우는 어떻게 할까?"></a>그렇다면 여러 개의 children 집합이 필요한 경우는 어떻게 할까?</h3><p>이런 경우는 별도로 props를 정의해서 각각 원하는 컴포넌트를 넣어주면 된다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SplitPane</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;splitPane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;splitPane-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;props.left&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;splitPane-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span> &#123;props.right&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">SplitPane</span> <span class="attr">left</span>=<span class="string">&#123;</span>&lt;<span class="attr">Contacts</span> /&gt;</span>&#125; right=&#123;<span class="tag">&lt;<span class="name">Chats</span> /&gt;</span>&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>화면의 왼쪽과 오른쪽을 분할해서 보여주는 SplitPane 컴포넌트</li>
<li>여기서는 left, right라는 props를 정의하고 각각 다른 컴포넌트를 전달</li>
<li>SplitPane에서는 left, right를 props로 전달받게 되고 각각 화면의 왼쪽과 오른쪽에 컴포넌트를 렌더링한다.</li>
</ul>
<br />

<div style="background-color:#FFA07A; padding: 1rem "> props.children이나 직접 정의한 props를 이용하여 하위 컴포넌트를 포함하는 형태로 합성하는 방법을 Containment</div>

<br />

<h2 id="Specialization"><a href="#Specialization" class="headerlink" title="Specialization"></a>Specialization</h2><p>전문화, 특수화를 의미</p>
<p>어떤 개념인지 잘 와닿지 않으니 예를 들어보면,</p>
<h3 id="‘WelcomDialog는-Dialog의-특별한-케이스다-’"><a href="#‘WelcomDialog는-Dialog의-특별한-케이스다-’" class="headerlink" title="‘WelcomDialog는 Dialog의 특별한 케이스다.’"></a>‘WelcomDialog는 Dialog의 특별한 케이스다.’</h3><ul>
<li>Dialog는 범용적인 의미를 가지고 있음. 👉🏻 모든 종류의 Dialog를 다 포함할 수 있는 개념</li>
<li>반면 WelcomDialog은 누군가를 반기기위한 Dialog</li>
</ul>
<h3 id="이처럼-범용적인-개념을-구별이-되게-구체화하는-것"><a href="#이처럼-범용적인-개념을-구별이-되게-구체화하는-것" class="headerlink" title="이처럼 범용적인 개념을 구별이 되게 구체화하는 것"></a>이처럼 범용적인 개념을 구별이 되게 구체화하는 것</h3><p>기존의 객체 지향 언어에서는 상속을 사용하여 Specialization을 구현</p>
<p>리액트에서는 합성을 사용하여 Specialization을 구현한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WelcomeDialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Dialog</span> <span class="attr">title</span>=<span class="string">&quot;어서오세요&quot;</span> <span class="attr">message</span>=<span class="string">&quot;사이트에 방문하신 것을 환영합니다.&quot;</span> /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Dialog 컴포넌트를 사용하는 WelcomDialog 컴포넌트</li>
<li>Dialog 컴포넌트는 title과 message라는 두 가지 props를 가지고 있음</li>
<li>props는 각각 제목과 메세지를 의미하는데 이 제목과 메세지를 어떻게 사용하느냐에 따라서 인삿말 Dialog가 될 수도 있고 경고 Dialog가 될 수도 있다. <em>(용도에 따라 다르게 쓸 수 있는 Dialog 컴포넌트를 만든거구나)</em></li>
</ul>
<br />

<div style="background-color:#FFA07A; padding: 1rem "> Specialization은 범용적으로 사용할 수 있는 컴포넌트를 만들어 놓고 이를 특수화 시켜서 컴포넌트를 사용하는 composition 방법</div>

<br />

<h2 id="Containment와-Specialization을-같이-사용하려면"><a href="#Containment와-Specialization을-같이-사용하려면" class="headerlink" title="Containment와 Specialization을 같이 사용하려면?"></a>Containment와 Specialization을 같이 사용하려면?</h2><p>Containment를 위해서 props.children을 사용하고 Specialization을 위해 직접 정의한 props를 사용하면 되겠다!</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.title&#125;</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.message&#125;</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   &#123;props.children&#125; // &lt;- containment를 위해</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> )</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SignUpDialog</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [nickname, setNickname] = <span class="title function_">useState</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setNickname</span>(event.<span class="property">target</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Dialog</span> <span class="attr">title</span>=<span class="string">&quot;화성 탐사 프로그램&quot;</span> <span class="attr">message</span>=<span class="string">&quot;닉네임을 알려주세요&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;nickName&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChane&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span> 가입하기 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Dialog</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/230330/230330-1.png" alt="."></p>
<p>이러한 형태로 specialization과 Containment를 동시에 사용할 수 있다.</p>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>일상생활에서 상속이란 단어는 부모가 자식에게 재산을 물려줄 때 사용</p>
<p>컴퓨터 프로그래밍에서의 상속은 객체지향 프로그래밍에서 나온 용어.</p>
<p>부모 클래스를 상속받아서 자식 클래스를 만든다는 개념으로 자식 클래스는 부모 클래스가 가진 변수나 함수 속성을 갖게 된다.</p>
<p>리액트에서는 다른 컴포넌트로부터 상속을 받아서 새로운 컴포넌트를 만드는 것을 고려해볼 수 있지만 추천X</p>
<h2 id="결론은…"><a href="#결론은…" class="headerlink" title="결론은…"></a>결론은…</h2><p>복잡한 컴포넌트를 쪼개서 여러 개의 컴포넌트로 만들고 만든 컴포넌트를 조합해서 새로운 컴포넌트를 만들자!</p>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://ko.reactjs.org/docs/composition-vs-inheritance.html">합성 (Composition) vs 상속 (Inheritance) – React</a></p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>URL vs URI</title>
    <url>/2023/230330-2-archive/</url>
    <content><![CDATA[<p><img src="/../img/230330/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%204.png" alt="스크린샷 4.png"></p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>: <strong>Uniform Resource Locator</strong></p>
<ul>
<li>네트워크 상에서 웹 페이지, 이미지, 동영상 파일이 위치한 식별하는 문자열</li>
<li>sceme, hosts, url-path로 구분</li>
</ul>
<h3 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h3><p>통신 방식을 결정한다. 일반적인 웹에서는 https를 사용</p>
<h3 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h3><p>웹 서버의 이름이나 도메인, IP를 사용하며 주소를 나타낸다.</p>
<h3 id="url-path"><a href="#url-path" class="headerlink" title="url-path"></a>url-path</h3><p>웹 서버에서 지정한 루트 디렉토리에서부터 시작해서 웹 페이지, 이미지, 동영상이 위치한 경로와 파일명을 나타낸다.</p>
<h2 id="URI-브라우저의-검색창을-클릭하면-나타나는-주소"><a href="#URI-브라우저의-검색창을-클릭하면-나타나는-주소" class="headerlink" title="URI - 브라우저의 검색창을 클릭하면 나타나는 주소"></a>URI - 브라우저의 검색창을 클릭하면 나타나는 주소</h2><p>: <strong>Uniform Resource Identifier</strong></p>
<ul>
<li>URL의 기본 요소인 scheme, hosts, url-path에 더해 query, fragment를 포함</li>
</ul>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>: 웹 서버에 보내는 추가적인 질문</p>
<p><code>http://www.google.com:80/search?q=JavaScript</code>를 브라우저의 검색창에 입력하면?</p>
<p>구글에서 JavaScript를 검색한 결과가 나타난다.</p>
<h3 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h3><ul>
<li>일종의 북마크 기능을 수행</li>
<li>URL에 fragment(<code>#</code>)와 특정 HTML 요소의 id를 전달하면 해당 요소가 있는 곳으로 스크롤을 이동한다.</li>
</ul>
<p><img src="/../img/230330/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%205.png" alt="스크린샷 5.png"></p>
]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>HOC(Higher-Order Components), 그래서 언제 써야하는데요? 🤷🏻‍♀️</title>
    <url>/2023/230330-3-archive/</url>
    <content><![CDATA[<p>HOC 패턴 이제 안써도 된답니다.👏🏻<br><img src="/../img/230331/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7.png" alt="."></p>
<p>이제 레거시 패턴이 되긴 했지만 그래도 어떻게 사용하고 언제 사용해야할지는 알아야하지 않겠습니까? 레거시 코드를 많이 마주치는 상황이 오기 때문이죠.</p>
<br />

<h1 id="HOC-Higher-Order-Components"><a href="#HOC-Higher-Order-Components" class="headerlink" title="HOC(Higher-Order Components)"></a>HOC(Higher-Order Components)</h1><p>앱 전반적으로 재사용한 로직을 prop으로 컴포넌트에게 제공</p>
<div style="background-color:#CCEEFF; padding: 1rem; text-align: center;">🚀 컴포넌트는 props를 UI로 변환하는 반면에, 고차 컴포넌트는 컴포넌트를 새로운 컴포넌트로 변환합니다.</div>

<p>우리는 여러 컴포넌트에서 같은 로직을 사용해야 하는 경우가 있습니다. 예를 들어, 컴포넌트의 스타일 시트를 설정할 수도 있고, 상태를 추가해야하는 경우가 있죠.</p>
<p>같은 로직을 여러 컴포넌트에서 재사용하는 방법 중 하나로 고차 컴포넌트 패턴을 활용하는 방법이 있습니다.</p>
<h2 id="고차-컴포넌트"><a href="#고차-컴포넌트" class="headerlink" title="고차 컴포넌트"></a>고차 컴포넌트</h2><p>고차 컴포넌트란 다른 컴포넌트를 받는 컴포넌트를 뜻합니다. HOC는 인자로 넘긴 컴포넌트에게 추가되길 원하는 로직을 가지고 있고 로직이 적용된 엘리먼트를 반환합니다.</p>
<p>네..? 무슨 말인지 잘 모르겟는데요<br><img src="/../img/230331/%EC%9D%B4%ED%95%B4%EB%B6%88%EA%B0%80-%EC%9D%B4%ED%95%B4%EC%95%88%EA%B0%80-%ED%99%A9%EB%8B%B9-%EB%AA%B0%EB%9D%BC-%EB%AA%A8%EB%A5%B4%EA%B2%A0%EB%8B%A4-%EB%AA%A8%EB%A6%84-%EC%9D%B4%ED%95%B4%EB%A5%BC-%EB%AA%BB%ED%95%98%EA%B2%A0%EC%96%B4.jpg" alt="."></p>
<br />

<h3 id="예를-들어-여러-컴포넌트에게-동일한-스타일을-적용하고-싶다고-가정해봅시다"><a href="#예를-들어-여러-컴포넌트에게-동일한-스타일을-적용하고-싶다고-가정해봅시다" class="headerlink" title="예를 들어, 여러 컴포넌트에게 동일한 스타일을 적용하고 싶다고 가정해봅시다."></a>예를 들어, 여러 컴포넌트에게 동일한 스타일을 적용하고 싶다고 가정해봅시다.</h3><p>로컬 스코프에 style 객체를 직접 만드는 대신, HOC가 style 객체를 만들어 컴포넌트에 전달하도록 합니다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">withStyles</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="comment">// 로직이 적용된 엘리먼트를 반환한다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123; <span class="attr">padding</span>: <span class="string">&#x27;100px&#x27;</span>, <span class="attr">margin</span>: <span class="string">&#x27;1rem&#x27;</span>, <span class="attr">fontSize</span>: <span class="string">&#x27;30px&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Text</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello word!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StyledButton</span> = <span class="title function_">withStyles</span>(<span class="title class_">Button</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StyledText</span> = <span class="title function_">withStyles</span>(<span class="title class_">Text</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">StyledButton</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">StyledText</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/230331/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%201.png" alt="."><br>Button컴포넌트와 Text컴포넌트를 수정한 StyledButton과 StyledText컴포넌트를 만들었습니다. 두 컴포넌트 모두 withStyles HOC로부터 스타일링 로직이 적용된거죠!</p>
<br />

<p>강아지 사진 목록을 API로부터 받아와서 렌더링을 하는 또 하나의 예제를 봐봅시다.</p>
<iframe src="https://codesandbox.io/embed/hoc-pattern-1-forked-3zy2ec?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="hoc-pattern-1 (forked)"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<p>UX를 개선하기 위해서 데이터를 받아오는 중에는 “로딩 중”이라는 메세지를 화면에 보여주고 싶다면 어떻게 해야할까요?</p>
<p>지금 드는 아이디어로는 useState를 사용해서 데이터를 받아오기 전엔 Loader 컴포넌트를 렌더링하고 데이터가 다 받아와지면 이미지 컴포넌트를 렌더링시키면 될 것 같습니다.</p>
  <br />

<p>고차 컴포넌트를 활용하면?</p>
<p>먼저 withLoader라는 HOC를 만듭니다.</p>
<blockquote>
<p>HOC는 컴포넌트를 인자로 받아 컴포넌트를 반환해야하는 것 잊지 마세요!</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// withLoader.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">withLoader</span>(<span class="params">Element, url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">        <span class="title function_">setData</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">getData</span>();</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// API응답을 받기 전까진 `Loading...`메시지를 출력</span></span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Element</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">data</span>=<span class="string">&#123;data&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제에서 HOC는 컴포넌트와 URL을 받습니다.</p>
<ol>
<li><p>withLoader의 useEffect 훅에서 url로 API를 호출하여 데이터를 받아오고 있습니다. 응답이 오기 전까지는 Loading… 텍스트를 렌더링합니다.</p>
</li>
<li><p>데이터를 받아오고 나면 data 상태를 초기화하게 되므로 인자로 전달되었던 컴포넌트가 화면에 렌더링됩니다.</p>
</li>
</ol>
<br />

<p><code>DogImages.js</code>에서 더 이상 DogImages 컴포넌트를 직접 export할 필요가 없어졌습니다. 대신 withLoading HOC로 감싸진 DogImages 컴포넌트를 export하면 됩니다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withLoader</span>(</span><br><span class="line">  <span class="title class_">DogImages</span>,</span><br><span class="line">  <span class="string">&#x27;https://dog.ceo/api/breed/labrador/images/random/6&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<br />

<p>withLoader HOC는 데이터를 prop으로 전달하고 있기 때문에 데이터를 가지고 강아지 사진 목록을 사용할 수 있습니다.</p>
<p>고차 컴포넌트 패터은 동일 로직을 여러 컴포넌트들에 제공할 수 있게 해줍니다. <code>withLoader</code> HOC는 컴포넌트와 url에서 받아오는 데이터에 대해서는 관여하지 않고 받아온 데이터를 넘길 뿐이죠.</p>
<h2 id="고차-컴포넌트를-조합해보자"><a href="#고차-컴포넌트를-조합해보자" class="headerlink" title="고차 컴포넌트를 조합해보자!"></a>고차 컴포넌트를 조합해보자!</h2><p>여러 고차 컴포넌트를 조합해서 사용할 수도 있습니다. 위 예제에서 DogImages 컴포넌트에 hover 효과를 적용시켜보자구요.</p>
<p><code>hovering</code>이라는 prop을 제공하는 HOC를 만들어야 합니다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">DogImages</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.hovering &amp;&amp; <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hover&quot;</span>&gt;</span>Hovering!<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.data.message.map((dog, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;dog&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Dog&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withHover</span>(</span><br><span class="line">  <span class="title function_">withLoader</span>(<span class="title class_">DogImages</span>, <span class="string">&#x27;https://dog.ceo/api/breed/labrador/images/random/6&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>DogImages에서 이 prop을 기준으로 hover 효과를 결정하면 됩니다.</p>
<iframe src="https://codesandbox.io/embed/hoc-pattern-3-whhh0?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="hoc-pattern-3"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

<p>DogImages 엘리먼트는 이제 withHover와 withLoader에서 제공하는 prop을 사용할 수 있습니다.</p>
<br />

<p>쉽게 이해가 가진 않는군요…<br><img src="/../img/230331/%EB%82%98%EB%8F%84-%EB%82%B4%EA%B0%80-%EB%AD%94-%EC%86%8C%EB%A6%B4-%ED%95%98%EB%8A%94%EC%A7%80-%EB%AA%B0%EB%9D%BC-%EA%B7%B8%EB%83%A5-%EC%9E%98%EB%82%9C-%EC%B2%99-%ED%95%9C%EA%B1%B0%EC%95%BC.jpg" alt="."></p>
<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><p>몇몇 상황은 React의 훅으로 대체할 수 있습니다.</p>
<p>위에서 구현했던 <code>withHover</code> HOC를 useHover 훅으로 대체해보면,</p>
<ul>
<li><p>고차 컴포넌트를 사용하는 대신 엘리먼트에 <code>mouseOver</code>, <code>mouseLeave</code>이벤트 핸들러 추가</p>
</li>
<li><p>HOC처럼 엘리먼트를 반환할 수 없으니, ref를 반환하여 이벤트 핸들러를 추가할 엘리먼트를 지정</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// useHover.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState, useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useHover</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [hovering, setHover] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleMouseOver</span> = (<span class="params"></span>) =&gt; <span class="title function_">setHover</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleMouseOut</span> = (<span class="params"></span>) =&gt; <span class="title function_">setHover</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> node = ref.<span class="property">current</span>;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">      node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, handleMouseOver);</span><br><span class="line">      node.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, handleMouseOut);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        node.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, handleMouseOver);</span><br><span class="line">        node.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, handleMouseOut);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [ref.<span class="property">current</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [ref, hovering];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// withLoader.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">withLoader</span>(<span class="params">Element, url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">fetch</span>(url)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> <span class="title function_">setData</span>(data));</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Element</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">data</span>=<span class="string">&#123;data&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> withLoader <span class="keyword">from</span> <span class="string">&#x27;./withLoader&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> useHover <span class="keyword">from</span> <span class="string">&#x27;./useHover&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">DogImages</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [hoverRef, hovering] = <span class="title function_">useHover</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;hoverRef&#125;</span> &#123;<span class="attr">...props</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;hovering &amp;&amp; <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hover&quot;</span>&gt;</span>Hovering!<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.data.message.map((dog, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;dog&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Dog&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withLoader</span>(</span><br><span class="line">  <span class="title class_">DogImages</span>,</span><br><span class="line">  <span class="string">&#x27;https://dog.ceo/api/breed/labrador/images/random/6&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>+) usehooks 라이브러리를 설치해서 <a href="https://usehooks-ts.com/react-hook/use-hover">useHover</a> hook을 사용할 수도 있습니다.</p>
<br />

<h3 id="HOC-패턴-장점은"><a href="#HOC-패턴-장점은" class="headerlink" title="HOC 패턴 장점은?"></a>HOC 패턴 장점은?</h3><p>고차 컴포넌트를 사용하면 한 곳에 구현한 로직들을 여러 컴포넌트에서 재사용할 수 있다.</p>
<h3 id="단점은요"><a href="#단점은요" class="headerlink" title="단점은요?"></a>단점은요?</h3><p>HOC가 반환하는 컴포넌트에 전달하는 props의 이름이 겹칠 수 있다.</p>
<p>👉🏻 <a href="https://patterns-dev-kr.github.io/design-patterns/hoc-pattern/#%EB%8B%A8%EC%A0%90">HOC패턴의 단점</a></p>
<p>👉🏻 <a href="https://yceffort.kr/2020/10/react-hooks-and-hocs">리액트의 Hooks과 HOC, HOC의 사용이 복잡해지는 경우</a></p>
<br />

<h2 id="그래서-HOC-패턴-언제-사용하는거죠"><a href="#그래서-HOC-패턴-언제-사용하는거죠" class="headerlink" title="그래서 HOC 패턴 언제 사용하는거죠?"></a>그래서 HOC 패턴 언제 사용하는거죠?</h2><ul>
<li><p>앱 전반적으로 동일하며 커스터마이징 불가한 동작이 여러 컴포넌트에 필요한 경우</p>
</li>
<li><p>컴포넌트가 커스텀 로직 추가 없이 단독으로 동작할 수 있어야 하는 경우</p>
</li>
</ul>
<br />

<h2 id="Referrence"><a href="#Referrence" class="headerlink" title="Referrence"></a>Referrence</h2><ul>
<li><p><a href="https://jjalbang.today/files/jjalbox/2021/06/20210623_60d2a03eba830.jpg">HOC 패턴</a></p>
</li>
<li><p><a href="https://usehooks-ts.com/react-hook/use-hover">useHooks - useHover</a></p>
</li>
<li><p><a href="https://yceffort.kr/2020/10/react-hooks-and-hocs">리액트의 Hooks과 HOC, HOC의 사용이 복잡해지는 경우</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>메가테라 프론트엔드 생존코스 3주차 주간회고</title>
    <url>/2023/230325-archive/</url>
    <content><![CDATA[<h1 id="Fact"><a href="#Fact" class="headerlink" title="Fact"></a>Fact</h1><ul>
<li>React 공식문서에 있는 Thinking in React를 공부했다.</li>
<li>하나의 코드를 컴포넌트로 분리하는 작업에 대해서 배웠다. 👉🏻 ‘컴포넌트를 어떤 기준으로 나눠야하는가?’</li>
<li>어떤 컴포넌트가 State를 가지고 있어야하는지, 어떤 컴포넌트는 Props를 받아서 사용해야할지에 대해 배웠다.</li>
<li>컴포넌트를 함수로 추출할 때 타입스크립트를 어떻게 사용하는지에 대해서 배웠다.</li>
<li><code>나만의 메뉴 만들기</code> 과제를 진행하면서 다시 한 번 컴포넌트와 State에 대해서 연습할 수 있었다.</li>
</ul>
<h1 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h1><ul>
<li>공식문서에서는 컴포넌트를 미리 분리를 해놓고 작업을 하는 방식을 취했는데, 아샬님은 모든 코드를 먼저 작성하고 컴포넌트를 분리하는 방식을 보여주셨다. 이때 아샬님의 리팩토링 과정은 물 흐르듯이 흘러가서 잠깐 놓치면 완전히 다른 방식의 코드가 만들어져 있었다. 강의를 멈췄다가 다시 보고 다시 돌려서 보다보니 강의 하나를 보는데 3시간 정도 걸린 것 같다.</li>
<li>컴포넌트 추출 작업을 따라가는 방법도 이해하는데 시간이 오래걸렸지만, 타입스크립트를 사용하는 부분에서 완전히 멘붕이었다. 타입스크립트가 익숙하지 않아서 전체 코드를 파악할 때 타입스크립트 코드로 인해 코드가 한 눈에 잘 안보인다. 더 많이 써보면서 코드 구조에 익숙해져야 할 것 같다.</li>
<li>강의를 보고 코드를 쳐보는 연습도 했지만 막상 과제를 하려고하니 코드가 쉽게 쳐지지 않는다. 많이 연습해보는 것밖에 답이 없다.</li>
<li>이번주는 린트 오류를 해결하지 못해서 린트 문제를 해결하기 위해 소요한 시간이 꽤 길었다.</li>
</ul>
<h1 id="Finding"><a href="#Finding" class="headerlink" title="Finding"></a>Finding</h1><ul>
<li>Lifting State Up 개념을 배우면서 라이브러리 없이는 상태관리가 생각보다 복잡하다라는 것을 알게되었다. 이래서 라이브러리로 쉽게 전역 상태 관리를 하기 시작한걸까?</li>
<li>컴포넌트를 분리하고 하나의 컴포넌트가 하는 일을 간단하게 만들었지만, 브라우저에서 어떤 구조로 렌더링되는지는 쉽게 보이지 않는다. 컴포넌트를 타고 타고 들어가면서 코드를 확인해야하는 불편함이 있다. 어떻게 해야 코드에서도 구조적으로 가독성이 높아지는지에 대해서도 알아봐야 겠다.</li>
</ul>
<h1 id="Future-aciton"><a href="#Future-aciton" class="headerlink" title="Future aciton"></a>Future aciton</h1><ul>
<li>3주차 과제 해설이 올라오면 씹고 뜯고 맛보기. 해설 코드를 보면서 어떻게 코드를 작성해야하는지에 대해 연습하기</li>
<li>매일 저녁 30분 산책하기. 매일 의자에 앉아있고 돌아다니질 않으니 허리 건강과 체력이 나빠지는게 느껴진다.</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>Megaptera</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue 구현하기</title>
    <url>/2023/230330-archive/</url>
    <content><![CDATA[<h3 id="Array로-구현하는-방법"><a href="#Array로-구현하는-방법" class="headerlink" title="Array로 구현하는 방법"></a>Array로 구현하는 방법</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rear</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = (<span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">rear</span>++] = value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">front</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">front</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">front</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">rear</span> - <span class="variable language_">this</span>.<span class="property">front</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list로-구현하는-방법"><a href="#list로-구현하는-방법" class="headerlink" title="list로 구현하는 방법"></a>list로 구현하는 방법</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newNode</span> = <span class="keyword">new</span> <span class="title class_">Node</span>(newValue);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = newNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Shift-함수는-쓰지말자"><a href="#Shift-함수는-쓰지말자" class="headerlink" title="Shift 함수는 쓰지말자!"></a>Shift 함수는 쓰지말자!</h2><p>shift 메서드를 사용하게 되면 배열의 index를 하나씩 당겨서 다시 정리해야하기 때문에 시간복잡도가 증가한다.</p>
<h1 id="Circluar-Queue"><a href="#Circluar-Queue" class="headerlink" title="Circluar Queue"></a>Circluar Queue</h1><p>Front와 Rear가 이어져있는 Queue</p>
<p>Circluar Queue는 Linked List로 구현했을 때 이점이 없다.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">maxSize</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">maxSize</span> = maxSize;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rear</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">isFull</span>()) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Queue is full&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">rear</span>] = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rear</span> = (<span class="variable language_">this</span>.<span class="property">rear</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">maxSize</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">front</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">front</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">front</span> = (<span class="variable language_">this</span>.<span class="property">front</span> + <span class="number">1</span>) % <span class="variable language_">this</span>.<span class="property">maxSize</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">isFull</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="variable language_">this</span>.<span class="property">maxSize</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">queue</span>[<span class="variable language_">this</span>.<span class="property">front</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 7주차 주간회고</title>
    <url>/2023/230402-1-archive/</url>
    <content><![CDATA[<p><img src="https://oopy.lazyrockets.com/api/rest/cdn/image/5ea7b8f9-fe5e-49b6-ad61-40007a25805b.png" alt="."></p>
<h1 id="Fact"><a href="#Fact" class="headerlink" title="Fact"></a>Fact</h1><ul>
<li>브라우저 작동 원리에 대해서 공부했다.</li>
<li>props와 state에 대해 공부했다.</li>
<li>REST API에 대해서 공부할 수 있는 시간이 주어져서 [그런 REST API로 괜찮은가] 라는 제목의 네이버 컨퍼런스 영상을 보고 정리했다. 👉🏻 <a href="https://leejaelll.github.io/2023/230329-archive/">REST API란 무엇인가</a></li>
<li>Postman을 이용해 API를 테스트하고 날씨 정보를 받아오는 연습을 했다.</li>
<li>컴포넌트 합성에 대해서 공부했다.</li>
</ul>
<h1 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h1><ul>
<li>벌써 7주차라니 시간이 너무 빨리 흘러간다. 하고 싶은건 많은데 어떻게 시간을 효율적으로 써야할지 모르겠다.</li>
<li>이후 프로젝트를 해야할 때 어떤 Open API를 사용해서 구현할지 고민해보면 좋을 것 같다.</li>
<li>스터디를 준비하면서 찾아보는 내용들이 확실히 깊게 남아있는 것 같다. 누군가를 설명하기 위해서 더 자세하게 찾아보기 때문에 그런 것 같기도 하다. 5월 말까지는 시간적으로 여유가 너무 없어서 스터디를 참여할까 말까 고민을 많이 했는데 하기를 잘한 것 같다. 다른 스터디원이 발표한 내용을 듣는 것만으로도 도움이 많이된다.</li>
</ul>
<h1 id="Finding"><a href="#Finding" class="headerlink" title="Finding"></a>Finding</h1><ul>
<li>누군가에게 설명하는 것은 어렵다. 하지만 계속해서 연습해야지.</li>
<li>개발자로서 글쓰기가 중요하다는 말을 많이 듣는데 ‘그래서 어떻게 써야 잘쓴 글이 되는걸까?’라는 생각이 든다. 글을 잘 쓰는 법에 대해서 찾아보자.</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>메가테라 프론트엔드 생존코스 4주차 주간회고</title>
    <url>/2023/230402-archive/</url>
    <content><![CDATA[<h2 id="Fact"><a href="#Fact" class="headerlink" title="Fact"></a>Fact</h2><ul>
<li>Express로 서버 만드는 방법과 서버와 통신하는 방법에 대해서 배웠다.</li>
<li>CORS의 개념에 대해서 공부했다.</li>
<li>React Hook과 Custom Hook에 대해서 공부했다.</li>
</ul>
<h2 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h2><ul>
<li>이전에 자바스크립트 프로젝트를 진행할 때 서버를 만든 경험이 있어서 수월했던 것 같다.</li>
<li>남들보다 이해 속도가 뒤쳐지는 것이 느껴진다. 강의 내용을 이해하는데 시간을 굉장히 많이 쓰고 있어서 추가 개념들 정리를 하고 나면 토요일이 끝난다. 과제를 할 시간이 없다…!</li>
<li>Custom Hook을 처음 봤는데 내가 익숙하게 사용할 수 있을까…?라는 생각이 든다. 이해하기 어렵지만 많이 사용해봐야지.</li>
<li>과제 해설코드가 올라왔지만, 우선 내가 할 수 있는 데까지 해보고 제출 후에 해설 코드를 봐야겠다.</li>
</ul>
<h2 id="Finding"><a href="#Finding" class="headerlink" title="Finding"></a>Finding</h2><ul>
<li>컴포넌트 합성의 개념에 대해서 공부했는데, 사용 방법에 대해서 잘 알게된 것 같다. 이후에 한 번 사용해봐야지</li>
<li>HOC 단점이 Wrapped Hell 이라고 하는데, 고차 컴포넌트에 대해서 찾아 볼 수 있는 시간이 되었다. 최근 리액트 공식문서가 리뉴얼되면서 고차 컴포넌트 개념이 사라졌지만 대부분의 기업에서는 아직 유용하게 사용하고 있는 것 같다. 디자인 패턴을 보면서 한 번씩 코드를 작성해봤지만, 이해가 가진 않는다. 꾸준히 작성해보는게 중요할 것 같다.</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>Megaptera</tag>
      </tags>
  </entry>
  <entry>
    <title>useEffect 정복 가보자고 🏃🏻</title>
    <url>/2023/230404-archive/</url>
    <content><![CDATA[<details>
  <summary>🤔 useEffect 로 componentDidMount 동작을 흉내내려면 어떻게 하지?</summary>
  <div markdown='1'>
  완전히 같진 않지만 `useEffect(fn, [])` 으로 가능합니다. `componentDidMount` 와 달리 prop과 state를 잡아둘 것입니다. 그래서 콜백 안에서도 초기 prop과 state를 확인할 수 있습니다. 만약 “최신의” 상태 등을 원한다면, ref에다 담아둘 수는 있습니다. 하지만 보통 더 간단하게 코드를 구조화하는 방법이 있기 때문에 굳이 이 방법을 쓸 필요도 없습니다. 이펙트를 다루는 멘탈 모델은 `componentDidMount` 나 다른 라이프사이클 메서드와 다르다는 점을 인지하셔야 합니다. 그리고 어떤 라이프사이클 메서드와 비슷한 동작을 하도록 만드는 방법을 찾으려고 하면 오히려 혼란을 더 키울 뿐입니다. 더 생산적으로 접근하기 위해 “이펙트 기준으로 생각해야(thinking in effects)” 하며 이 멘탈 모델은 동기화를 구현하는 것에 가깝지 라이프사이클 이벤트에 응답하는 것과는 다릅니다.
  </div>
</details>

<br />

<details>
<summary>🤔 `useEffect` 안에서 데이터 페칭(Data fetching)은 어떻게 해야할까? 두번째 인자로 오는 배열(`[]`) 은 뭐지?</summary>
<div markdown='1'>
  [이 링크의 글이](https://www.robinwieruch.de/react-hooks-fetch-data/) `useEffect` 를 사용하여 데이터를 불러오는 방법을 파악하는데 좋은 기본서가 됩니다. 글을 꼭 끝까지 읽어보세요! 지금 읽고 계시는 글처럼 길지 않습니다. `[]` 는 이펙트에 리액트 데이터 흐름에 관여하는 어떠한 값도 사용하지 않겠다는 뜻입니다. 그래서 한 번 적용되어도 안전하다는 뜻이기도 합니다. 이 빈 배열은 실제로 값이 사용되어야 할 때 버그를 일으키는 주된 원인 중 하나입니다. 잘못된 방식으로 의존성 체크를 생략하는 것 보다 의존성을 필요로 하는 상황을 제거하는 몇 가지 전략을(주로 `useReducer`, `useCallback`) 익혀야 할 필요가 있습니다.
</div>
</details>

<br />

<details>
<summary>🤔 이펙트를 일으키는 의존성 배열에 함수를 명시해도 되는걸까?</summary>
<div markdown='1'>
추천하는 방법은 prop이나 state를 반드시 요구하지 않는 함수는 컴포넌트 바깥에 선언해서 호이스팅하고, 이펙트 안에서만 사용되는 함수는 이펙트 함수 내부에 선언하는 겁니다. 그러고 나서 만약에 랜더 범위 안에 있는 함수를 이펙트가 사용하고 있다면 (prop으로 내려오는 함수 포함해서), 구현부를 `useCallback`
   으로 감싸세요. 왜 이런걸 신경써야 할까요? 함수는 prop과 state로부터 값을 “볼 수” 있습니다. 그러므로 리액트의 데이터 플로우와 연관이 있지요. [자세한 답변](https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies)
  은 훅 FAQ 부분에 있습니다.
</div>
</details>

<br />

<details>
<summary>🤔 왜 가끔씩 데이터 페칭이 무한루프에 빠지는걸까?</summary>
<div markdown='1'>
이펙트 안에서 데이터 페칭을 할 때 두 번째 인자로 의존성 배열을 전달하지 않았을 때 생길 수 있는 문제입니다. 이게 없으면 이펙트는 매 랜더마다 실행됩니다. 그리고 state를 설정하는 일은 또 다시 이펙트를 실행하죠. 의존성 배열에 항상 바뀌는 값을 지정해 두는 경우에도 무한 루프가 생길 수 있습니다. 하나씩 지워보면서 어느 값이 문제인지 확인할 수도 있지만, 사용하고 있는 의존 값을 지우는 일은(아니면 맹목적으로 `[]` 을 지정하는 것은) 보통 잘못된 해결법입니다. 그 대신 문제의 근원을 파악하여 해결해야 합니다. 예를 들어 함수가 문제를 일으킬 수 있습니다. 그렇다면 이펙트 함수 안에 집어넣거나, 함수를 꺼내서 호이스팅 하거나, `useCallback` 으로 감싸서 해결할 수 있습니다. 객체가 재생성되는 것을 막으려면 `useMemo` 를 비슷한 용도로 사용할 수 있습니다.
</div>
</details>

<br />

<details>
<summary>🤔 왜 가끔씩 이펙트 안에서 이전 state나 prop 값을 참조할까?</summary>
<div markdown='1'>
이펙트는 언제나 자신이 정의된 블록 안에서 랜더링이 일어날 때마다 prop과 state를 “지켜봅니다”. 이렇게 하면 [버그를 방지할 수 있지만](https://overreacted.io/ko/how-are-function-components-different-from-classes/) 어떤 경우에는 짜증날 수 있습니다. 그럴 때는 명시적으로 어떤 값을 가변성 ref에 넣어서 관리할 수 있습니다(링크에 있는 글 말미에 설명되어 있습니다). 혹시 기대한 것과 달리 이전에 랜더링될 때의 prop이나 state가 보인다면, 아마도 의존성 배열에 값을 지정하는 것을 깜빡했을 겁니다. 이 [린트 규칙](https://github.com/facebook/react/issues/14920)을 사용하여 그 값을 파악할 수 있도록 연습해 보세요. 며칠 안으로 자연스레 몸에 밸 것입니다. 또한 FAQ 문서에서 [이 답변 부분을](https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function) 읽어보세요.
</div>
</details>

<br />

<hr>
<h2 id="모든-렌더링은-고유의-Prop과-State가-있다"><a href="#모든-렌더링은-고유의-Prop과-State가-있다" class="headerlink" title="모든 렌더링은 고유의 Prop과 State가 있다."></a>모든 렌더링은 고유의 Prop과 State가 있다.</h2><p>effect를 이야기하기 전에 렌더링에 대해서 이야기해야 한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">usestate</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You cliked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드에서 count는 그저 숫자이다. 그저 아래 코드와 같이 단순한 숫자에 불과하다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="number">42</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&lt;p&gt;<span class="title class_">You</span> cliked &#123;count&#125; times&lt;/p&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>처음으로 컴포넌트가 렌더링될 때, useState로부터 가져온 count변수는 0이다.</li>
<li>setCount(1)을 호출하면, 다시 컴포넌트를 호출하고, 이 때 count는 1이 되는 식</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 처음 랜더링 시</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>; <span class="comment">// useState() 로부터 리턴</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클릭하면 함수가 다시 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span>; <span class="comment">// useState() 로부터 리턴</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 또 한번 클릭하면, 다시 함수가 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">2</span>; <span class="comment">// useState() 로부터 리턴</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="state를-업데이트할-때마다-리액트는-컴포넌트를-호출한다"><a href="#state를-업데이트할-때마다-리액트는-컴포넌트를-호출한다" class="headerlink" title="state를 업데이트할 때마다, 리액트는 컴포넌트를 호출한다."></a>state를 업데이트할 때마다, 리액트는 컴포넌트를 호출한다.</h3><p>매 렌더링 결과물은 고유의 counter 상태 값을 살펴본다. 이 값은 함수 안에 상수로 존재하는 값</p>
<p>따라서 위에 표시한 줄은 어떠한 데이터 바인딩도 수행하지 않았다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;<span class="title class_">You</span> clicked &#123;count&#125; times&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>이것은 렌더링할 때 숫자 값을 내장하는 것에 불과함. 이 숫자 값은 리액트를 통해 제공된다.</p>
<p>setCount를 호출할 때, 리액트는 다른 count 값과 함께 컴포넌트를 다시 호출한다. 그러면 리액트는 가장 최신의 렌더링 결과물과 일치하도록 DOM을 업데이트한다.</p>
<h3 id="명심해야할-것은-count는-시간이-지난다고-바뀌는-것이-아니라는-것이다"><a href="#명심해야할-것은-count는-시간이-지난다고-바뀌는-것이-아니라는-것이다" class="headerlink" title="명심해야할 것은 count는 시간이 지난다고 바뀌는 것이 아니라는 것이다."></a>명심해야할 것은 count는 시간이 지난다고 바뀌는 것이 아니라는 것이다.</h3><p>컴포넌트가 다시 호출되고, 각각의 렌더링마다 고유의 count 값을 보는 것! 👉🏻 <a href="https://overreacted.io/ko/react-as-a-ui-runtime/">UI 런타임으로서의 React</a></p>
<br />

<h2 id="모든-렌더링은-고유의-이벤트-핸들러를-가진다"><a href="#모든-렌더링은-고유의-이벤트-핸들러를-가진다" class="headerlink" title="모든 렌더링은 고유의 이벤트 핸들러를 가진다"></a>모든 렌더링은 고유의 이벤트 핸들러를 가진다</h2><p>이벤트 핸들러의 경우는 어떨까?</p>
<p>3초 뒤에 <code>count</code> 값과 함께 alert을 띄우는 코드 예시:</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAlertClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;You clicked on: &#x27;</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleAlertClick&#125;</span>&gt;</span>Show alert<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>count를 3으로 증가시킨다.</li>
<li>“Show alert”을 누른다.</li>
<li>setTimeout이 실행되기 전에 count를 5로 증가시킨다.</li>
</ol>
<p>이때 alert 창에는 어떤 값이 나타날까?</p>
<p>정답은 3이 나온다! 그 이유는?</p>
<p>setTimeout이 실행되는 시점에 count는 3을 가지고 있기 때문이다.</p>
<br />

<h3 id="왜-이렇게-동작하는-걸까"><a href="#왜-이렇게-동작하는-걸까" class="headerlink" title="왜 이렇게 동작하는 걸까?"></a>왜 이렇게 동작하는 걸까?</h3><p><strong>count는 별개의 함수 호출마다 존재하는 상수 값이라는 이야기를 했다.</strong></p>
<p>함수는 여러번 호출되지만 각각의 렌더링에서 함수 안의 count 값은 상수이자 독립적인 값으로 존재한다.</p>
<p>리액트만 그런 것이 아니라 보통의 함수도 같은 방식으로 동작한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = person.<span class="property">name</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Hello, &#x27;</span> + name);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someone = &#123; <span class="attr">name</span>: <span class="string">&#x27;Dan&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123; <span class="attr">name</span>: <span class="string">&#x27;Yuzhi&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br><span class="line"></span><br><span class="line">someone = &#123; <span class="attr">name</span>: <span class="string">&#x27;Dominic&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">sayHi</span>(someone);</span><br></pre></td></tr></table></figure>

<ul>
<li>외부의 someone 변수는 여러 번 재할당되고 있지만, 함수 내부에서 person과 엮여있는 name 이라는 지역 상수가 존재.</li>
<li>이 상수는 지역 상수이기 때문에 각각의 함수 호출로부터 분리되어 있음</li>
<li>결과적으로 setTimeout 함수가 실행될 때마다 고유의 name을 기억한다.</li>
</ul>
<p>이 설명을 통해 이벤트 핸들러가 count 값을 잡아두었는지 알 수 있게 되었다.</p>
<h3 id="매-렌더링마다-각각의-count-값을-보는-것"><a href="#매-렌더링마다-각각의-count-값을-보는-것" class="headerlink" title="매 렌더링마다 각각의 count 값을 보는 것"></a>매 렌더링마다 각각의 count 값을 보는 것</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 처음 랜더링 시</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">0</span>; <span class="comment">// useState() 로부터 리턴</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAlertClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;You clicked on: &#x27;</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클릭하면 함수가 다시 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">1</span>; <span class="comment">// useState() 로부터 리턴</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAlertClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;You clicked on: &#x27;</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 또 한번 클릭하면, 다시 함수가 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="number">2</span>; <span class="comment">// useState() 로부터 리턴</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAlertClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;You clicked on: &#x27;</span> + count);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉🏻 따라서 효과적으로 각각의 렌더링은 고유한 버전의 handleAlertClick을 리턴한다. 그리고 각각의 버전은 고유의 count를 기억한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 처음 랜더링 시</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAlertClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;You clicked on: &#x27;</span> + <span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;; <span class="comment">// 0이 안에 들어있음</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클릭하면 함수가 다시 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAlertClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;You clicked on: &#x27;</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;; <span class="comment">// 1이 안에 들어있음</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 또 한번 클릭하면, 다시 함수가 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleAlertClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;You clicked on: &#x27;</span> + <span class="number">2</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &lt;button onClick=&#123;handleAlertClick&#125; /&gt;; <span class="comment">// 2가 안에 들어있음</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="이벤트-핸들러가-특정-렌더링에-속해있으며-alert-표시를-클릭할-때-그-렌더링-시점의-count-state를-유지한-채로-사용하는-것"><a href="#이벤트-핸들러가-특정-렌더링에-속해있으며-alert-표시를-클릭할-때-그-렌더링-시점의-count-state를-유지한-채로-사용하는-것" class="headerlink" title="이벤트 핸들러가 특정 렌더링에 속해있으며, alert 표시를 클릭할 때 그 렌더링 시점의 count state를 유지한 채로 사용하는 것"></a>이벤트 핸들러가 특정 렌더링에 속해있으며, alert 표시를 클릭할 때 그 렌더링 시점의 count state를 유지한 채로 사용하는 것</h3><p>특정 렌더링 시 그 내부에서 props와 state는 영원히 같은 상태로 유지된다.</p>
<p>🤔 만약 props와 state가 렌더링으로부터 분리되어 있다면?</p>
<p>: 이를 사용하는 어떠한 값도 분리되어 있는 것. 그러므로 props와 state도 렌더링에 속해있는 것이고, 이벤트 핸들러 내부의 비동기 함수라 할지라도 count 값을 보게 된다.</p>
<br />

<h2 id="모든-렌더링은-고유의-effect를-가진다"><a href="#모든-렌더링은-고유의-effect를-가진다" class="headerlink" title="모든 렌더링은 고유의 effect를 가진다."></a>모든 렌더링은 고유의 effect를 가진다.</h2><p>어떻게 effect가 최신의 count 상태를 읽어들일까?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  **<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">  &#125;);**</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Click me</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>현재 count는 컴포넌트 렌더링에 포함되는 상수이므로 가변되는 값은 아닐테고..?</p>
<p>이벤트 핸들러는 그 렌더링에 속한 state를 본다. count는 특정 범위 안에 속하는 변수이기 때문.</p>
<p>effect에도 똑같은 개념이 적용된다!</p>
<br />

<h3 id="effect-함수-자체가-매-렌더링마다-별도로-존재한다"><a href="#effect-함수-자체가-매-렌더링마다-별도로-존재한다" class="headerlink" title="effect 함수 자체가 매 렌더링마다 별도로 존재한다."></a>effect 함수 자체가 매 렌더링마다 별도로 존재한다.</h3><p><em>“변화하지 않는” effect 안에서 count 변수가 임의로 바뀐다는 뜻이 아님</em></p>
<p>각각의 effect 버전은 매번 렌더링에 속한 count 값을 본다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 최초 랜더링 시</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 첫 번째 랜더링의 이펙트 함수</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;<span class="number">0</span>&#125;</span> times`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클릭하면 함수가 다시 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 두 번째 랜더링의 이펙트 함수</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;<span class="number">1</span>&#125;</span> times`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 또 한번 클릭하면, 다시 함수가 호출된다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 세 번째 랜더링의 이펙트 함수</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`You clicked <span class="subst">$&#123;<span class="number">2</span>&#125;</span> times`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<h3 id="리액트는-effect-함수를-기억해-놨다가-DOM의-변화를-처리하고-렌더링하고-난-뒤에-실행한다"><a href="#리액트는-effect-함수를-기억해-놨다가-DOM의-변화를-처리하고-렌더링하고-난-뒤에-실행한다" class="headerlink" title="리액트는 effect 함수를 기억해 놨다가 DOM의 변화를 처리하고 렌더링하고 난 뒤에 실행한다."></a>리액트는 effect 함수를 기억해 놨다가 DOM의 변화를 처리하고 렌더링하고 난 뒤에 실행한다.</h3><p>하나의 개념으로서 effect를 설명하고 있지만, <strong>사실 매 렌더링마다 다른 함수라는 의미</strong>이다.</p>
<p>그리고 각각의 effect 함수는 그 렌더링에 속한 props와 state를 본다.</p>
<br />

<p>자세하게 이해할 수 있도록 첫 번째 렌더링을 차례대로 설명해보면</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">리액트: state가 <span class="number">0</span>일 때 <span class="variable constant_">UI</span>를 보여줘.</span><br><span class="line">컴포넌트: 여기 렌더링의 결과물로 &lt;p&gt;<span class="title class_">You</span> clicked <span class="number">0</span> times&lt;/p&gt;가 있어. 그리고 모든 처리가 끝나고 이 이펙트를 실행하는 것 잊지마!</span><br><span class="line">리액트: 좋아. <span class="variable constant_">UI</span> 업데이트 함. 야 브라우저 <span class="variable constant_">DOM</span>에 뭐 추가 좀 해도되냐.</span><br><span class="line">브라우저: ㅇㅋ 내가 그려줌.</span><br><span class="line">리액트: 땡큐. 이제 컴포넌트야 너가 준 effect 실행할게! <span class="function">() =&gt;</span> &#123;<span class="variable language_">document</span>.<span class="property">title</span>= <span class="string">&#x27;You clicked 0 times&#125; 실행 중</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>그렇다면 버튼을 클릭했을 때 무슨 일이 일어나는지 다시 한 번 생각해보자.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">컴포넌트: 야 리액트 내 상태 변경 좀;</span><br><span class="line">리액트: 상태 <span class="number">1</span>일 때 <span class="variable constant_">UI</span> 줄 수 있음?</span><br><span class="line">컴포넌트: 렌더링 결과물로 &lt;p&gt;<span class="title class_">You</span> clicked <span class="number">1</span> times&lt;/p&gt;가 있어. 모든 처리가 끝나면 이펙트 실행하는 거 잊지마!</span><br><span class="line">리액트: 오키. <span class="variable constant_">UI</span> 업데이트 할게. 야 브라우저 <span class="variable constant_">DOM</span>에 추가 좀 해도 되냐?</span><br><span class="line">브라우저: ㅇㅇ 내가 그려줄게</span><br><span class="line">리액트: 땡큐 그럼 이제 effect 실행할게. () =&gt; &#123; <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;You clicked 1 times&#x27;</span> &#125; 실행 중</span><br></pre></td></tr></table></figure>

<br />

<h2 id="모든-랜더링은-고유의…-모든-것을-가지고-있다"><a href="#모든-랜더링은-고유의…-모든-것을-가지고-있다" class="headerlink" title="모든 랜더링은 고유의… 모든 것을 가지고 있다"></a>모든 랜더링은 고유의… 모든 것을 가지고 있다</h2><p>이제 effect는 렌더링 후에 실행되며, 컴포넌트 결과물의 일부로서 특정 렌더링 시점의 props와 state를 본다는 것을 알았다.</p>
<p>생각이 맞는지 실험해보자. 약간 시간차를 두고 버튼을 여러번 누르면 어떻게 될까?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;You clicked $&#123;count&#125; times`);</span></span><br><span class="line"><span class="string">    &#125;, 3000);</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="string">        Click me</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>각각의 타이머는 특정 렌더링에 속해있기 때문에 버튼을 클릭하면 매번 다른 컴포넌트가 만들어진다. 그러므로 여러번 클릭하더라도 로그는 순서대로 출력될 것이다.</p>
<p>하지만 클래스 컴포넌트로 만들면 이렇게 동작하지 않는다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;<span class="variable language_">this</span>.state.count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;<span class="variable language_">this</span>.state.count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;this.state.count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="language-xml">            this.setState(&#123;</span></span><br><span class="line"><span class="language-xml">              count: this.state.count + 1,</span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          Click me</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>, rootElement);</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;<span class="variable language_">this</span>.state.count&#125;</span> times`</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this.state.count</code> 값은 특정 렌더링 시점의 값이 아니라 언제나 최신의 값을 가리키기 때문이다.</p>
<p>클로저를 사용하여 클래스 컴포넌트 예제를 고칠 수 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>You clicked &#123;this.state.count&#125; times<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="language-xml">            this.setState(&#123;</span></span><br><span class="line"><span class="language-xml">              count: this.state.count + 1,</span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          Click me</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Example</span> /&gt;</span></span>, rootElement);</span><br></pre></td></tr></table></figure>

<h3 id="클로저는-접근하려는-값이-절대-바뀌지-않을-때-유용하다"><a href="#클로저는-접근하려는-값이-절대-바뀌지-않을-때-유용하다" class="headerlink" title="클로저는 접근하려는 값이 절대 바뀌지 않을 때 유용하다."></a><strong>클로저는 접근하려는 값이 절대 바뀌지 않을 때 유용하다.</strong></h3><p>반드시 상수를 참조하고 있기 때문에 생각을 하기 쉽도록 만들어준다. props와 state는 특정 렌더링 안에서 절대 바뀌지 않는다.</p>
<br />

<h2 id="흐름을-거슬러-올라가기"><a href="#흐름을-거슬러-올라가기" class="headerlink" title="흐름을 거슬러 올라가기"></a>흐름을 거슬러 올라가기</h2><blockquote>
<p><em>컴포넌트의 렌더링 안에 있는 모든 함수(이벤트 핸들러, effect, setTimeout)는 렌더가 호출될 때 정의된 porps와 state 값을 잡아둔다.</em></p>
</blockquote>
<p>다시 한 번 위 문장을 생각해보면 두 예제는 같다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">counter</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = props.<span class="property">counter</span>;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(counter);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>props나 state를 컴포넌트 안에서 일찍 읽어들였는지 아닌지는 상관없다. (값들은 변경되지 않기 때문!)</p>
<p>하나의 렌더링 스코프 안에서 props와 state는 변하지 않은 값으로 남아있다.</p>
<br />

<p>🤔 effect 안에 정의해둔 콜백에서 사전에 잡아둔 값을 쓰는 것이 아니라 최신의 값을 이용하고 싶다면?</p>
<p>: 제일 쉬운 방법은 ref를 사용하는 것. 👉🏻 <a href="https://overreacted.io/ko/how-are-function-components-different-from-classes/">함수형 컴포넌트와 클래스, 어떤 차이가 존재할까?</a></p>
<br />

<p>과거의 렌더링 시점에서 미래의 props나 state를 조회해야 할 필요가 있을 때 주의해야 할 것이 이런 방식은 흐름을 거슬러 올라가는 일이다. 잘못되진 않았지만, 패러다임에서 벗어나는게 덜 깨끗해 보일 수 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> latestCount = <span class="title function_">useRef</span>(count);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 변경 가능한 값을 최신으로 설정한다.</span></span><br><span class="line">    latestCount.<span class="property">current</span> = count;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 변경 가능한 최신의 값을 읽어 들인다.</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`You clicked <span class="subst">$&#123;latestCount.current&#125;</span> times`</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>리액트로 어떠한 값을 직접 변경하는 것이 꺼림칙해 보이지만, 리액트의 클래스 컴포넌트는 정확하게 이런 식으로 <code>this.state</code> 를 재할당하고 있다.</p>
<p><strong>미리 잡아둔 props 및 state와는 달리 특정 콜백에서 <code>latestCount.current</code> 의 값을 읽어 들일 때 언제나 같은 값을 보장하지 않는다.</strong></p>
<p>정의된 바에 따라 이 값은 언제나 변경할 수 있다. 그렇기 때문에 이런 사용 방법은 기본 동작이 아니다.</p>
<br />

<h2 id="그러면-클린업-cleanup-은-뭐지"><a href="#그러면-클린업-cleanup-은-뭐지" class="headerlink" title="그러면 클린업(cleanup)은 뭐지?"></a>그러면 클린업(cleanup)은 뭐지?</h2><p>어떤 effect는 클린업 단계를 가질 수도 있다.</p>
<br />

<h3 id="클린업의-목적은-구독과-같은-이벤트를-되돌리는-것"><a href="#클린업의-목적은-구독과-같은-이벤트를-되돌리는-것" class="headerlink" title="클린업의 목적은 구독과 같은 이벤트를 되돌리는 것."></a>클린업의 목적은 구독과 같은 이벤트를 되돌리는 것.</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeToFriendStatus</span>(props.<span class="property">id</span>, handleStatusChange);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>첫 번째 렌더링에서 prop이 {id: 10}이고, 두 번째 렌더링에서 {id: 20}이라고 가정해보자.</p>
<ul>
<li>리액트가 {id: 10}을 다루는 이펙트를 클린업한다.</li>
<li>리액트가 {id: 20}을 가지고 UI를 렌더링한다.</li>
<li>리액트가 {id: 20}을 다루는 이펙트를 실행한다.</li>
</ul>
<p>이 멘탈 모델대로라면, 클린업이 리렌더링 되기 전에 실행되고 이전에 prop을 보고 그 다음 새 effect가 리렌더링 이후 실행되기 때문에 새 prop을 본다고 생각할 수 있다. 👉🏻 클래스의 라이프사이클</p>
<p>여기서는 잘못된 내용. 왜 그런지 알아보자.</p>
<br />

<h3 id="리액트는-브라우저가-페인트하고-난-뒤에야-effect를-실행한다"><a href="#리액트는-브라우저가-페인트하고-난-뒤에야-effect를-실행한다" class="headerlink" title="리액트는 브라우저가 페인트하고 난 뒤에야 effect를 실행한다."></a>리액트는 브라우저가 페인트하고 난 뒤에야 effect를 실행한다.</h3><p>대부분의 effect가 스크린 업데이트를 가로막지 않기 때문에 앱을 빠르게 만들어준다. 마찬가지로 effect의 cleanup도 미뤄진다. 이전 effect는 새 prop과 함께 리렌더링 되고 난 뒤에 클린업 된다.</p>
<ul>
<li>리액트가 {id: 20}을 가지고 UI를 렌더링한다.</li>
<li>브라우저가 실제 그리기를 한다. 화면 상에서 {id: 20}이 반영된 UI를 볼 수 있다.</li>
<li>리액트는 {id: 10}에 대한 이펙트를 클린업한다.</li>
<li>리액트가 {id: 20}에 대한 이펙트를 실행한다.</li>
</ul>
<br />

<p>🤔 어떻게 prop이 {id: 20}으로 바뀌고 나서도 이펙트의 클린업이 이전 값인 {id: 10}을 보는거지?</p>
<p>: 이전 단락을 이용해보자면,</p>
<blockquote>
<p><em>컴포넌트가 렌더링 안에 있는 <strong>모든</strong> 함수는 (이벤트 핸들러, 이펙트, 타임아웃이나 그 안에서 호출되는 API 등) 랜더가 호출될 때 정의된 props와 state 값을 잡아둔다.</em></p>
</blockquote>
<p>즉, 이펙트의 클린업은 최신 prop을 읽지 않는다. 클린업이 정의된 시점의 렌더링에 있던 값을 읽는다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 첫 번째 랜더링, props는 &#123;id: 10&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 첫 번째 랜더링의 이펙트</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">      <span class="comment">// 첫 번째 랜더링의 클린업</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">10</span>, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 다음 랜더링, props는 &#123;id: 20&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 두 번째 랜더링의 이펙트</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">ChatAPI</span>.<span class="title function_">subscribeToFriendStatus</span>(<span class="number">20</span>, handleStatusChange);</span><br><span class="line">      <span class="comment">// 두 번째 랜더링의 클린업</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">ChatAPI</span>.<span class="title function_">unsubscribeFromFriendStatus</span>(<span class="number">20</span>, handleStatusChange);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="리액트는-페인팅-이후-effect를-다루는게-기본이며-그-결과-앱을-빠르게-만들어-준다"><a href="#리액트는-페인팅-이후-effect를-다루는게-기본이며-그-결과-앱을-빠르게-만들어-준다" class="headerlink" title="리액트는 페인팅 이후 effect를 다루는게 기본이며 그 결과 앱을 빠르게 만들어 준다."></a>리액트는 페인팅 이후 effect를 다루는게 기본이며 그 결과 앱을 빠르게 만들어 준다.</h3><hr>
<h2 id="라이프사이클이-아니라-동기화"><a href="#라이프사이클이-아니라-동기화" class="headerlink" title="라이프사이클이 아니라 동기화"></a>라이프사이클이 아니라 동기화</h2><p>리액트는 처음 렌더링 결과물과 업데이트를 통합하여 표현한다.</p>
<p>이로 인해 프로그램의 엔트로피를 줄일 수 있다. <em>(이게 뭘 의미하는거지?)</em></p>
 <br />

<p><strong>“엔트로피”는 코드의 무질서 또는 예측 불가능성 정도를 나타낸다.</strong></p>
<blockquote>
<p>만약 프로그램이 명령형 스타일로 작성되면 경로를 추적하기가 어려워져 버그 및 기타 예기치 않은 동작이 발생할 수 있다. 리액트는 반대로 선언적 스타일로 작성하기 때문에 코드를 더 쉽게 이해하고 유지 관리할 수 있도록 한다.</p>
</blockquote>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">&#123; name &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Greeting&quot;</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;Greeting name=&quot;Dan&quot; /&gt;</code> 을 렌더링 한 다음에 <code>&lt;Greeting name=&quot;Yuzhi&quot; /&gt;</code>를 렌더링하던지, 아예 <code>&lt;Greeting name=&quot;Yuzhi&quot; /&gt;</code>만 렌더링하던지 모든 경우의 결과는 “Hello, Yuzhi”로 같다.</p>
<br />

<h3 id="리액트는-우리가-지정한-props와-state에-따라-DOM과-동기화한다"><a href="#리액트는-우리가-지정한-props와-state에-따라-DOM과-동기화한다" class="headerlink" title="리액트는 우리가 지정한 props와 state에 따라 DOM과 동기화한다."></a>리액트는 우리가 지정한 props와 state에 따라 DOM과 동기화한다.</h3><p>렌더링 시 “마운트”와 “업데이트”의 구분이 없다.</p>
<p>effect도 같은 방식으로 생각해야 한다. <code>useEffect</code> 는 리액트 트리 바깥에 있는 것들을 props와 state에 따라 동기화 할 수 있게 한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">&#123; name &#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    **<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;**</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Hello, &#123;name&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드는 마운트&#x2F;업데이트&#x2F;언마운트 멘탈 모델과는 다르다. 만약 컴포넌트가 첫 번째로 렌더링할 때와 그 후에 다르게 동작하는 effect를 작성하려고하면 흐름을 거스르는 일을 하려고 하는 것.</p>
<p>렌더링 결과물이 목적지에 따라가는 것이 아니라 여정에 따른다면 동기화에 실패한다.</p>
<p>컴포넌트를 prop A, B, C 순서로 렌더링하던지, 바로 C를 렌더링하던지 별로 신경쓰이지 않아야 한다. 결국 마지막의 결과물은 같아야 한다.</p>
<p>당연하지만 여전히 모든 effect를 매번 렌더링마다 실행하는 것은 효율이 떨어질 수 있다. 그렇다면 이 문제를 어떻게 해결할 수 있을까?</p>
<br />

<h2 id="리액트에게-effect를-비교하는-법을-가르치기"><a href="#리액트에게-effect를-비교하는-법을-가르치기" class="headerlink" title="리액트에게 effect를 비교하는 법을 가르치기"></a>리액트에게 effect를 비교하는 법을 가르치기</h2><p>우리는 리액트가 DOM 전체를 매번 새로 그리는 것이 아니라 실제로 바뀐 부분만 DOM을 업데이트한다는 것을 배웠다.</p>
<p>아래의 컴포넌트를</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;Greeting&quot;</span>&gt;<span class="title class_">Hello</span>, <span class="title class_">Dan</span>&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>이렇게 바꾼다면</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">&lt;h1 className=<span class="string">&quot;Greeting&quot;</span>&gt;<span class="title class_">Hello</span>, <span class="title class_">Yuzhi</span>&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>리액트는 두 객체를 비교</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> oldProps = &#123; <span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Dan&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> newProps = &#123; <span class="attr">className</span>: <span class="string">&#x27;Greeting&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;Hello, Yuzhi&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>각각의 prop을 짚어보고 children이 바뀌어서 DOM 업데이트가 필요하다고 파악했지만 className은 동일하므로</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">domNode.<span class="property">innerText</span> = <span class="string">&#x27;Hello, Yuzhi&#x27;</span>;</span><br><span class="line"><span class="comment">// domNode.className 은 건드릴 필요가 없다</span></span><br></pre></td></tr></table></figure>

<p>위 코드만 호출된다.</p>
<br />

<h3 id="🤔-이펙트를-적용할-필요가-없다면-다시-실행하지-않는-것이-좋을텐데-이펙트에도-이런-방법을-적용하면-되지-않을까"><a href="#🤔-이펙트를-적용할-필요가-없다면-다시-실행하지-않는-것이-좋을텐데-이펙트에도-이런-방법을-적용하면-되지-않을까" class="headerlink" title="🤔 이펙트를 적용할 필요가 없다면 다시 실행하지 않는 것이 좋을텐데, 이펙트에도 이런 방법을 적용하면 되지 않을까?"></a>🤔 이펙트를 적용할 필요가 없다면 다시 실행하지 않는 것이 좋을텐데, 이펙트에도 이런 방법을 적용하면 되지 않을까?</h3><p>예를 들어, 아래의 컴포넌트는 상태 변화 때문에 다시 렌더링 될 것이다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">&#123; name &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Hello, &#123;name&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCounter(count + 1)&#125;&gt;Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 effect는 counter 상태값을 사용하지 않는다. 이펙트는 <code>document.title</code> , <code>name</code> prop을 동기화 하지만 name prop은 같다. <code>document.title</code> 을 매번 counter 값이 바뀔 때마다 재할당하는 것은 효율적이지 않아보인다.</p>
<p>그렇다면 이펙트를 비교하면 안될까?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">oldEffect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, Dan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">newEffect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, Dan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 리액트가 이 배열을 같은 배열이라고 인식할 수 있을까?</span></span><br></pre></td></tr></table></figure>

<p>리액트는 함수를 호출해보지 않고 함수가 어떤 일을 하는지 알아낼 수는 없다.</p>
<p>그래서 <strong>특정한 이펙트가 불필요하게 다시 실행되는 것을 방지하고 싶다면 의존성 배열(”deps”)</strong> 을 useEffect 인자로 전달할 수 있는 것이다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">&#125;, [name]); <span class="comment">// 우리의 의존성</span></span><br></pre></td></tr></table></figure>

<p>이건 마치 우리가 리액트에게</p>
<p><em>“야 리액트 너가 이 함수의 안을 볼 수 없는건 아는데 렌더링 스코프에서 name 이외 값은 쓰지 않는다고 약속할게”</em></p>
<p>라고 말하는 것과 같다.</p>
<br />

<p>현재와 이전 이펙트 발동 시 이 값들이 같다면 동기화할 것은 없으니 리액트는 이펙트를 스킵할 수 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">oldEffect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, Dan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oldDeps = [<span class="string">&#x27;Dan&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">newEffect</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, Dan&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> newDeps = [<span class="string">&#x27;Dan&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리액트는 함수 안을 살펴볼 수 없지만, deps를 비교할 수 있다.</span></span><br><span class="line"><span class="comment">// 모든 deps가 같으므로, 새 이펙트를 실행할 필요가 없다.</span></span><br></pre></td></tr></table></figure>

<p>렌더링 사이에 의존성 배열 안에 있는 값이 하나라도 다르면 이펙트를 스킵할 수 없다.</p>
<br />

<h2 id="리액트에게-의존성으로-거짓말하지-마라"><a href="#리액트에게-의존성으로-거짓말하지-마라" class="headerlink" title="리액트에게 의존성으로 거짓말하지 마라"></a>리액트에게 의존성으로 거짓말하지 마라</h2><p>의존성에 대해 리액트에게 거짓말을 할 경우 좋지 않은 결과를 가져온다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []); <span class="comment">// 이게 맞을까요? 항상 그렇진 않지요. 그리고 더 나은 방식으로 코드를 작성하는 방법이 있습니다.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“하지만 저는 마운트 될 때만 이펙트를 실행하고 싶다고요!” 라고 할 수 있다.</p>
<div style="background-color:#CCEEFF; padding: 1rem; text-align: center;">
🚀 일단 지금은 deps를 지정한다면 컴포넌트 있는 모든 값(porps, state, 함수들 등 컴포넌트 안에 있는 모두 다) 중 <br /> 그 이펙트에 허용될 값은 반드시 거기 있어야 한다는 것을 기억해두자.

</div>

<p>위 코드는 문제를 일으킬 수 있다. 예를 들어 데이터 불러오는 로직이 무한 루프에 빠질 수도 있고, 소켓이 너무 자주 반응할 수도 있다. 이런 문제를 해결하는 방법은 의존성을 제거하는 것이 아니다.</p>
<p>일단 이 문제에 대해 더 자세히 알아보자.</p>
<br />

<h2 id="의존성으로-거짓말을-하면-생기는-일"><a href="#의존성으로-거짓말을-하면-생기는-일" class="headerlink" title="의존성으로 거짓말을 하면 생기는 일"></a>의존성으로 거짓말을 하면 생기는 일</h2><p>만약 deps가 이펙트에 사용하는 모든 값을 가지고 있다면 이펙트는 언제 다시 이펙트를 실행해야 할 지 알고 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">&#125;, [name]);</span><br></pre></td></tr></table></figure>

<p><img src="https://overreacted.io/fae247cd068eedbd4b62ba50592d2b3d/deps-compare-correct.gif" alt="https://overreacted.io/fae247cd068eedbd4b62ba50592d2b3d/deps-compare-correct.gif"></p>
<p>👉🏻 의존성이 다르기 때문에 이펙트를 다시 실행한다.</p>
<br />

<p>만약 이펙트에 <code>[]</code> 를 넘겨주었다면? 새 이펙트 함수는 실행되지 않는다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">&#125;, []); <span class="comment">// 틀렸음: deps에 name이 없다</span></span><br></pre></td></tr></table></figure>

<p><img src="https://overreacted.io/25f75db3f9f57ffe1426912093577445/deps-compare-wrong.gif" alt="https://overreacted.io/25f75db3f9f57ffe1426912093577445/deps-compare-wrong.gif"></p>
<br />

<p>또 하나의 예를 들어보자.</p>
<p>예를 들어, 매 초마다 숫자가 올라가는 카운터를 작성한다고 해보자. 클래스 컴포넌트의 개념을 적용했을 때 우리의 직관은</p>
<p><em>“인터벌을 한 번만 실행하고, 한 번만 제거하자”</em></p>
<p>가 된다. 이 생각을 가지고 useEffect를 사용한 코드로 변환하게 되면, 직관적으로 deps에 <code>[]</code>를 넣게 된다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 예제는 한 번만 증가한다.</p>
<p>의존성 배열은 내가 언제 이펙트를 다시 실행해야 할지 지정할 때 쓰인다.라고 생각하면 자가당착에 빠진다.</p>
<p>하지만 의존성 배열이 리액트에게 어떤 렌더링 스코프에서 나온 값 중 이펙트에 쓰이는 것 전부를 알려주는 힌트라고 인식한다면 말이된다.</p>
<p>count를 사용하지만 deps를 <code>[]</code>라고 정의하면서 거짓말을 했기 때문에 이런 오류가 발생하는 것이다.</p>
<br />

<p>첫 번째 렌더링에서 count는 0이다. 따라서 첫 번째 렌더링 이펙트에서 <code>setCount(count + 1)</code>는 <code>setCount(0 + 1)</code> 이라는 뜻이 된다.</p>
<p>deps를 []라고 정의했기 때문에 이펙트를 다시 실행하지 않고 결국 그로 인해 매 초마다 setCount(0 + 1)을 호출하는 것이다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 첫 번째 랜더링, state는 0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 첫 번째 랜더링의 이펙트</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(<span class="number">0</span> + <span class="number">1</span>); <span class="comment">// 언제나 setCount(1)</span></span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [] <span class="comment">// 절대 다시 실행하지 않는다</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매번 다음 랜더링마다 state는 1이다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 이 이펙트는 언제나 무시될 것</span></span><br><span class="line">    <span class="comment">// 왜냐면 리액트에게 빈 deps를 넘겨주는 거짓말을 했기 때문</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(<span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>지금 우리는 리액트에게 이펙트는 컴포넌트 안에 값을 쓰지 않는다고 거짓말을 한 상태이다.</p>
<p>이펙트는 컴포넌트 안에 있는 값인 count 값을 쓰고 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []);</span><br></pre></td></tr></table></figure>

<p>따라서 <code>[]</code> 을 의존성 배열로 지정하는 것은 버그를 만들 것이다. 리액트는 배열을 비교하고, 이 이펙트를 업데이트 하지 않는다.</p>
<p><img src="https://overreacted.io/29e53bd0c9b7d2ac70d3cd924886b030/interval-wrong.gif" alt="https://overreacted.io/29e53bd0c9b7d2ac70d3cd924886b030/interval-wrong.gif"></p>
<p>이런 종류의 이슈는 떠올리기 어렵다. 따라서 언제나 이펙트에 <strong>의존성을 솔직하게 전부 명시하는 것</strong>을 중요한 규칙으로 받아들여야한다. 👉🏻 이 규칙을 강제하길 원할 때 쓸 수 있는 <a href="https://github.com/facebook/react/issues/14920">린트 규칙</a></p>
<br />

<h2 id="의존성을-솔직하게-적는-두-가지-방법"><a href="#의존성을-솔직하게-적는-두-가지-방법" class="headerlink" title="의존성을 솔직하게 적는 두 가지 방법"></a>의존성을 솔직하게 적는 두 가지 방법</h2><p>의존성을 솔직하게 적는 두 가지 전략이 있다.</p>
<h3 id="1-컴포넌트-안에-있으면서-이펙트에-사용되는-모든-값이-의존성-배열-안에-포함되도록-수정"><a href="#1-컴포넌트-안에-있으면서-이펙트에-사용되는-모든-값이-의존성-배열-안에-포함되도록-수정" class="headerlink" title="1. 컴포넌트 안에 있으면서 이펙트에 사용되는 모든 값이 의존성 배열 안에 포함되도록 수정"></a>1. 컴포넌트 안에 있으면서 이펙트에 사용되는 모든 값이 의존성 배열 안에 포함되도록 수정</h3><p>count를 deps 안에 추가하기</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>

<p>이제 count 값은 이펙트를 다시 실행하고 매번 다음 인터벌에서 <code>setCount(count + 1)</code> 부분은 해당 렌더링 시점의 count 값을 사용할 것이다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 첫 번째 랜더링, state는 0</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 첫 번째 랜더링의 이펙트</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(<span class="number">0</span> + <span class="number">1</span>); <span class="comment">// setCount(count + 1)</span></span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">0</span>] <span class="comment">// [count]</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 랜더링, state는 1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(</span><br><span class="line">    <span class="comment">// 두 번째 랜더링의 이펙트</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(<span class="number">1</span> + <span class="number">1</span>); <span class="comment">// setCount(count + 1)</span></span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] <span class="comment">// [count]</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 문제를 해결하겠지만 count 값이 바뀔 때마다 인터벌은 해제되고 다시 설정될 것이다.</p>
<p><img src="https://overreacted.io/5734271ddfa94d2d65ac6160515e0069/interval-rightish.gif" alt="https://overreacted.io/5734271ddfa94d2d65ac6160515e0069/interval-rightish.gif"></p>
<p>👉🏻 의존성이 다르기 때문에 이펙트를 다시 실행한다.</p>
<br />

<h3 id="2-이펙트의-코드를-바꿔서-자주-바뀌는-값을-요구하지-않도록-만드는-것"><a href="#2-이펙트의-코드를-바꿔서-자주-바뀌는-값을-요구하지-않도록-만드는-것" class="headerlink" title="2. 이펙트의 코드를 바꿔서 자주 바뀌는 값을 요구하지 않도록 만드는 것"></a>2. 이펙트의 코드를 바꿔서 자주 바뀌는 값을 요구하지 않도록 만드는 것</h3><p>의존성을 더 적게 넘겨주도록 바꾸면 된다.</p>
<p>의존성을 제거하는 몇 가지 공통적인 기술을 살펴보자.</p>
<hr>
<h2 id="이펙트가-자급자족-하도록-만들기"><a href="#이펙트가-자급자족-하도록-만들기" class="headerlink" title="이펙트가 자급자족 하도록 만들기"></a>이펙트가 자급자족 하도록 만들기</h2><p>이펙트의 의존성에서 count를 제거하도록 만들고 싶다면?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></figure>

<p>우리는 지금 무엇때문에 count를 쓰고 있는 걸까? 오로지 setCount를 위해 사용하고 있다.</p>
<p>사실 이 경우는 count를 쓸 필요가 없다. 이전 상태를 기준으로 상태 값을 업데이트 하고싶을 때는 setState에 <strong>함수 형태의 업데이터</strong>를 사용하면 된다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure>

<ul>
<li>이전 코드에서 count는 setCount(count + 1)이라고 썼기 때문에 이펙트 안에서 필요한 의존성이었다.</li>
<li>하지만 count를 count + 1로 변환하여 리액트에게 돌려주기 위해 원했을 뿐. (그러나 리액트는 현재의 count를 이미 알고있다.)</li>
<li>우리가 리액트에게 알려줘야 하는 것은? 지금 값이 뭐든 간에 상태 값을 하나 더하라는 것</li>
</ul>
<p>👉🏻 그게 정확히 setCount(c ⇒ c + 1)이 의도하는 것</p>
<br />

<p>리액트에게 상태가 어떻게 바뀌어야 하는지 “지침을 보내는 것”이라고 생각할 수 있다. 이 “업데이터 형태” 또한 다른 케이스에서 사용할 수 있다. 👉🏻 <a href="https://overreacted.io/react-as-a-ui-runtime/#batching">여러개의 업데이트를 묶어서 처리해야할 때(batching)</a></p>
<p><img src="https://overreacted.io/f128ad20c28317ed27a3cb68197fc906/interval-right.gif" alt="https://overreacted.io/f128ad20c28317ed27a3cb68197fc906/interval-right.gif"></p>
<p>이 이펙트가 한 번만 실행되었다 하더라도, 첫 번째 렌더링에 포함되는 인터벌 콜백은 인터벌이 실행될 때마다 <code>c ⇒ c + 1</code> 이라는 업데이트 지침을 전달하는데 완벽하게 들어맞는다. 더 이상 현재의 count 상태</p>
<br />

<h2 id="함수형-업데이트와-Google-Docs"><a href="#함수형-업데이트와-Google-Docs" class="headerlink" title="함수형 업데이트와 Google Docs"></a>함수형 업데이트와 Google Docs</h2><p>동기화에 대해 생각할 때 흥미로운 부분은 종종 시스템 간의 ‘메세지’를 상태와 엮이지 않은 채로 유지하고 싶을 때가 있다는 것이다.</p>
<p>예를 들어, Google Docs에서 문서를 편집하는 것은 실제로 서버로 전체 페이지를 보내는 것이 아니다. 그 대신 사용자가 무엇을 하고자 했는지 표현한 것을 보낸다.</p>
<p>우리가 사용하는 경우는 다르겠지만, 이펙트에도 같은 철학이 적용된다.</p>
<p><strong>오로지 필요한 최소한의 정보를 이펙트 안에서 컴포넌트로 전달하는게 최적화에 도움이 된다.</strong></p>
<p>setCount(c ⇒ c + 1) 같은 업데이터 형태는 setCount(count + 1)보다 명백히 적은 정보를 전달한다. 현재의 카운트 값에 오염되지 않기 때문이다. 그저 증가해야한다라는 행위를 표현할 뿐이다.</p>
<br />

<h3 id="하지만-setCount-c-⇒-c-1-조차도-그리-좋은-방법은-아니다"><a href="#하지만-setCount-c-⇒-c-1-조차도-그리-좋은-방법은-아니다" class="headerlink" title="하지만 setCount(c ⇒ c + 1)조차도 그리 좋은 방법은 아니다."></a>하지만 <code>setCount(c ⇒ c + 1)</code>조차도 그리 좋은 방법은 아니다.</h3><p>조금 이상해 보이기도 하고 할 수 있는 일이 굉장히 제한적이다.</p>
<p>예를 들어 서로에게 의존하는 두 상태 값이 있거나 prop 기반으로 다음 상태를 계산할 필요가 있을 때는 도움이 되지 않는다. 다행히도 <code>setCount(c ⇒ c + 1)</code> 은 자매 패턴이 있다. 바로 <code>useReducer</code>.</p>
<br />

<h2 id="액션을-업데이트로부터-분리하기"><a href="#액션을-업데이트로부터-분리하기" class="headerlink" title="액션을 업데이트로부터 분리하기"></a>액션을 업데이트로부터 분리하기</h2><p>이전의 예제를 count와 step 두 가지 상태 변수를 가지는 것으로 바꿔보자.</p>
<p>setInterval은 step 입력값에 따라 count 값을 더한다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [step, setStep] = <span class="title function_">useState</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> c + step);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [step]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;step&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 예제의 현재 동작은 step이 변경되면 인터벌을 다시 시작한다. 이펙트를 분해하고 새로 설정하는데는 아무 문제가 없고, 특별히 좋은 이유가 있지 않다면 분해하는 것을 피하지 말아야 한다.</p>
<p>하지만 step이 바뀐다고 인터벌 시게가 초기화되지 않는 것을 원한다면 어떻게 해야할까?</p>
<p>이펙트의 의존성 배열에서 step을 제거하려면 어떻게 해야할까?</p>
<p>어떤 상태 변수가 다른 상태 변수의 값에 연관되도록 설정하려고 한다면, 두 상태 변수 모두 useReducer로 교체해야한다.</p>
<br />

<h3 id="setSomething-something-gt-같은-코드를-작성하고-있다면-대신-reducer를-써보는-것을-고려하기-좋은-타이밍"><a href="#setSomething-something-gt-같은-코드를-작성하고-있다면-대신-reducer를-써보는-것을-고려하기-좋은-타이밍" class="headerlink" title="setSomething(something =&gt; ...) 같은 코드를 작성하고 있다면, 대신 reducer를 써보는 것을 고려하기 좋은 타이밍!"></a><code>setSomething(something =&gt; ...)</code> 같은 코드를 작성하고 있다면, 대신 reducer를 써보는 것을 고려하기 좋은 타이밍!</h3><p>reducer는 컴포넌트에서 일어나는 ‘액션’의 표현과 그 반응으로 상태가 어떻게 업데이트 되어야 할지를 분리한다.</p>
<p>이펙트 안에서 step의 의존성을 dispatch로 변경하기</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line"><span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;); <span class="comment">// setCount(c =&gt; c + step) 대신에</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">&#125;, [dispatch]);</span><br></pre></td></tr></table></figure>

<ul>
<li>전체 코드</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;step&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">            type: &#x27;step&#x27;,</span></span><br><span class="line"><span class="language-xml">            step: Number(e.target.value),</span></span><br><span class="line"><span class="language-xml">          &#125;);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">step</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span>, rootElement);</span><br></pre></td></tr></table></figure>

<br />

<p>useReducer를 사용하면 좋은 이유는?</p>
<p>: <strong>리액트는 컴포넌트가 유지되는 한 <code>dispatch</code> 함수가 항상 같다는 것을 보장한다.</strong></p>
<br />

<p>따라서 위의 예제에서 인터벌을 다시 구독할 필요가 없어지는 것.</p>
<p>(<em>리액트가 <code>dispatch</code>, <code>setState</code>, <code>useRef</code> 컨테이너 값이 항상 고정되어 있다는 것을 보장하니까 의존성 배열에서 뺄 수도 있지만, 명시해서 나쁠 것은 없다.)</em></p>
<p>effect 안에서 상태를 읽는 대신 무슨 일이 일어났는지 알려주는 정보를 인코딩하는 액션을 dispatch한다. 이렇게 해서 이펙트는 step 상태로부터 분리되어 있게 된다.</p>
<p>effect는 어떻게 상태를 업데이트할지 신경쓰지 않고, 단지 무슨 일이 일어났는지 알려준다. 그리고 reducer가 업데이트 로직을 모아둔다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">step</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; count, step &#125; = state;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: count + step, step &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;step&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; count, <span class="attr">step</span>: action.<span class="property">step</span> &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<h2 id="왜-useReducer가-Hooks의-치트-모드인가"><a href="#왜-useReducer가-Hooks의-치트-모드인가" class="headerlink" title="왜 useReducer가 Hooks의 치트 모드인가?"></a>왜 useReducer가 Hooks의 치트 모드인가?</h2><p>우리는 이펙트가 이전 상태를 기준으로 상태를 설정할 필요가 있을 때 어떻게 의존성을 제거하는지 살펴보았다.</p>
<p>하지만 다음 상태를 계산하는데 props가 필요하다면 어떨까? 예를 들어, API가 <code>&lt;Count step=&#123;1&#125; /&gt;</code> 이라면?</p>
<p>의존성으로 props.step을 설정하는 것을 피할 수 없나? 피할 수 있다.</p>
<p>reducer 자체를 컴포넌트 안에 정의하여 props를 읽도록 하면 된다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params">&#123; step &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(reducer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;tick&#x27;</span>) &#123;</span><br><span class="line">      **<span class="keyword">return</span> state + step;**</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;tick&#x27;</span> &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, [dispatch]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>이 경우조차 랜더링간 <code>dispatch</code> 의 동일성은 여전히 보장된다.</strong> 그래서 원한다면 이펙트의 의존성 배열에서 빼버릴 수도 있다.</p>
<br />

<p>“이게 어떻게 가능하지?”, “어떻게 다른 렌더링에 포함된 이펙트 안에서 호출된 reducer가 props를 알고있지?”라는 생각이 들 수도 있다. 👉🏻 답은 <code>dispatch</code>를 할 때에 있다.</p>
<p>리액트는 그저 액션을 기억해 놓는다.</p>
<p>하지만 다음 렌더링 중에 reducer를 호출할 것이다. 이 시점에서 새 props가 스코프 안으로 들어오고 이펙트 내부와는 상관이 없게되는 것.</p>
<p>이래서 useReducer를 Hooks의 치트모드라고 생각하는 것이다. 업데이트 로직과 그로 인해 무엇이 일어나는지 서술하는 것을 분리할 수 있도록 만들어준다. 그 다음은 이펙트의 불필요한 의존성을 제거하여 필요할 때 보다 더 자주 실행되는 것을 피할 수 있도록 도와준다.</p>
<br />

<h2 id="함수를-이펙트-안으로-옮기기"><a href="#함수를-이펙트-안으로-옮기기" class="headerlink" title="함수를 이펙트 안으로 옮기기"></a>함수를 이펙트 안으로 옮기기</h2><p>흔한 실수 중 하나가 함수는 의존성에 포함되면 안된다는 것이다.</p>
<p>예를 들어보면, 이 코드는 동작하는 것처럼 보일 수 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">      <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []); <span class="comment">// 이거 괜찮은가?</span></span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>일단 코드는 동작한다. 하지만 간단히 로컬 함수를 의존성에서 제외하는 해결책은 컴포넌트가 커지면서 모든 경우를 다루고 있는지 보장하기 아주 힘들다는 문제가 있다.</p>
<p>각 함수가 5배는 커져서 코드를 나누었다고 가정해보자.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 이 함수가 길다고 상상해 봅시다</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 함수도 길다고 상상해 봅시다</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이제 나중에 이 함수들 중에 하나가 state나 prop을 사용한다고 생각해 보자.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 함수가 길다고 상상해 봅시다</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 이 함수가 길다고 상상해 봅시다</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 이런 함수를 어떠한 이펙트에도 deps를 업데이트 하는 것을 깜빡했다면, 이펙트는 prop과 state의 변화에 동기화하는데 실패할 것이다.</p>
<p>다행히도, 이 문제를 해결할 수 있는 방법이 있다.</p>
<br />

<h3 id="함수를-이펙트-안에서만-사용한다면-그-함수를-직접-이펙트-안으로-옮긴다"><a href="#함수를-이펙트-안에서만-사용한다면-그-함수를-직접-이펙트-안으로-옮긴다" class="headerlink" title="함수를 이펙트 안에서만 사용한다면 그 함수를 직접 이펙트 안으로 옮긴다."></a>함수를 이펙트 안에서만 사용한다면 그 함수를 직접 이펙트 안으로 옮긴다.</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 아까의 함수들을 안으로 옮겼어요!</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=react&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">      <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ Deps는 OK</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>나중에 getFetchUrl을 수정하고 query state를 써야한다고 하면 이펙트 안에 있는 함수만 고치면 된다는 것을 발견할 수 있다. query를 이펙트의 의존성으로 추가만 하면 된다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(<span class="title function_">getFetchUrl</span>());</span><br><span class="line">      <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, [query]); <span class="comment">// ✅ Deps는 OK</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<h2 id="하지만-저는-이-함수를-이펙트-안에-넣을-수-없어요"><a href="#하지만-저는-이-함수를-이펙트-안에-넣을-수-없어요" class="headerlink" title="하지만 저는 이 함수를 이펙트 안에 넣을 수 없어요."></a>하지만 저는 이 함수를 이펙트 안에 넣을 수 없어요.</h2><img src="https://i.pinimg.com/564x/a3/43/cb/a343cb11d7fdecca055dc2d0e98cf58e.jpg" style="width: 512px">

<p>때때로 함수를 이펙트 안에 옮기고 싶지 않을 수도 있다.</p>
<p>예를 들어, 한 컴포넌트에서 여러개의 이펙트가 있는데 같은 함수를 호출할 때, 로직을 복붙하고 싶지는 않다.</p>
<p>이런 함수를 이펙트의 의존성으로 정의하지 말아야할까?</p>
<p>다시 말하자면, 이펙트는 자신의 의존성에 대해 거짓말을 하면 안된다.</p>
<p>보통은 더 나은 해결책이 있다. 흔한 오해 중 하나가 ‘함수는 절대 바뀌지 않는다’이다. 하지만 글을 통해 배웠듯, <strong>컴포넌트 안에 정의된 함수는 매 렌더링마다 바뀐다.</strong></p>
<p>하지만 그로 인해 문제가 발생한다. 두 이펙트가 getFetchUrl을 호출한다고 가정해보자.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 빠진 dep: getFetchUrl</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 빠진 dep: getFetchUrl</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 경우 <code>getFetchUrl</code>을 각각의 이펙트 안으로 옮기게 되면 로직을 공유할가 없는데..?</p>
<p>두 이펙트 모두 매 렌더링마다 바뀌는 <code>getFetchUrl</code> 에 기대고 있으니, 의존성 배열도 쓸모가 없다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 🔴 매번 랜더링마다 모든 이펙트를 다시 실행한다</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, [getFetchUrl]); <span class="comment">// 🚧 Deps는 맞지만 너무 자주 바뀐다</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, [getFetchUrl]); <span class="comment">// 🚧 Deps는 맞지만 너무 자주 바뀐다</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<p>어떻게 해결해야 할까? 간단한 해결책 두 가지가 있다.</p>
<h3 id="함수가-컴포넌트-스코프-안의-어떠한-것도-사용하지-않는다면-컴포넌트-외부로-끌어올려두고-이펙트-안에서-자유롭게-사용한다"><a href="#함수가-컴포넌트-스코프-안의-어떠한-것도-사용하지-않는다면-컴포넌트-외부로-끌어올려두고-이펙트-안에서-자유롭게-사용한다" class="headerlink" title="함수가 컴포넌트 스코프 안의 어떠한 것도 사용하지 않는다면, 컴포넌트 외부로 끌어올려두고 이펙트 안에서 자유롭게 사용한다."></a>함수가 컴포넌트 스코프 안의 어떠한 것도 사용하지 않는다면, 컴포넌트 외부로 끌어올려두고 이펙트 안에서 자유롭게 사용한다.</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line">**<span class="comment">// ✅ 데이터 흐름에 영향을 받지 않는다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFetchUrl</span>(<span class="params">query</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">&#125;**</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, []); <span class="comment">// ✅ Deps는 OK</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, []); <span class="comment">// ✅ Deps는 OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>저 함수는 렌더링 스코프에 포함되어 있지 않으며, 데이터 흐름에 영향을 받을 수 없기 때문에 deps에 명시할 필요가 없다.</p>
<br />

<h3 id="useCallback-훅으로-감싼다"><a href="#useCallback-훅으로-감싼다" class="headerlink" title="useCallback 훅으로 감싼다."></a>useCallback 훅으로 감싼다.</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ✅ 여기 정의된 deps가 같다면 항등성을 유지한다</span></span><br><span class="line">  <span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ 콜백의 deps는 OK</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, [getFetchUrl]); <span class="comment">// ✅ 이펙트의 deps는 OK</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, [getFetchUrl]); <span class="comment">// ✅ 이펙트의 deps는 OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<p><strong><code>useCallback</code> 은 의존성 체크에 레이어를 하나 더 더하는 것이다.</strong></p>
<p>다시 말해서 문제를 다른 방식으로 해결하는데, 함수의 의존성을 피하기보다 함수 자체가 필요할 때만 바뀔 수 있도록 만드는 것</p>
<p>이 접근 방식이 왜 유용한걸까?</p>
<p>아까 예제는 <code>&#39;react&#39;</code>, <code>&#39;redux&#39;</code> 라는 두 가지 검색 결과를 보여주었다. 하지만 입력을 받는 부분을 추가하여 임의의 query를 검색할 수 있다고 가정해보자. 그래서 query를 인자로 받는 대신 <code>getFetchUrl</code> 이 지역 상태로부터 이를 읽어들인다.</p>
<p>그렇게 수정하면서 즉시 query 의존성이 빠져있다는 사실을 파악할 수 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// No query argument</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 빠진 의존성: query</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<p>useCallback의 deps에 query를 포함하도록 고치면, getFetchUrl을 사용하는 어떤 이펙트라도 query가 바뀔 때마다 실행할 것</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SearchResults</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ query가 바뀔 때까지 항등성을 유지한다</span></span><br><span class="line">  <span class="keyword">const</span> getFetchUrl = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">  &#125;, [query]); <span class="comment">// ✅ 콜백 deps는 OK</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="title function_">getFetchUrl</span>();</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;, [getFetchUrl]); <span class="comment">// ✅ 이펙트의 deps는 OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useCallback</code> 덕분에 <code>query</code> 가 같다면, <code>getFetchUrl</code> 또한 같을 것이며, 이펙트는 다시 실행되지 않을 것이다. 하지만 <code>query</code>가 바뀐다면 <code>getFetchUrl</code> 또한 바뀌고 데이터를 다시 fetch한다.</p>
<p><em>(마치 스프레드 시트에서 어떤 셀을 바꾸면 다른 셀이 자동으로 다시 계산되는 것과 비슷하다.)</em></p>
<br />

<h3 id="그저-데이터-흐름과-동기화에-대한-개념을-받아들인-결과"><a href="#그저-데이터-흐름과-동기화에-대한-개념을-받아들인-결과" class="headerlink" title="그저 데이터 흐름과 동기화에 대한 개념을 받아들인 결과"></a>그저 데이터 흐름과 동기화에 대한 개념을 받아들인 결과</h3><p>부모로부터 함수 prop을 내려보내는 것 또한 같은 해결책이 적용된다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ✅ query가 바뀔 때까지 항등성을 유지한다</span></span><br><span class="line">  <span class="keyword">const</span> fetchData = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 리턴한다 ...</span></span><br><span class="line">  &#125;, [query]); <span class="comment">// ✅ 콜백 deps는 OK</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;fetchData&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123; fetchData &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [data, setData] = <span class="title function_">useState</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>().<span class="title function_">then</span>(setData);</span><br><span class="line">  &#125;, [fetchData]); <span class="comment">// ✅ 이펙트 deps는 OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetchData</code> 는 오로지 <code>Parent</code> 의 <code>query</code> 상태가 바뀔 때만 변하기 때문에, <code>Child</code> 컴포넌트는 앱에 꼭 필요할 때가 아니라면 데이터를 다시 fetch하지 않을 것.</p>
<br />

<h2 id="함수도-데이터-흐름의-일부인가"><a href="#함수도-데이터-흐름의-일부인가" class="headerlink" title="함수도 데이터 흐름의 일부인가?"></a>함수도 데이터 흐름의 일부인가?</h2><p>이 패턴은 클래스 컴포넌트에서 사용하면 제대로 동작하지 않는데, effect와 라이프사이클 패러다임의 결정적인 차이를 보여준다.</p>
<p>위 코드를 클래스 컴포넌트로 치환했다고 가정해보자.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">query</span>: <span class="string">&#x27;react&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  **fetchData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">query</span>;</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;;**</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">  &#125;;</span><br><span class="line">  **<span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;**</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>하지만 이 로직은 <code>componentDidUpdate</code> 에선 동작하지 않는다.</strong></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">    <span class="comment">// 🔴 이 조건문은 절대 참이 될 수 없다</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">fetchData</span> !== prevProps.<span class="property">fetchData</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>당연히도 <code>fetchData</code>는 클래스 메서드이다. state가 바뀌었다고 저 메서드가 달라지지는 않는다.</p>
<br />

<p>따라서 this.props.fetchData는 prevProps.fetchData와 같기 때문에 절대 다시 데이터를 fetch하지 않는다. 그렇다면 아까 조건문을 제거하면 어떻게 될까?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 되면 매번 다시 렌더링할 때마다 데이터를 불러올텐데…?</p>
<br />

<p>혹시 특정한 query를 바인딩해두면?</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData.bind(this,</span> <span class="attr">this.state.query</span>)&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 되면 query가 바뀌지 않았는데도 <code>this.props.fetchData !== prevProps.fetchData</code> 는 언제나 true가 되기 때문에 결국 매번 데이터를 다시 fetch한다.</p>
<br />

<h3 id="진짜-클래스-컴포넌트로-이-문제를-해결하는-방법은-query-자체를-Child-컴포넌트에-넘기는-것-뿐"><a href="#진짜-클래스-컴포넌트로-이-문제를-해결하는-방법은-query-자체를-Child-컴포넌트에-넘기는-것-뿐" class="headerlink" title="진짜 클래스 컴포넌트로 이 문제를 해결하는 방법은 query 자체를 Child 컴포넌트에 넘기는 것 뿐"></a>진짜 클래스 컴포넌트로 이 문제를 해결하는 방법은 query 자체를 Child 컴포넌트에 넘기는 것 뿐</h3><p>Child 컴포넌트가 query를 직접 사용하지 않음에도 불구하고 query가 바뀔 때 다시 데이터를 불러오는 로직은 해결할 수 있다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">query</span>: <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url =</span><br><span class="line">      <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">query</span>;</span><br><span class="line">    <span class="comment">// ... 데이터를 불러와서 무언가를 한다 ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">fetchData</span>=<span class="string">&#123;this.fetchData&#125;</span> <span class="attr">query</span>=<span class="string">&#123;this.state.query&#125;</span> /&gt;</span></span>; <span class="comment">// ✅ query 자체를 넘겨준다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">query</span> !== prevProps.<span class="property">query</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">fetchData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>클래스 컴포넌트에서 함수 prop 자체는 실제로 데이터 흐름에서 차지하는 부분이 없다.</p>
<p>메서드는 가변성이 있는 this 변수에 묶여 있기 때문에 함수의 일관성을 장담할 수 없게된다. 그러므로 우리가 함수만 필요할 때도 ‘차이’를 비교하기 위해 온갖 데이터를 전달해야 했다.</p>
<p>부모 컴포넌트로부터 내려온 this.props.fetchData가 어떤 상태에 기대고 있는지, 아니면 그냥 상태가 바뀌기만 하는 것인지 알 수가 없다.</p>
<br />

<h3 id="useCallback을-사용하면-함수는-명백하게-데이터-흐름에-포함된다"><a href="#useCallback을-사용하면-함수는-명백하게-데이터-흐름에-포함된다" class="headerlink" title="useCallback을 사용하면 함수는 명백하게 데이터 흐름에 포함된다."></a>useCallback을 사용하면 함수는 명백하게 데이터 흐름에 포함된다.</h3><p>만약 함수의 입력값이 바뀌면 함수 자체가 바뀌고, 만약 그렇지 않다면 같은 함수로 남아있다고 말할 수 있다.</p>
<p><code>useCallback</code> 덕분에 <code>props.fetchData</code> 같은 props 변화는 자동적으로 하위 컴포넌트로 전달된다.</p>
<br />

<h3 id="useMemo-또한-복잡한-객체에-대해-같은-방식의-해결책을-제공한다"><a href="#useMemo-또한-복잡한-객체에-대해-같은-방식의-해결책을-제공한다" class="headerlink" title="useMemo 또한 복잡한 객체에 대해 같은 방식의 해결책을 제공한다."></a>useMemo 또한 복잡한 객체에 대해 같은 방식의 해결책을 제공한다.</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ColorPicker</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// color가 진짜로 바뀌지 않는 한</span></span><br><span class="line">  <span class="comment">// Child의 얕은 props 비교를 깨트리지 않는다</span></span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> style = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123; color &#125;), [color]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useCallback</code>은 꽤 좋은 돌파구이며 함수가 전달되어 자손 컴포넌트의 이펙트 안에서 호출되는 경우 유용하다. 아니면 자손 컴포넌트의 메모이제이션이 깨지지 않도록 방지할 때도 쓰인다. 하지만 훅 자체가 콜백을 내려보내는 것을 피하는 더 좋은 방법을 함께 제공한다.</p>
<hr>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>useEffect가 뭔지 정말 모르겠다!라고 생각했었는데 Dan Abramov님이 쓰신 useEffect 완벽 가이드 글을 정리하면서 effect가 어떤 방식으로 동작하는지 조금은 개념이 잡힌 것 같다. 뿐만 아니라 클래스형 컴포넌트와 함수형 컴포넌트의 차이에 대해서도 간략하게 알 수 있게 된 것 같아서 도움이 되었다. (공부하는데 2일이 걸렸다… 너무 힘들었다..!)</p>
<p>+) 마지막은 제일 좋아하는 박명수 짤로 마무리..</p>
<img src="https://i.pinimg.com/564x/a5/fb/e4/a5fbe4b47f843556d2eb5e3131bdc1cf.jpg" style="width: 512px;">

<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://overreacted.io/ko/a-complete-guide-to-useeffect/">https://overreacted.io/ko/a-complete-guide-to-useeffect/</a></p>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 8주차 주간회고 (부제: 진짜 회고)</title>
    <url>/2023/230409-1-archive/</url>
    <content><![CDATA[<p>section이 끝난 주에 주간회고를 쓰는건 언제나 당황스럽습니다.<br>지금 회고를 쓴다는 것은 코드스테이츠는 section이 4개로 나눠져있는데 벌써 section이 2개가 끝나버렸다는 이야기이기 때문이죠. 곧 있으면 경쟁 사회에 홀로 서 있을 제가 불안한겁니다.</p>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRjONFtjN_FhZ7VTiOp6RyPZd0hANVpw-PB2w&usqp=CAU" alt="alt"></p>
<p>그래도 section2에서 무엇을 배웠고 뭐가 아쉬웠는지 먼저 돌아보는게 먼저니까 한 번 돌아보겠습니다.</p>
<br />

<h3 id="section2-학습-목표를-달성했나요"><a href="#section2-학습-목표를-달성했나요" class="headerlink" title="section2 학습 목표를 달성했나요?"></a>section2 학습 목표를 달성했나요?</h3><p>이번 section2의 목표는 리액트로 클라이언트를 구현하고, Node.js, Express를 사용하여 서버를 구현한 후 각 클라이언트와 서버를 연결해 데이터를 주고 받는 Wep App을 만들어보는 것이었습니다.</p>
<p>사실 이전에 Express를 사용해서 서버를 구현해본 적이 있기 때문에 개념들을 이해하는데 큰 어려움은 없었습니다. 하지만 exress를 사용하지 않고 http 모듈로 서버를 구성하는 실습 과제에선 어려웠던 것 같습니다. 저는 새로운 개념을 마주쳤을 때 겁부터 먹어버리는 겁쟁이인 건 변함이 없나봅니다. ʕ ´•̥̥̥ ᴥ•̥̥̥&#96;ʔ</p>
<br />

<h3 id="공부하던-방식을-모두-바꿔보자"><a href="#공부하던-방식을-모두-바꿔보자" class="headerlink" title="공부하던 방식을 모두 바꿔보자!"></a>공부하던 방식을 모두 바꿔보자!</h3><p>최근에 프론트엔드 개발자 취준생들을 위한 웨비나를 들었는데, 그 중에서 기억에 남는 말이 있습니다. 바로 ‘뇌에 부하를 줘야한다’라는 말이었습니다. 그리고 교재나 강의를 그대로 옮겨적는 건 그냥 손가락 운동이기 때문에 공부가 하나도 안된다라는 말씀을 해주셨습니다.</p>
<p>근데 이거 나한테 애기해주시는 건가..?라는 생각이 들었던 게 저는 항상 다른 공식문서나 교재들을 보고 그대로 옮겨 적거나, 강의를 그대로 적는 의미없는 활동만 계속해서 해왔었습니다.</p>
<p>물론 패러프레이징, 즉 나만의 언어로 작성하면서 성장한다는 것은 머리로는 알고 있지만 알고 있는 지식들이 많지 않기 때문에 다른 글들을 찾아보면서 어느샌가 나도 모르게 글을 그대로 적고 있는 경우들이 많았습니다.</p>
<p>내가 해왔던 모든 활동들이 가치 없는 것들이라는 이야기를 들으니 되게 아프면서도, 지금이라도 빨리 올바른 습관을 들이자라는 마음이 들었습니다!</p>
<img src="https://jjalbang.today/jjv3rQ.jpg" style="width:512px; height:auto">

<br />

<p><strong>✅ 떠오르는 인사이트들을 적어보기</strong></p>
<p>교재나 보거나 강의를 들었을 때 생각나는 인사이트들이 있다면 바로 적어놓으려고 합니다. 나의 상황에서는 어떻게 대입하면 좋을지 혹은 ‘나는 이렇게 생각해왔었는데 여기서는 이렇게 얘기를 하네?’라는 식으로요.</p>
<p><strong>✅ 깊은 개념보단 우선 간단한 구현부터 시작해보기</strong></p>
<p>사실 이 부분은 매번 고민하고 있습니다. 깊은 개념까지 알아놓는 것이 좋을까? 아니면 개념은 나중에, 우선 실습이 먼저와 같은 고민들이요.</p>
<p>저 같은 경우는 하나의 개념을 깊게 봐야 그 기술에 대한 이해도가 높아진다 생각해서 구현보단 이론에 중점을 두고 공부를 했었습니다. 하지만 매번 교재를 그대로 적어가면서 공부를 했었기 때문에 시간만 소비하고 성장도 하지못하는 결과를 초래해버렸습니다.이제부터는 간단한 코드라도 내 머릿속에서 생각해서 만들어보기 위한 노력을 해보려고합니다.</p>
<p>습관을 만드는 건 어렵겠지만 꾸준히 한다면 할 수 있겠죠? 지금이라도 고칠 수 있어서 다행인 것 같습니다. section3때는 더 열심히 해볼 생각입니다. 중요한건 꺾여도 계속 하는 마음이니까요!</p>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>메가테라 프론트엔드 생존코스 5주차 주간회고</title>
    <url>/2023/230409-archive/</url>
    <content><![CDATA[<p>🐛 <strong>이번 주 요약</strong>: 테스트 코드 실패의 연속<br><img src="https://jjalbang.today/jjv2J6.jpg" style="width:512px; height:auto"></p>
<br />

<h2 id="Fact"><a href="#Fact" class="headerlink" title="Fact"></a>Fact</h2><ul>
<li>TDD에 관한 개념을 배웠고 실제로 테스트 코드를 작성해볼 수 있는 시간이었다.</li>
<li>테스트를 위한 도구 사용방법을 배웠다.</li>
<li>4주차에 만들었던 푸드코트 키오스크에 Unit 테스트와 E2E 테스트를 작성하는 과제를 진행했다.</li>
</ul>
<h2 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h2><ul>
<li>지난 주에 과제를 하다가 이해하지 못한 개념들이 있었는데, 5주차 과제에서 한 번 더 작성해보면서 코드에 익숙해진 것 같다.</li>
<li>5주차의 학습 목표 첫 문장에 ‘처음부터 TDD를 제대로 습득하는 건 대단히 어렵습니다.’라고 되어있었는데 그걸 느낀 사람? 바로 나.. 대단한 어려움에 부딪혔다! 반복 학습만이 해결해줄 수 있을 것 같은데 짧은 시간 안에 해결하기는 어려워보인다.</li>
<li>이번 주 TDD를 배우면서 ‘하나의 컴포넌트를 테스트하기 위해서 해야하는 것들이 정말 많다’라고 느꼈다. 배보다 배꼽이 커진 것 같은 느낌이랄까…? 컴포넌트 구현 자체도 어렵다고 느껴지니 이런 생각이 드는 것 같다.</li>
<li>어찌 저찌 코드를 만들어서 테스트를 돌리면 계속해서 실패할 때의 좌절감… 굉장히 정신적으로 피폐해지는 것 같았다. 해설 코드를 보지 않고 어떻게든 통과해보려고했지만 실패해서 결국은 해설 코드를 확인하고 제출했다.</li>
</ul>
<h2 id="Finding"><a href="#Finding" class="headerlink" title="Finding"></a>Finding</h2><ul>
<li>axios로 데이터를 받아오는 과정에서 AxiosError를 마주쳤는데, 그 이유에 대해서 아직 찾지 못했다. 데이터를 정상적으로 받아온 후에 에러가 발생하는데 이럴 땐 어떻게 구글링을 해야할지 모르겠다.🤔</li>
<li>매주 새로운 개념들을 받아들이는게 쉽지 않다. 반복 학습만이 답이라는 것 잊지 말자!</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>Megaptera</tag>
      </tags>
  </entry>
  <entry>
    <title>재귀를 공부해보았읍니다.</title>
    <url>/2023/230411-archive/</url>
    <content><![CDATA[<p>오늘은 재귀함수를 공부했습니다. 재귀함수가 나올 떄마다 이해가 안가서 재귀를 사용하면 코드 가독성이 떨어진다는 합리화를 하며 요리조리 피해다녔는데 오늘 정면으로 승부를 볼 수 있는 시간이었습니다.</p>
<img src="https://jjalbang.today/jjv2Qx.jpg" style="width:512px; height:auto">

<br />

<h2 id="재귀함수란"><a href="#재귀함수란" class="headerlink" title="재귀함수란?"></a>재귀함수란?</h2><p>재귀라는 의미는 자기 자신으로 되돌아 간다는 의미인데요, 자바스크립트에서 말하는 재귀는 자기 자신을 호출하는 것입니다. 그러니까 함수 내부 안에서 자신의 함수를 호출하는 것이지요.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recursive</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">recursive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉🏻 이렇게 정의한 함수를 함수 내부 안에서 호출하면 <code>hello world</code>를 무한으로 출력시킬 수 있습니다.</p>
<br />

<h2 id="재귀함수-언제-사용해야하는데"><a href="#재귀함수-언제-사용해야하는데" class="headerlink" title="재귀함수, 언제 사용해야하는데?"></a>재귀함수, 언제 사용해야하는데?</h2><ul>
<li>반복문을 사용할 때 호출 횟수가 명확하지 않을 때</li>
<li>중첩된 반복문이 많을 때</li>
</ul>
<p>이런 경우일 때 주로 재귀함수를 사용합니다.</p>
<br />

<h2 id="재귀함수-활용방법에-대해서-알려드리자면"><a href="#재귀함수-활용방법에-대해서-알려드리자면" class="headerlink" title="재귀함수 활용방법에 대해서 알려드리자면,"></a>재귀함수 활용방법에 대해서 알려드리자면,</h2><p>우선 base case와 recursive case를 나눠서 생각해야합니다.</p>
<p>base case는 종료조건을 의미하고 recursive case는 반복으로 재귀함수를 호출해야하는 조건을 의미합니다. base case가 없으면 함수가 무한으로 호출되기 때문에 콜스택에 계속해서 함수가 쌓이는 현상을 경험할 수 있답니다.</p>
<p><strong>🐛 일반적 재귀함수 템플릿</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recursive</span>(<span class="params">input1, input2, ...</span>) &#123;</span><br><span class="line">  <span class="comment">// 탈출 조건</span></span><br><span class="line">  <span class="keyword">if</span>(재귀함수를 종료해야하는 경우)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">recursive</span>(); <span class="comment">// 재귀조건</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<h2 id="재귀-문제를-풀어봅시다"><a href="#재귀-문제를-풀어봅시다" class="headerlink" title="재귀 문제를 풀어봅시다."></a>재귀 문제를 풀어봅시다.</h2><p>오늘 풀어 본 문제 중에서 푸는데 시간이 오래 걸렸던 문제들을 다시 풀면서 정리해봅시다.</p>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>수(num)와 배열을 입력받아 차례대로 num개의 요소만 포함된 새로운 배열을 리턴</p>
<p>입출력 예시</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> output = <span class="title function_">take</span>(<span class="number">2</span>, [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output); <span class="comment">// --&gt; [1, -2]</span></span><br><span class="line"></span><br><span class="line">output = <span class="title function_">take</span>(<span class="number">5</span>, [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output); <span class="comment">// --&gt; [1, -2, 1, 3]</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 문제 이해하기</strong></p>
<ul>
<li><p>num개의 요소를 가진 배열을 리턴해라!</p>
</li>
<li><p>recursive case</p>
<ul>
<li>배열의 length와 num이 다를 때 👉🏻 맨 뒤 요소를 제외한 배열을 만들어서 재귀 함수에 전달 후 호출</li>
</ul>
</li>
<li><p>base case</p>
<ul>
<li>배열의 length와 num이 같을 때</li>
<li>num이 배열의 길이보다 크다면 바로 배열 값 그대로 리턴하고 종료</li>
</ul>
</li>
</ul>
<br />

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">take</span>(<span class="params">num, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &gt;= arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">take</span>(num, arr.<span class="title function_">slice</span>(<span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이게 간단한 코드인 것 같지만 왜 오래 걸렸냐면… 처음엔 num개의 요소를 뺀 배열을 리턴하라는 문제인 줄 알고 열심히 풀었지만, 계속해서 테스트 케이스를 통과하지 못하는 것을 보고 제가 잘못 풀고 있다는 것을 그제서야 깨달았습니다.</p>
<h3 id="unpackGiftbox"><a href="#unpackGiftbox" class="headerlink" title="unpackGiftbox"></a>unpackGiftbox</h3><p>선물 상자에 대한 정보를 담은 배열과 문자열을 입력받아 조건에 맞는 선물이 있는지 여부를 리턴</p>
<p>입출력 예시</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> giftBox = [<span class="string">&#x27;macbook&#x27;</span>, <span class="string">&#x27;mugcup&#x27;</span>, [<span class="string">&#x27;eyephone&#x27;</span>, <span class="string">&#x27;postcard&#x27;</span>], <span class="string">&#x27;money&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = <span class="title function_">unpackGiftbox</span>(giftBox, <span class="string">&#x27;iphone&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output); <span class="comment">// --&gt; false</span></span><br><span class="line"></span><br><span class="line">output = <span class="title function_">unpackGiftbox</span>(giftBox, <span class="string">&#x27;postcard&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output); <span class="comment">// --&gt; true</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 문제 이해하기</strong></p>
<ul>
<li>배열 안에 있는 요소들을 탐색하면서 wish로 받은 값이 있는지 확인 후 boolean 값으로 리턴하자!</li>
<li>현재 배열 안에 배열이 많은데? 👉🏻 flat 메서드로 배열을 평탄화 시키고 작업하자.</li>
<li>recursive case</li>
<li>base case<ul>
<li>wish와 동일한 값이 있을 떄 true 리턴</li>
<li>giftBox.length가 0일 때 false 리턴</li>
</ul>
</li>
</ul>
<br />

<p>처음에 작성한 코드</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unpackGiftbox</span>(<span class="params">giftBox, wish</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (giftBox.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩된 배열이 많으니 배열을 평탄화 시켜놓고 작업</span></span><br><span class="line">  <span class="keyword">const</span> newGiftBox = giftBox.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">  <span class="keyword">if</span> (newGiftBox[<span class="number">0</span>] === wish) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">unpackGiftbox</span>(newGiftBox.<span class="title function_">slice</span>(<span class="number">1</span>), wish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>배열 안에 배열이 너무 많기 때문에 배열을 먼저 평탄화 시키고 작업해야겠다!라는 생각이 먼저 들었고 배열의 첫 번째 요소값과 wish를 비교해서 같은지 확인작업을 진행했습니다. 만약 첫 번째 요소와 wish의 값이 다르다면 0번째 요소를 제외한 배열을 재귀 함수의 인수로 전달하고 후출하는 방식으로요.</p>
<br />

<p>이 코드를 실행시켜보면 1개의 테스트 코드를 실패한 것을 볼 수 있습니다.</p>
<p><img src="/../img/230411/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%204.png" alt="."><br><img src="/../img/230411/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%205.png" alt="alt"><br><img src="/../img/230411/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%206.png" alt="alt"></p>
<p>재귀 호출 횟수가 최대 4번까지인 것 같은데 제 코드에서는 현재 7번의 재귀 호출이 일어나고 있습니다.</p>
<p>호출 횟수를 줄이려면 어떻게 하는게 좋을까..🤔 생각을 해보다가 <code>배열의 1depth는 for문으로 순회하면 되겠다!</code>라는 생각이 들었습니다.</p>
<img src="https://jjalbang.today/jjv2lQ.jpg" style="width:512px; height:auto">

<p>이만큼 생각한 내 자신? 대단해</p>
<br />

<p><strong>정리를 해보자면</strong></p>
<p>우선 for문으로 배열을 순회한다.<br>➡️ i번째 요소가 wish와 같은 지 확인한다.<br>➡️ 만약 i번째 요소가 배열이라면, i번째 요소를 인수로 전달하고 재귀함수를 호출한다.</p>
<p>이 순서대로 간다면 재귀 호출 횟수를 줄일 수 있을 것 같습니다.</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unpackGiftbox</span>(<span class="params">giftBox, width</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; giftBox.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (giftBox[i] === wish) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ✅ i번째 요소가 Array인지 확인하기</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(giftBox[i])) &#123;</span><br><span class="line">      <span class="comment">// 재귀 호출했을 떄 그 함수의 값이 true라면 true 리턴하기</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">unpackGiftbox</span>(giftBox[i], wish)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>테스트 통과😎</p>
<br />

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>재귀 함수를 썼던 경험이 많이 없다보니, 경우의 수를 생각하는데 시간이 오래 걸렸던 것 같습니다. 혼자서 공부했다면 계속해서 피해다녔을 것 같은데 오늘 수업 덕분에 정면승부할 수 있었던 것 같습니다.</p>
<p>그런데 실무에서는 재귀를 어떻게 쓸까요? 정말 혹시라도 실무자분들이나 재귀를 프로젝트에 사용해보신적이 있다면 답변을 남겨주셨으면 좋겠습니다.👏🏻</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>리액트의 LifeCycle과 LifeCycle Method</title>
    <url>/2023/230414-archive/</url>
    <content><![CDATA[<p>리액트의 생명주기와 생명주기 메서드에 대해서 공부해보겠습니다. 생명주기 메서드에 대해서 제대로 살펴보는건 처음인 것 같습니다. 매번 도망다니기 바빴는데 말이죠.</p>
<p><img src="/../img/230414/IMG_9412.jpg" alt="."></p>
<h3 id="리액트-컴포넌트는-생명주기-Life-Cycle-가-있다"><a href="#리액트-컴포넌트는-생명주기-Life-Cycle-가-있다" class="headerlink" title="리액트 컴포넌트는 생명주기(Life Cycle)가 있다."></a>리액트 컴포넌트는 생명주기(Life Cycle)가 있다.</h3><p>리액트의 각 컴포넌트들은 <strong>라이프사이클 즉, 생명주기</strong>를 가지고 있습니다. 생명주기는 컴포넌트 생성부터 시작해서 업데이트가 되기도 하고 마지막엔 소멸되는 과정을 거치게 됩니다.</p>
<br />

<h3 id="변화하는-과정을-캐치해서-작업을-하고싶다"><a href="#변화하는-과정을-캐치해서-작업을-하고싶다" class="headerlink" title="변화하는 과정을 캐치해서 작업을 하고싶다."></a>변화하는 과정을 캐치해서 작업을 하고싶다.</h3><p>컴포넌트를 처음 렌더링하는 시점에 어떠한 작업을 처리해야하거나, 컴포넌트를 업데이트하기 전 후로 어떤 작업을 처리해야 할 수도 있습니다. 혹은 불필요한 업데이트를 방지해야 할 수도 있죠.</p>
<p>이 과정에서 특정한 이벤트들이 발생하는데 이것을 <strong>생명주기 메서드(LifeCycle Method)</strong> 라고 합니다.</p>
<p>모든 컴포넌트는 여러 종류의 “생명주기 메서드”를 가지며, 이 메서드를 오버라이딩하여 특정 시점에 코드가 실행되도록 설정할 수 있습니다.</p>
<br />
생명주기는 어떻게 생겼냐구요? 이렇게 생겼습니다.

<p><img src="/../img/230414/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%201.png" alt="스크린샷 1.png"></p>
<p>상대적으로 자주 사용되지 않는 메서드들까지 합치면 총 9가지입니다.</p>
<p><img src="/../img/230414/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B72.png" alt="스크린샷.png"><br><em>출처: <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></em></p>
<h3 id="생명주기는-총-3가지-카테고리로-나뉜다"><a href="#생명주기는-총-3가지-카테고리로-나뉜다" class="headerlink" title="생명주기는 총 3가지 카테고리로 나뉜다."></a>생명주기는 총 3가지 카테고리로 나뉜다.</h3><p>생명주기는 생성될 때(Mount), 업데이트 할 때(Update), 제거할 때(Unmount) 카테고리로 나눕니다.</p>
<p>🤔 <strong>그렇다면 마운트 되었다는 것은 무엇을 의미할까요?</strong></p>
<p>DOM이 생성되고 나서 웹 브라우저에 나타나는 것을 마운트라고 합니다. 즉, 컴포넌트의 인스턴스가 생성되어 DOM 상에 삽입될 때를 의미합니다.</p>
<p><strong>🤔 업데이트 되었다는 것은?</strong></p>
<ul>
<li>props가 바뀔 때</li>
<li>state가 바뀔 때</li>
<li>부모 컴포넌트가 리렌더링될 때</li>
<li>this.forceUpdate로 강제로 렌더링 트리거할 때</li>
</ul>
<p>이러한 경우를 의미합니다.</p>
<p><strong>🤔 마지막으로 언마운트 되었다는 것은?</strong></p>
<p>마운트의 반대 과정으로 컴포넌트가 DOM에서 제거될 때를 언마운트라고 합니다.</p>
<br />

<p>자 이제 생명주기 메서드에 대해서 하나씩 살펴봅시다.</p>
<img src="https://pbs.twimg.com/media/DgNb9OZUEAAmONL?format=jpg&name=small" style="width:512px; height:auto">

<br />

<h3 id="생명주기-메서드-종류는-총-9가지다"><a href="#생명주기-메서드-종류는-총-9가지다" class="headerlink" title="생명주기 메서드 종류는 총 9가지다."></a>생명주기 메서드 종류는 총 9가지다.</h3><p>constructor, getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidMount, componentDidUpdate, componentWillUnmount, componentDidCatch</p>
<p>메서드 이름만 봐선 뭐하는 놈들인지 이해가 안가므로.. 접두사로 구분을 해보자면,</p>
<ul>
<li>Will 접두사가 붙은 메서드는 👉🏻 <strong>작동하기 전</strong>에 특정 작업을 실행</li>
<li>Did 접두사가 붙은 메서드는 👉🏻 <strong>작동한 후</strong>에 작업을 실행</li>
</ul>
<p>우선 이렇게만 알아두고 넘어갑시다.</p>
<br />

<h3 id="마운트될-때-발생하는-생명주기-메서드"><a href="#마운트될-때-발생하는-생명주기-메서드" class="headerlink" title="마운트될 때 발생하는 생명주기 메서드"></a>마운트될 때 발생하는 생명주기 메서드</h3><ul>
<li>constructor</li>
<li>getDerivedStateFromProps</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<p><strong>constructor</strong></p>
<p>: <code>constructor</code>는 컴포넌트의 생성자 메서드로, 컴포넌트가 만들어지면 가장 먼저 실행되는 메서드입니다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">	<span class="variable language_">super</span>(props);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>state를 초기화하는 작업이 없다면 constructor를 구현하지 않아도 됩니다.</p>
<p>constructor를 사용하는 이유는 무엇일까요?</p>
<ol>
<li>this.state에 객체를 할당하여 지역 state를 초기화</li>
<li>인스턴스에 이벤트 처리 메서드 바인딩</li>
</ol>
<p>보통 이 두가지 목적을 위하여 사용합니다.</p>
<p><span style="background-color: rgba(153, 219, 218, 0.3)"><em>🚧 중요한 건 constructor 내부에서 setState를 호출하면 안됩니다.</em></span></p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="comment">// 🚧 여기서 this.setState()를 호출하면 안됨</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>constructor는 this.state를 직접 할당할 수 있는 유일한 곳이기 때문이죠.</p>
<p><strong>getDerivedStateFromProps</strong></p>
<p>: props로 넘어온 것을 state로 만들고 싶을 때 사용합니다.</p>
<ul>
<li>만약 state가 갱신되었다면 변경된 객체를 반환</li>
<li>변경된 state가 없다면 null을 반환</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getDerivedStateFromProps&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (nextProps.<span class="property">color</span> !== prevState.<span class="property">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">color</span>: nextProps.<span class="property">color</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다른 메서드와 달리 <code>static</code> 을 필요로 하고, 이 메서드 안에서는 this를 조회할 수 없습니다. (static이니까요!) <code>getDerivedStateFromProps</code> 메서드는 마운트될 때와 업데이트될 때 render 메서드 이전에 매번 호출됩니다.</p>
<p><strong>render</strong></p>
<p>: 컴포넌트를 렌더링하는 메서드로 <strong>반드시 구현되어야 하는 유일한 메서드</strong>입니다.</p>
<p><strong>componentDidMount</strong></p>
<p>: 컴포넌트 첫 번째 렌더링을 마치고 나면 호출되는 메서드입니다.</p>
<p>이 메서드가 호출되는 시점에는 우리가 만든 컴포넌트가 화면에 나타난 상태입니다. 이 단계에서는 axios, fetch 등을 사용해 외부에서 데이터를 불러오는 작업을 합니다.</p>
<br />

<h3 id="업데이트될-때-발생하는-생명주기"><a href="#업데이트될-때-발생하는-생명주기" class="headerlink" title="업데이트될 때 발생하는 생명주기"></a>업데이트될 때 발생하는 생명주기</h3><ul>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>render</li>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidUpdate</li>
</ul>
<p><strong>getDerivedStateFromProps</strong></p>
<p>: 마운트 될 때 발생했던 메서드로, 컴포넌트의 props와 state가 변경되었을 때도 이 메서드가 호출됩니다.</p>
<p><strong>shouldComponentUpdate</strong></p>
<p>: 컴포넌트가 리렌더링 할지 말지를 결정하는 메서드입니다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;shouldComponentUpdate&quot;</span>, nextProps, nextState);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 숫자의 마지막 자리가 4면 리렌더링하지 않는다.</span></span><br><span class="line">	<span class="keyword">return</span> nextState.<span class="property">number</span> % <span class="number">10</span> !== <span class="number">4</span> <span class="comment">// 🐛 false를 반환하면 작업을 중지(리렌더링 방지)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>주로 최적화할 때 사용하는 메서드입니다. 👉🏻 React.memo의 역할과 비슷합니다.</p>
<p><strong>render</strong></p>
<p>: 생략!</p>
<p><strong>getSnapshotBeforeUpdate</strong></p>
<p>: 컴포넌트에 변화가 일어나기 직전의 DOM 상태를 가져와서 <span style="color:red; font-weight:700;">특정 값을 반환</span>하면 그 다음에 발생하게 되는 componentDidUpdate 함수에서 받아와서 사용할 수 있습니다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getSnapshotBeforeUpdate&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (prevProps.<span class="property">color</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">color</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">style</span>.<span class="property">color</span>; <span class="comment">// 특정 값 반환</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 특정 값 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>componentDidUpdate</strong></p>
<p>: 리렌더링을 마치고 화면에 우리가 원하는 변화가 모두 반영되고 난 뒤 호출되는 메서드입니다.</p>
<p><span style="color:red; font-weight:700;">3번째 파라미터로 getSnapshotBeforeUpdate에서 반환한 값</span> 을 조회할 수 있습니다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;componentDidUpdate&quot;</span>, prevProps, prevState);</span><br><span class="line">    <span class="keyword">if</span> (snapshot) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;업데이트 되기 직전 색상: &quot;</span>, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<br />

<p>아니 그래서.. <code>getSnapshotBeforeUpdate</code> 을 언제 어떻게 사용한다는 걸까요..?</p>
<p><a href="https://codesandbox.io/s/getsnapshotbeforeupdate-yeje-vpmle?fontsize=14">실제 사용사례</a>를 한 번 보고 넘어갑시다.</p>
<p>Chrome에서는 이미 자체적으로 구현되어있는 기능인데요, 새로운 내용이 추가되었을 때 사용자의 스크롤 위치를 유지시키는 기능입니다.<br>하지만 Safari 브라우저를 포함한 일부 브라우저는 이 기능이 구현되어 있지 않아서 아래와 같이 작동하게 됩니다.</p>
<p><img src="https://i.imgur.com/1POUOrQ.gif" alt="https://i.imgur.com/1POUOrQ.gif"></p>
<p>내용이 추가된다 해도 제가 있던 위치 2에서 머물러야 할 때 <code>getSnapshotBeforeUpdate</code>를 활용하면 유지를 할 수 있게 됩니다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./ScrollBox.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScrollBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">array</span>: [<span class="number">1</span>],</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleInsert = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">array</span>: [<span class="variable language_">this</span>.<span class="property">id</span>++, ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">array</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// DOM 업데이트가 일어나기 직전의 시점입니다.</span></span><br><span class="line">    <span class="comment">// 새 데이터가 상단에 추가되어도 스크롤바를 유지해보겠습니다.</span></span><br><span class="line">    <span class="comment">// scrollHeight 는 전 후를 비교해서 스크롤 위치를 설정하기 위함이고,</span></span><br><span class="line">    <span class="comment">// scrollTop 은, 이 기능이 크롬에 이미 구현이 되어있는데,</span></span><br><span class="line">    <span class="comment">// 이미 구현이 되어있다면 처리하지 않도록 하기 위함입니다.</span></span><br><span class="line">    <span class="keyword">if</span> (prevState.<span class="property">array</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">array</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; scrollTop, scrollHeight &#125; = <span class="variable language_">this</span>.<span class="property">list</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 여기서 반환 하는 값은 componentDidMount 에서 snapshot 값으로 받아올 수 있습니다.</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        scrollTop,</span><br><span class="line">        scrollHeight,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(prevProps, prevState, snapshot);</span><br><span class="line">    <span class="keyword">if</span> (snapshot) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; scrollTop &#125; = <span class="variable language_">this</span>.<span class="property">list</span>;</span><br><span class="line">      <span class="keyword">if</span> (scrollTop !== snapshot.<span class="property">scrollTop</span>) <span class="keyword">return</span>; <span class="comment">// 기능이 이미 구현되어있다면 처리하지 않습니다.</span></span><br><span class="line">      <span class="keyword">const</span> diff = <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">scrollHeight</span> - snapshot.<span class="property">scrollHeight</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">list</span>.<span class="property">scrollTop</span> += diff;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> rows = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">array</span>.<span class="title function_">map</span>(<span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;row&quot;</span> <span class="attr">key</span>=<span class="string">&#123;number&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;number&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;(ref)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">            this.list = ref;</span></span><br><span class="line"><span class="language-xml">          &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          className=&quot;list&quot;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">          &#123;rows&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleInsert&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ScrollBox</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/gS01iZ9.gif" alt="https://i.imgur.com/gS01iZ9.gif"></p>
<p><code>getSnapshotBeforeUpdate</code> 는 사실 사용되는 일이 그렇게 많지 않습니다. 그냥 이런게 있다.. 정도만 알아두시면 충분합니다.</p>
<p><span style="background-color: rgba(153, 219, 218, 0.3)"><em>🚧 DOM 에 변화가 반영되기 직전에 DOM의 속성을 확인하고 싶을 때 이 생명주기 메서드를 사용하면 된다는 것을 알아두세요.</em></span></p>
<br />

<h3 id="언마운트될-때-발생하는-메서드"><a href="#언마운트될-때-발생하는-메서드" class="headerlink" title="언마운트될 때 발생하는 메서드"></a>언마운트될 때 발생하는 메서드</h3><p>언마운트에 관련된 생명주기 메서드는 <code>componentWillUnmount</code> 하나입니다.</p>
<p><strong>componentWillUnmount</strong></p>
<p>: 컴포넌트가 화면에서 사라지기 직전에 호출됩니다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;componentWillUnmount&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>여기서는 주로 DOM에 직접 등록했었던 이벤트를 제거하고, 만약에 <code>setTimeout</code><br> 을 걸은것이 있다면 <code>clearTimeout</code> 을 통하여 제거를 합니다.</p>
<p>마지막으로!</p>
<p><strong>componentDidCatch</strong></p>
<p>: 렌더링 도중에 에러가 발생했을 때 애플리케이션이 먹통되지 않고 오류 UI를 보여줄 수 있도록 만들 수 있습니다.</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">error</span>: <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// .. 에러시 보여줄 작업</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>error</code> 파라미터 : 어떤 에러가 발생했는지에 대한 정보</li>
<li><code>info</code> 파라미터 : 어디에 있는 코드에서 오류가 발생했는지에 대한 정보</li>
</ul>
<p>이 메서드를 사용할 때는 컴포넌트 자신에게 발생하는 에러를 잡아낼 수 없고, 자신의 this.prop.children으로 전달되는 컴포넌트에서 발생하는 에러만 잡아낼 수 있습니다.</p>
<br />

<h3 id="하나의-예제를-가져와보았읍니다"><a href="#하나의-예제를-가져와보았읍니다" class="headerlink" title="하나의 예제를 가져와보았읍니다."></a>하나의 예제를 가져와보았읍니다.</h3><p><img src="/../img/230414/ezgif.com-crop.gif" alt="ezgif.com-crop.gif"></p>
<ul>
<li><code>&quot;색상 랜덤으로 변경시켜버리기&quot;</code> 버튼을 누르면 숫자의 색상이 변경된다.</li>
<li><code>&quot;토글버튼으로 나타났다 사라졌다&quot;</code> 버튼을 누르면 컴포넌트가 사라지거나 나타난다.</li>
<li><code>&quot;숫자 증가&quot;</code> 버튼을 누르면 숫자가 1씩 더해진다.</li>
</ul>
<p>먼저 기능 구현해보기</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./styles.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 랜덤 색상 만드는 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">16777215</span>).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;#000000&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [toggle, setToggle] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleRandomColor</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setColor</span>(<span class="title function_">getRandomColor</span>());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>코드를 구현해보자ㅏㅏㅏㅏ<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;handleRandomColor&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        색상 랜덤으로 변경시켜버리기</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setToggle((toggle) =&gt; !toggle)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        토글버튼으로 나타났다 사라졌다</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;toggle &amp;&amp; <span class="tag">&lt;<span class="name">Sample</span> <span class="attr">color</span>=<span class="string">&#123;color&#125;</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;</span> <span class="attr">setCount</span>=<span class="string">&#123;setCount&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Sample</span>(<span class="params">&#123; color &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount((count) =&gt; count + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        숫자 증가!!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>저는 먼저 setState 훅을 사용해 구현을 해보았습니다.</p>
<br />

<h3 id="이제-클래스형-컴포넌트로-구현하면…"><a href="#이제-클래스형-컴포넌트로-구현하면…" class="headerlink" title="이제 클래스형 컴포넌트로 구현하면…"></a>이제 클래스형 컴포넌트로 구현하면…</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">LifeCycleSample</span> <span class="keyword">from</span> <span class="string">&#x27;./LifeCycleSample&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 랜덤 색상을 생성합니다</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRandomColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">16777215</span>).<span class="title function_">toString</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;#000000&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [visible, setVisible] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setColor</span>(<span class="title function_">getRandomColor</span>());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onToggle</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setVisible</span>(!visible);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>랜덤 색상<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onToggle&#125;</span>&gt;</span>토글<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;visible &amp;&amp; <span class="tag">&lt;<span class="name">LifeCycleSample</span> <span class="attr">color</span>=<span class="string">&#123;color&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, rootElement);</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifeCycleSample</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">number</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  myRef = <span class="literal">null</span>; <span class="comment">// ref 를 설정 할 부분</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;constructor&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// 상태가 변경되면 변경된 객체를 반환하는 메서드</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getDerivedStateFromProps&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nextProps.<span class="property">color</span> !== prevState.<span class="property">color</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">color</span>: nextProps.<span class="property">color</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 마운트되고 화면에 표시된 이후에 실행</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentDidMount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="comment">// 리렌더링 여부를 결정하는 메서드</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;shouldComponentUpdate&#x27;</span>, nextProps, nextState);</span><br><span class="line">    <span class="comment">// 숫자의 마지막 자리가 4면 리렌더링하지 않습니다</span></span><br><span class="line">    <span class="keyword">return</span> nextState.<span class="property">number</span> % <span class="number">10</span> !== <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentWillUnmount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">number</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// 변화가 일어나기 직전의 DOM 상태를 가져와서 특정 값 반환</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getSnapshotBeforeUpdate&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (prevProps.<span class="property">color</span> !== <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">color</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">style</span>.<span class="property">color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentDidUpdate&#x27;</span>, prevProps, prevState);</span><br><span class="line">    <span class="keyword">if</span> (snapshot) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;업데이트 되기 직전 색상: &#x27;</span>, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> style = &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">color</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;(ref)</span> =&gt;</span> (this.myRef = ref)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          &#123;this.state.number&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>color: &#123;this.state.color&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>더하기<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">LifeCycleSample</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://codesandbox.io/s/currying-bash-mrkjb?fontsize=14&file=/src/LifeCycleSample.js:0-1675">currying-bash-mrkjb - CodeSandbox</a></p>
<br />

<p><img src="/../img/230414/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7.png" alt="."><br>어라…?<br><img src="https://pbs.twimg.com/media/DgNb9OZUEAAmONL?format=jpg&name=small" style="width:512px; height:auto"></p>
<p>그럼 클래스형 컴포넌트가 아닌 함수형 컴포넌트에서는 어떻게 생명주기를 파악할 수 있을까요?</p>
<h3 id="클래스형-컴포넌트와-함수형-컴포넌트의-비교"><a href="#클래스형-컴포넌트와-함수형-컴포넌트의-비교" class="headerlink" title="클래스형 컴포넌트와 함수형 컴포넌트의 비교"></a>클래스형 컴포넌트와 함수형 컴포넌트의 비교</h3><table>
<thead>
<tr>
<th>분류</th>
<th>클래스형 컴포넌트</th>
<th>함수형 컴포넌트</th>
</tr>
</thead>
<tbody><tr>
<td>Mounting</td>
<td>constructor()</td>
<td>함수형 컴포넌트 내부</td>
</tr>
<tr>
<td>Mounting</td>
<td>render()</td>
<td>return()</td>
</tr>
<tr>
<td>Mounting</td>
<td>ComponenDidMount()</td>
<td>useEffect()</td>
</tr>
<tr>
<td>Updating</td>
<td>componentDidUpdate()</td>
<td>useEffect()</td>
</tr>
<tr>
<td>UnMounting</td>
<td>componentWillUnmount()</td>
<td>useEffect()</td>
</tr>
</tbody></table>
<br />

<blockquote>
<p>결론은 클래스형 컴포넌트 라이프사이클 메서드는 이런 것들이 있구나 정도로만 알고 넘어가고, useEffect에 대해서 자세히 알아두면 좋을 것 같다!</p>
</blockquote>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.zerocho.com/category/React/post/579b5ec26958781500ed9955">React의 생명 주기(Life Cycle)</a></li>
<li><a href="https://react.vlpt.us/basic/25-lifecycle.html">LifeCycle Method</a></li>
<li><a href="https://ko.reactjs.org/docs/react-component.html">React.Component</a></li>
</ul>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>코드스테이츠 프론트엔드 9주차 주간회고</title>
    <url>/2023/230414-1archive/</url>
    <content><![CDATA[<p>돌아온 금요일 9주차 주간회고를 시작하겠습니다.</p>
<br />
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>메가테라 프론트엔드 생존코스 6주차 주간회고</title>
    <url>/2023/230416-archive/</url>
    <content><![CDATA[<h3 id="🐛-이번-주-요약-눈으로만-봐선-이해할-수가-없다"><a href="#🐛-이번-주-요약-눈으로만-봐선-이해할-수가-없다" class="headerlink" title="🐛 이번 주 요약: 눈으로만 봐선 이해할 수가 없다!"></a>🐛 이번 주 요약: 눈으로만 봐선 이해할 수가 없다!</h3><p><img src="/../img/230416/kakaotalk1.jpeg" alt="."></p>
<br />

<h2 id="Fact"><a href="#Fact" class="headerlink" title="Fact"></a>Fact</h2><ul>
<li>‘관심사의 분리’라는 개념에 대해 공부하고 왜 관심사의 분리를 해야하는지에 대해 공부했습니다.</li>
<li>Layered Architecture, Flux Architecture에 대해서 공부했습니다.</li>
<li>External Store를 통해서 상태를 전역으로 관리할 수 있는 방법에 대해서 공부했습니다.</li>
<li>전역 상태를 만드는 방법으로 TSryinge, usestore-ts에 대해서 공부했습니다.</li>
</ul>
<h2 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h2><ul>
<li>월요일에 홀맨님이 라이브로 조언을 해주시는 시간이 있었는데, 그게 동기부여가 된 것 같습니다. 뇌에 부하를 줘야한다는 말이 충격적으로 다가왔던 지라 제가 여태 공부를 어떤 방식으로 해왔는지 다시 되돌아 볼 수 있는 시간이어서 정말 도움이 많이 되었던 것 같습니다.</li>
<li>Redux를 만들어보는 강의를 듣는데 Redux가 어떻게 생긴건지, Redux가 어떤 방식으로 동작하는지에 대한 개념이 전혀 없어서 강의를 들어도 이해하기가 어려웠습니다. Redux의 기본 개념에 대해서 공부를 해야하다보니 시간이 오래 걸렸던 것 같습니다.</li>
<li>Action, Dispatch, Reducer와 같은 단어의 개념이 뭔지 모르고 코드를 따라치고 있었던 시간이 조금 아깝게 느껴졌습니다. ʕ ´•̥ ᴥ•̥&#96;ʔ</li>
<li>데브노트에 강의 내용 정리를 하지 않고 공부한 내용들을 적으려니 생각보다 막막한 것 같습니다. 강의를 들을 땐 강의 속도가 빨라서 코드 흐름 자체를 이해하는 것만으로도 벅찹니다..</li>
<li>1주차 강의부터 다시 살펴봐야할 때가 된 것 같습니다. 키워드들을 다시 봤는데 이 개념이 어디서 나오게 된 건지 가물가물해졌기 떄문이죠. 단기기억까지는 저장했었는데 장기기억으로 넘어갈때까지의 반복을 하지 않았던 제 자신에게 잔소리를 한 번 더 하면서 다시 공부를 해야겠습니다.</li>
</ul>
<h2 id="Finding"><a href="#Finding" class="headerlink" title="Finding"></a>Finding</h2><p>이전까지는 강의를 보면서 코드를 따라치면서 공부를 했었는데요. 이 방법이 저에게는 효과적이지 못하다는 느낌을 받았습니다.</p>
<p>이번 6주차부터는 강의를 한 번 보고 코드를 손으로 써봤는데 코드의 흐름이 머릿속에 들어오는 것 같아서 손으로 계속해서 써보려고 합니다. 조금 무식해보이는 방법일 수는 있어도 저에게 맞는 방법을 계속해서 찾아나가고 싶습니다.</p>
<h2 id="Future-action"><a href="#Future-action" class="headerlink" title="Future action"></a>Future action</h2><ul>
<li>데브 노트엔 내 물음표를 계속해서 넣기. (강의 자료를 내 데브노트에 정리하는 건 의미가 없으니까!)</li>
</ul>
]]></content>
      <tags>
        <tag>Retrospective</tag>
        <tag>Megaptera</tag>
      </tags>
  </entry>
  <entry>
    <title>🫧 버블 정렬(bubble sort) 구현해보기</title>
    <url>/2023/230418-archive/</url>
    <content><![CDATA[<h2 id="버블-정렬-Bubble-Sort"><a href="#버블-정렬-Bubble-Sort" class="headerlink" title="버블 정렬(Bubble Sort)"></a>버블 정렬(Bubble Sort)</h2><p>하나의 요소를 배열의 길이만큼 돌면서 해당 요소와 다른 요소를 비교 한 후 해당 요소가 더 크다면 위치를 바꾸는 방법입니다.</p>
<p><img src="/../img/230418/bubblesort.gif" alt="bubble sort"></p>
<h2 id="🫥-어떻게-구현하면-될까요"><a href="#🫥-어떻게-구현하면-될까요" class="headerlink" title="🫥 어떻게 구현하면 될까요?"></a>🫥 어떻게 구현하면 될까요?</h2><ol>
<li><p>전체 요소를 순회해야 합니다. 👉🏻 <code>for (let i = 0; i &lt; arr.length; i++;) &#123;&#125;</code></p>
</li>
<li><p>순회하는 i번쨰 요소는 배열의 마지막 요소까지 비교를 해야하므로 이중 for문을 사용해야겠습니다.</p>
</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>arr[j]가 arr[j + 1]보다 크면 서로의 위치를 바꿉니다.</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure>

<p>temp로 이렇게 저렇게 바꾸겠다라는 코드 말고…<br>하나의 함수를 사용해서 요소를 변경시켜보자구요!</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">swap</span> = (<span class="params">arr, idx1, idx2</span>) =&gt; &#123;</span><br><span class="line">  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>완성시키면?</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">swap</span> = (<span class="params">arr, idx1, idx2</span>) =&gt; &#123;</span><br><span class="line">  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> bubbleSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) <span class="title function_">swap</span>(arr, j, j+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<h2 id="현재-코드의-문제점"><a href="#현재-코드의-문제점" class="headerlink" title="현재 코드의 문제점"></a>현재 코드의 문제점</h2><p>현재 코드는 2개의 문제를 가지고 있습니다.</p>
<p><strong>🚧 배열의 범위를 넘어가면서 순회 중!</strong></p>
<p>arr[j]는 arr의 마지막 요소까지 순회합니다. 그렇다면 arr[j + 1]은 뭐가 될까요? 바로 undefined입니다.</p>
<p>우린 45와 undefined를 비교하고 있는 셈이죠. 배열의 범위를 넘기지 않고 탐색할 수 있는 방법이 뭐가 있을까요?</p>
<p><strong>🚧 정렬이 멈추지 않아요!</strong></p>
<p>for문이 종료되기 전에 중간에 정렬이 완료되는 경우가 있을 수 있습니다. 하지만 현재 코드에서는 멈출 수 있는 방법이 없죠. 우리의 코드는 조건에 맞는 for문이 끝날 때까지 멈추지 않고 계속해서 돌아가고 있을 겁니다. 중간에 멈출 수 있으면 좋을 것 같습니다!</p>
<br />

<h2 id="해결-방법"><a href="#해결-방법" class="headerlink" title="해결 방법"></a>해결 방법</h2><p>첫 번째 문제의 해결 방법은 첫 번째 for문은 거꾸로 돌고 두 번째 for문은 i - 1까지 반복하는 겁니다. 이렇게 되면 배열의 범위 안에서 반복이 가능합니다.</p>
<p>두 번째 문제의 해결 방법은 정렬이 다 되었는지 체크할 수 있는 상태를 가진 변수 <code>noSwap</code>을 하나 설정하는 겁니다.</p>
<p>for문이 시작될 때 true 👉🏻 값을 swap 했다면 false로 변경합니다.<br>만약 값을 swap하지 않았다면? 👉🏻 <code>noSwap</code>이 true라면 반복문을 빠져나오도록 합니다.</p>
<br />

<h2 id="정리해보면"><a href="#정리해보면" class="headerlink" title="정리해보면"></a>정리해보면</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">swap</span> = (<span class="params">arr, idx1, idx2</span>) =&gt; &#123;</span><br><span class="line">  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bubbleSort = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> noSwaps;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    noSwaps = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="title function_">swap</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        noSwaps = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (noSwaps) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br />

<hr>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><img src="https://jjalbang.today/jjv2Qp.jpg" style="width:512px; height:auto">

<p>처음 버블 정렬을 구현해야할 때 순회하는 요소와 그 다음 요소를 비교해서 바꾸면 되겠다라는 막연한 아이디어는 있었는데 디테일하게 구현하려고 하니 너무 막막했읍니다…</p>
<p>제 알고리즘 구현 능력은 여전히 하찮다는 생각을 하며.. 이제 꾸준히 한 문제씩 풀어보려고합니다. 문제 유형별로 카테고리를 나눠서 정리를 해보겠읍니다..!</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>CodeStates</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello, World!</title>
    <url>/2022/hello-world-0/</url>
    <content><![CDATA[<h2 id="🙌-안녕-GitHub-블로그"><a href="#🙌-안녕-GitHub-블로그" class="headerlink" title="🙌 안녕, GitHub 블로그!"></a>🙌 안녕, GitHub 블로그!</h2><p>여태 Notion으로 공부한 내용을 정리하다가 github 블로그로 넘어오게되었다.<br>그 이유는.. 모두에게 공개되는 github에 글을 작성했을 때, 더 신중하게 작성할 수 &gt;있을 것이라는 생각에 바로 github으로 변경했다.</p>
<h3 id="📒-영어공부의-필요성을-느끼는-중입니다"><a href="#📒-영어공부의-필요성을-느끼는-중입니다" class="headerlink" title="📒 영어공부의 필요성을 느끼는 중입니다."></a>📒 영어공부의 필요성을 느끼는 중입니다.</h3><p>최근 공부를 하면서 모르는 개념이 생길 때마다 공식 문서를 찾아보는데 문서를 볼 때마다 제대로 된 이해를 하지 못하는 것 같은 느낌이 들었다. 개발 관련된 단어라도 알고 있으면 이해가 수월하지 않을까? 라는 생각이 드는 찰나에 meot님의 개발 용어 레포지토리를 찾았다! 이것부터 차근차근 열심히 영어공부를 해보자..!</p>
<h3 id="✨-공부한-내용-기록하기"><a href="#✨-공부한-내용-기록하기" class="headerlink" title="✨ 공부한 내용 기록하기"></a>✨ 공부한 내용 기록하기</h3><p>TIL 이외의 내용들은 모두 이 곳에 기록해두자.<br>아직 미완성된 블로그이지만 글도 많이 쌓이고 기능도 조금씩 고쳐나가면 좋은 블로그가 되지 않을까:)<br>~<br>~-</p>
]]></content>
      <tags>
        <tag>IT</tag>
        <tag>Web</tag>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP와 HTTP 차이점이 무엇인가요?</title>
    <url>/2023/230419-archive/</url>
    <content><![CDATA[<p><em>🤷🏻‍♀️: “HTTP와 HTTPS의 차이점에 대해서 말씀해주시겠어요?”</em></p>
<img src="https://velog.velcdn.com/images/kim_unknown_/post/721eb7a0-1d1a-4168-b4e8-6969e6b6d541/image.jpg" style="width:512px; height:auto">

<p><em>🙋🏻: HTTP는… Hyper Text Transter Protocol의 약자로.. 음…</em></p>
<hr>
<br />

<p>제 미래가 머리속에 그려지는 것 같습니다. 기술 면접은 생각만해도 언제나 떨리는 일입니다.<br>막상 물어보면 하나도 대답을 못하죠.</p>
<p>하지만 계속해서 이럴 수는 없으니까! 짧게라도 대답할 수 있도록 정리를 해보자구요!</p>
<br />

<h2 id="✅-HTTP"><a href="#✅-HTTP" class="headerlink" title="✅ HTTP"></a>✅ HTTP</h2><p>HTTP란 Hyper Text Transfer Protocol, 즉 하이퍼 텍스트를 전송하기 위한 약속을 의미합니다.</p>
<p>웹을 만드는 여러가지 기술 중에 HTML, JavaScript, CSS는 필수적으로 필요한데요, 이 웹 표준 데이터는 서버에 저장되어 있습니다. 그리고 클라이언트는 저장되어있는 데이터를 서버에 요청을 해야합니다.</p>
<p><span style="background-color: rgba(153, 219, 218, 0.3); font-style: italic">이러한 웹 표준 데이터를 서버에 요청하고 받아오는 프로토콜이 HTTP입니다.</span></p>
<br />

<h3 id="✅-HTTP의-단점"><a href="#✅-HTTP의-단점" class="headerlink" title="✅ HTTP의 단점"></a>✅ HTTP의 단점</h3><p>HTTP는 단점이 있는데요, 바로 <strong>암호화</strong>되어있지 않다는 것입니다.<br>암호화하지 않았기 때문에 도청당할 수 있는 위험이 있습니다.<br>통신 경로상에 있는 네크워크 기기나 컴퓨터와 같은 기기를 통해 도청을 당할 수도 있습니다.</p>
<p>또한 통신 상대를 확인하지 않기 때문에 신뢰성이 떨어집니다.<br>HTTP는 어떤 요청이 들어와도 응답을 해주는 구조이기 때문에 정보에 대한 정확성이 떨어지고 서버와 클라이언트가 보낸 정보를 중간에 누군가 바꿀 위험이 발생합니다.</p>
<br />

<h3 id="✅-HTTPS의-탄생"><a href="#✅-HTTPS의-탄생" class="headerlink" title="✅ HTTPS의 탄생"></a>✅ HTTPS의 탄생</h3><p>그래서 HTTP의 단점을 극복하기 위해 나타나게 된 것이 HTTPS입니다.<br><strong>HTTPS는 SSL을 이용한 HTTP 통신 방식입니다.</strong></p>
<p>HTTP 통신하는 소켓 부분을 SSL이라는 프로토콜로 대체합니다. 원래 HTTP는 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 됩니다.</p>
<p>HTTPS로 전환하게 되면 암호화와 증명서, 안정성 보호를 이용할 수 있기 때문에 보안상 우위에 있을 뿐만 아니라 검색 엔진 최적화에서도 도움을 받을 수 있다는 장점이 있습니다.</p>
<h2 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h2><p>SSL은 Secure Socket Layer로, 암호화 기반 인터넷 보안 프로토콜입니다. 인터넷 통신에 개인정보 보호, 인증, 데이터 무결성을 위해 개발되었습니다.</p>
]]></content>
      <tags>
        <tag>Network</tag>
        <tag>Tech_Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
