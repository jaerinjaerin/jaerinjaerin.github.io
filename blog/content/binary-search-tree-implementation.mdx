---
title: 'Binary Search Tree(ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬) êµ¬í˜„í•˜ê¸° ğŸŒ²'
date: 2023-05-11
tags: ['Algorithm']
thumbnail: /thumbnails/algorithm-subset-problem.png
---

íŠ¸ë¦¬ì— ëŒ€í•´ì„œ ê³µë¶€í–ˆìœ¼ë‹ˆ, ì´ì§„íƒìƒ‰íŠ¸ë¦¬ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ì„œ ì •ë¦¬í•´ë³´ë ¤ê³  í•©ë‹ˆë‹¤. :)

## âœ… init

Nodeë¥¼ ë§Œë“¤ í´ë˜ìŠ¤, Binary Search Tree í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.

```jsx
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}
```

```jsx
class BinarySearchTree {
  constructor() {
    this.root = null;
  }
}
```

## ğŸš€ insert method

### Pseudo Code

- ìƒˆë¡œìš´ ë…¸ë“œ(newNode)ë¥¼ ë§Œë“ ë‹¤.
- root Nodeì™€ ë¹„êµí•œë‹¤.
- root Nodeê°€ ì—†ë‹¤ë©´ newNodeë¥¼ rootë¡œ ë§Œë“ ë‹¤.
- root Nodeê°€ ìˆë‹¤ë©´ newNodeì˜ ê°’ì´ í° ì§€, ì‘ì€ ì§€ ë¹„êµí•œë‹¤.
- root Nodeë³´ë‹¤ í¬ë‹¤ë©´?
  root.rightì— ì†í•œ ë…¸ë“œë¥¼ í™•ì¸í•œë‹¤.
  root.rightê°€ ìˆë‹¤ë©´ ì´ì „ ìŠ¤í…ì„ ë™ì¼í•˜ê²Œ ë°˜ë³µí•œë‹¤.
  root.rightê°€ ì—†ë‹¤ë©´ newNodeë¥¼ root.rightë¡œ ë§Œë“ ë‹¤.
- root Nodeë³´ë‹¤ ì‘ë‹¤ë©´?
  root.leftì— ì†í•œ ë…¸ë“œë¥¼ í™•ì¸í•œë‹¤.
  root.left ìˆë‹¤ë©´ ì´ì „ ìŠ¤í…ì„ ë™ì¼í•˜ê²Œ ë°˜ë³µí•œë‹¤.
  root.left ì—†ë‹¤ë©´ newNodeë¥¼ root.leftë¡œ ë§Œë“ ë‹¤.

```jsx
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);
    if (this.root === null) {
      this.root = newNode;
      return this;
    }

    // ë¹„êµí•˜ëŠ” ë…¸ë“œë¥¼ currentë¼ëŠ” ë³€ìˆ˜ì— í• ë‹¹
    let current = this.root;
    while (true) {
      // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ìš”ì†Œë¼ë©´ undefined í˜¹ì€ false return
      if (value === current.value) return undefined;

      // valueê°€ ì‘ë‹¤ë©´ ì™¼ìª½ìœ¼ë¡œ ì´ë™
      if (value < current.value) {
        if (current.left === null) {
          current.left = newNode;
          return this;
        } else {
          current = current.left;
        }
      } else if (value > current.value) {
        if (current.right === null) {
          this.root.right = newNode;
          return this;
        } else {
          current = current.right;
        }
      }
    }
  }
}
```

## contains method

### ğŸš€ Pseudo Code

- rootë¶€í„° ì‹œì‘
  rootê°€ ì—†ë‹¤ë©´ íƒìƒ‰í•  í•„ìš”ê°€ ì—†ìŒ
  rootê°€ ìˆë‹¤ë©´, new Nodeì˜ ê°’ì´ rootì˜ ê°’ë³´ë‹¤ ì‘ì€ì§€ í°ì§€ ë¹„êµí•œë‹¤.
- ë§Œì•½ new Nodeì˜ ê°’ì´ ë” í¬ë‹¤ë©´?
  current = current.right
  ì¢…ë£Œì¡°ê±´ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ê³„ì† ë°˜ë³µí•œë‹¤.
  ê°’ì„ ì°¾ì•˜ë‹¤ë©´ return true
- ë§Œì•½ new Nodeì˜ ê°’ì´ ë” ì‘ë‹¤ë©´?
  current = current.left
  ì¢…ë£Œ ì¡°ê±´ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ê³„ì† ë°˜ë³µí•œë‹¤.
  ê°’ì„ ì°¾ì•˜ë‹¤ë©´ return true
- ì¢…ë£Œì¡°ê±´ê¹Œì§€ ì°¾ì§€ ëª»í–ˆë‹¤ë©´ return false

```jsx
contains(value) {
  if (this.root === null) return false;
  let current = this.root;
  let found = false; // í•´ë‹¹ ìš”ì†Œë¥¼ ì°¾ì•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë³€ìˆ˜

  // currentê°€ ì¡´ì¬í•˜ê³  ê°’ì„ ì°¾ì§€ ëª»í–ˆë‹¤ë©´ (foundê°€ falseë¼ë©´) whileë¬¸ ì‹¤í–‰
  while (current && !found) {
    if (value < current.value) {
      current = current.left;
    } else if (value > current.value) {
      current = current.right;
    } else {
      return true;
    }
  }
  return false;
}
```

## ğŸ–ï¸ Arrayë¥¼ ì´ìš©í•´ì„œ í‘¸ëŠ” ë°©ë²•

```jsx
const array = [1, 1, 5, 400, 599, 1004, 2876, 8712];
function BinarySearchTree(array, findValue) {
  let left = 0;
  let right = array[array.length - 1];
  let mid = Math.floor((left + right) / 2);
  while (left < right) {
    if (array[mid] === findValue) {
      return mid;
    }
    if (array[mid] < findValue) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
    mid = Math.floor((left + right) / 2);
  }
  return -1;
}
```
