---
title: 베스트앨범
description: 해시테이블과 고차함수를 이용해서 구현하기
date: 2024-11-11
tags: ['Algorithm']
thumbnail: '/thumbnails/algorithm-a-to-z.png'
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

## 문제

스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.

1. 속한 노래가 많이 재생된 장르를 먼저 수록합니다.
2. 장르 내에서 많이 재생된 노래를 먼저 수록합니다.
3. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.

노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.

### 제한 사항

- genres[i]는 고유번호가 i인 노래의 장르입니다.
- plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.
- genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.
- 장르 종류는 100개 미만입니다.
- 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.
- 모든 장르는 재생된 횟수가 다릅니다.

### 입출력 예시

| genres                                          | plays                      | return       |
| ----------------------------------------------- | -------------------------- | ------------ |
| ["classic", "pop", "classic", "classic", "pop"] | [500, 600, 150, 800, 2500] | [4, 1, 3, 0] |

```tsx
const genres = ['classic', 'pop', 'classic', 'classic', 'pop'];
const plays = [500, 600, 150, 800, 2500];
```

### 입출력 설명

classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다.

- 고유 번호 3: 800회 재생
- 고유 번호 0: 500회 재생
- 고유 번호 2: 150회 재생

pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다.

- 고유 번호 4: 2,500회 재생
- 고유 번호 1: 600회 재생

따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다.

- 장르 별로 가장 많이 재생된 노래를 최대 두 개까지 모아 베스트 앨범을 출시하므로 2번 노래는 수록되지 않습니다.

---

## 나의 풀이

<Callout type="info">
**핵심 개념**

- `장르 별로 가장 많이 재생된 노래 두개씩` → 장르별로 데이터를 모아야한다.
- 장르별로 총 재생된 횟수의 합계도 가지고 있어야 한다.

</Callout>

결과적으로 완성되어야 하는 데이터 구조는 다음과 같습니다.

```tsx
{ genre : "classic", totalPlays: 1450, songs: [{id: 0, play: 500}, {id:3, play: 150}] }]
```

<Steps>

<Step>
### 1. 두 개의 배열을 하나의 데이터로 만들기

```tsx
const songs = genres.map((genre, index) => {
    return { genre: genre, id: index, play: plays[index] }
})

songs.reduce((acc, song => {
	if(!acc[song.genre]) {
		acc[song.genre] = [];
	}
	acc[song.genre].push(song);
	return acc;
}, {})

 // 결과:
  // {
  //   classic: [
  //     {genre: 'classic', id: 0, play: 500},
  //     {genre: 'classic', id: 2, play: 150},
  //     {genre: 'classic', id: 3, play: 800}
  //   ],
  //   pop: [
  //     {genre: 'pop', id: 1, play: 600},
  //     {genre: 'pop', id: 4, play: 2500}
  //   ]
  // }
```

</Step>

<Step>
### 2. 장르별로 그룹핑하기

```tsx
const grouped = songs.reduce((acc, song) => {
  if (!acc[song.genre]) {
    acc[song.genre] = [];
  }
  acc[song.genre].push(song);
  return acc;
}, {});
```

</Step>

<Step>
### 3. 각 장르의 총 play 합계 계산 및 정렬

```tsx
const genreStats = Object.entries(grouped)
  .map(([genre, items]) => ({
    genre,
    items,
    totalPlay: items.reduce((sum, song) => sum + song.play, 0),
  }))
  .sort((a, b) => b.totalPlay - a.totalPlay); // 총합 내림차순
```

</Step>

<Step>
### 4. 각 장르에서 play가 많은 2개씩 선택

```tsx
const result = genreStats.flatMap(
  ({ items }) =>
    items
      .sort((a, b) => b.play - a.play) // play 내림차순
      .slice(0, 2) // 상위 2개만
      .map((song) => song.id) // id만 추출
);
```

</Step>

</Steps>

---

## Solution

<Callout type="success">
**Map 객체를 활용한 효율적인 해결법**

Map 객체를 사용하면 더 간결하고 효율적으로 문제를 해결할 수 있습니다.

</Callout>

<Steps>

<Step>
### 1. Map 객체 생성

```tsx
const genreMap = new Map();
```

</Step>

<Step>
### 2. genres와 plays 배열 정보를 하나로 결합

```tsx
genres.map((genre, index) => [genre, plays[index]]);
// [[ 'classic', 500 ], [ 'pop', 600 ], [ 'classic', 150 ], [ 'classic', 800 ], [ 'pop', 2500 ]]
```

</Step>

<Step>
### 3. genreMap에 데이터 저장

genre 기준으로 `{ total: 0, songs: [{ play: 0, index: 1}], ... }` 형태의 데이터를 생성합니다.

```tsx
.forEach(([genre, play], index) => {
	const data = genreMap.get(genre) || { total: 0, songs: []};

	genreMap.set(genre, {
		total: data.total + play,
		songs: [...data.songs, { play, index }]
	})
})

// 출력값
Map(2) {
  'classic' => { total: 1450, songs: [ [Object], [Object], [Object] ] },
  'pop' => { total: 3100, songs: [ [Object], [Object] ] }
}
```

</Step>

<Step>
### 4. 장르별로 가장 많이 재생된 두 곡만 저장

```tsx
genreMap.set(genre, {
  total: data.total + play,
  songs: [...data.songs, { play, index }].sort((a, b) => b.play - a.play).slice(0, 2),
});
```

</Step>

<Step>
### 5. entries 메서드로 배열 형태로 변환 후 total 기준 정렬

```tsx
[...genreMap.entries()].sort((a, b) => b[1].total - a[1].total);
```

</Step>

<Step>
### 6. flatMap으로 songs 값만 추출

```tsx
.flatMap(item => item[1].songs)
```

</Step>

<Step>
### 7. songs 배열의 index만 반환

```tsx
.map(song => song.index)
```

</Step>

</Steps>

### 최종 코드

```tsx title="solution.js"
function solution(genres, plays) {
  const genreMap = new Map();

  genres
    .map((genre, index) => [genre, plays[index]])
    .forEach(([genre, play], index) => {
      const data = genreMap.get(genre) || { total: 0, songs: [] };

      genreMap.set(genre, {
        total: data.total + play,
        songs: [...data.songs, { play, index }].sort((a, b) => b.play - a.play).slice(0, 2),
      });
    });

  return [...genreMap.entries()]
    .sort((a, b) => b[1].total - a[1].total)
    .flatMap((item) => item[1].songs)
    .map((song) => song.index);
}
```

<Callout type="success">
**시간 복잡도**: O(n log n) - Map 연산과 정렬을 포함합니다.

**공간 복잡도**: O(n) - 모든 노래 정보를 Map에 저장합니다.

</Callout>
