---
title: 'TypeScript Readonly 사용하기'
description: 'readonly 키워드와 Readonly 유틸리티 타입으로 불변성 보장하기'
date: '2024-05-28'
tags: ['TypeScript']
featured: false
thumbnail: '/thumbnails/typescript.png'
---

import { Callout } from 'fumadocs-ui/components/callout';

## `readonly`

<Callout type="info">
**readonly의 정의**

객체의 속성이나 배열의 요소를 읽기 전용으로 만들기 위해 사용한다. readonly로 선언된 속성은 초기화 후에는 변경할 수 없다.

<mark>**데이터의 불변성을 보장할 때 유용**</mark>

</Callout>

---

## 사용 예시

### 1. 인터페이스에서 readonly 사용

속성을 readonly로 선언하여 읽기 전용으로 만들 수 있다.

```typescript
interface User {
  readonly id: number;
  name: string;
}

const user: User = { id: 1, name: 'Alice' };

console.log(user.id); // 1

user.name = 'Bob'; // OK
// user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.
```

<Callout type="warn">
**읽기 전용 속성 수정 시도**

readonly로 선언된 속성을 수정하려고 하면 컴파일 타임 에러가 발생한다. 이를 통해 의도하지 않은 데이터 변경을 방지할 수 있다.

</Callout>

### 2. 클래스에서 readonly 사용

class에서도 속성을 readonly로 선언할 수 있다. readonly 속성은 클래스 내부에서 초기화될 수 있지만, 이후에는 수정할 수 없다.

```typescript
class Person {
  readonly id: number;
  name: string;

  constructor(id: number, name: string) {
    this.id = id;
    this.name = name;
  }
}

const person = new Person(1, 'John');

console.log(person.id); // 1

person.name = 'Jane'; // OK
// person.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.
```

<Callout type="info">
**클래스에서의 초기화**

readonly 속성은 다음 두 가지 방법으로 초기화할 수 있다:
1. 선언 시점에서 초기화
2. 생성자(constructor) 내부에서 초기화

초기화 이후에는 값을 변경할 수 없다.

</Callout>

### 3. 배열에서 readonly 사용

```typescript
const numbers: readonly number[] = [1, 2, 3, 4];

console.log(numbers[0]); // 1

// numbers.push(5); // Error: Property 'push' does not exist on type 'readonly number[]'.
// numbers[0] = 10; // Error: Index signature in type 'readonly number[]' only permits reading.
```

<Callout type="success">
**배열의 불변성 보장**

readonly 배열은 다음과 같은 변경 작업을 모두 차단한다:
- 요소 추가 (push, unshift 등)
- 요소 제거 (pop, shift, splice 등)
- 요소 수정 (인덱스를 통한 직접 할당)

</Callout>

### 4. Readonly 유틸리티 타입 사용

TypeScript는 객체의 모든 속성을 읽기 전용으로 만드는 `Readonly` 유틸리티 타입을 제공한다.

```typescript
interface User {
  id: number;
  name: string;
}

const user: Readonly<User> = { id: 1, name: 'Alice' };

console.log(user.id); // 1

// user.name = "Bob"; // Error: Cannot assign to 'name' because it is a read-only property.
// user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.
```

<Callout type="info">
**Readonly 유틸리티 타입**

`Readonly<T>`는 타입 T의 모든 속성을 readonly로 만든다. 각 속성마다 readonly를 일일이 붙이지 않아도 되므로 편리하다.

</Callout>

---

## 정리

<Callout type="success">
**readonly 사용의 장점**

1. **불변성 보장**: 초기화 후 값 변경을 방지하여 예측 가능한 코드 작성
2. **의도 명확화**: 변경되지 않아야 하는 데이터를 명시적으로 표현
3. **버그 방지**: 실수로 인한 데이터 변경을 컴파일 타임에 차단
4. **함수형 프로그래밍**: 불변성을 중시하는 함수형 패러다임과 잘 어울림

readonly는 데이터의 무결성을 유지하고 안전한 코드를 작성하는 데 필수적인 도구이다.

</Callout>
