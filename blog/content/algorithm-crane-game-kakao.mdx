---
title: '크레인 인형뽑기'
description: 2019 카카오 개발자 겨울 인턴십
date: '2022-10-13'
tags: ['Algorithm']
featured: false
thumbnail: '/thumbnails/algorithm-subset-problem.png'
---

## 문제

게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다. 죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.

![크레인 인형뽑기 게임판](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/69f1cd36-09f4-4435-8363-b71a650f7448/crane_game_101.png)

게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다.

모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다.

다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.

![인형 집기 과정](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/638e2162-b1e4-4bbb-b0d7-62d31e97d75c/crane_game_102.png)

만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.

![인형 터지는 과정](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/8569d736-091e-4771-b2d3-7a6e95a20c22/crane_game_103.gif)

크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동 시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)

게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.

---

## 제한 사항

- board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.
- board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.
- 0은 빈 칸을 나타냅니다.
- 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.
- moves 배열의 크기는 1 이상 1,000 이하입니다.
- moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.

---

## 예제

### 입력 예제 1

```jsx
[
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 3],
  [0, 2, 5, 0, 1],
  [4, 2, 4, 4, 2],
  [3, 5, 1, 3, 1],
][(1, 5, 3, 5, 1, 2, 1, 4)]; // board 배열 // moves 배열
```

### 출력 예제 1

```
4
```

---

## 🙌🏻 문제 이해하기

문제를 해결하기 위해 어떤 방법을 사용해야하는지 생각해보자 :)

1. 인형을 스택이라는 바구니에 넣어야 한다. ➡️ 배열 생성
2. moves 배열을 하나씩 순회해야한다. ➡️ forEach 메서드
3. 위치 1에 해당하는 board의 인덱스는 0이다.
   - board 배열의 형태는 2차원 배열이며 위치 1에 해당하는 요소를 탐색하기 위해선
   - [0][1], [1][1], [2][1] 의 형태로 반복을 해야한다. ➡️ for문 [i][1]
4. 반복문으로 탐색을 하다가 값이 0이 아닌 요소를 만나면 인형을 꺼내야한다.
5. 인형을 꺼냈다면 해당 위치의 배열 요소는 0으로 만들어줘야 한다.
6. 꺼낸 인형을 스택에 push하자. 그 전에 체크를 해야하는데,
   - 만약 스택에 담겨있는 마지막 인형이 넣을 인형과 동일하다면? → push가 아니라 pop을 하면 된다. 그리고 answer += 2
   - 동일하지 않다면? → 그 때 push하기
7. 터진 인형의 갯수를 구하는 문제이기 때문에 answer를 반환하면 된다.

---

## ✅ Solution

```jsx
function solution(board, moves) {
  let answer = 0;
  let stack = [];
  moves.forEach((item) => {
    for (let i = 0; i < board.length; i++) {
      // 순회하는 요소가 0이 아닐때만 stack에 값을 push할 수 있다.
      if (board[i][item - 1] !== 0) {
        // stack에 넣을 값을 임시 저장해놓기 (인형 꺼내기)
        let tmp = board[i][item - 1];
        // 값을 선택했으니, 배열의 원소는 0으로 설정해놓기
        board[i][item - 1] = 0;
        // stack에 push 하기 전에 먼저 체크
        // 1. 만약 tmp가 stack의 가장 마지막 요소와 같으면 pop하고 answer += 2
        // 2. tmp가 stack의 가장 마지막 요소와 일치하지 않으면 stack.push(tmp)
        if (tmp === stack[stack.length - 1]) {
          stack.pop();
          answer += 2;
        } else stack.push(tmp);
        // 해당 포지션에선 작업을 끝냈기 때문에 for문에서 탈출
        break;
      }
    }
  });

  return answer;
}

console.log(
  solution(
    [
      [0, 0, 0, 0, 0],
      [0, 0, 1, 0, 3],
      [0, 2, 5, 0, 1],
      [4, 2, 4, 4, 2],
      [3, 5, 1, 3, 1],
    ],
    [1, 5, 3, 5, 1, 2, 1, 4]
  )
);
```

---

## 😎 Review

stack을 구현하고 배열을 하는 부분까지는 이제 어렵지 않다. 하지만 어느 시점에서 어떻게 자료를 빼낼건지에 대해서는 계속 공부를 하면서 익숙해져야할 것 같다…😢

예전엔 건들지도 못했던 내 자신과 비교하면 그래도 많이 늘었다! 게속 열심히 공부해보즈앗
