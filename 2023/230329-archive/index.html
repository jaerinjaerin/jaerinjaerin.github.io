<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="leejaelll">


    <meta name="subtitle" content="by Leejaelll">






<title>REST API가 무엇인가 (부제: 그런 REST API로 괜찮은가) | LEE_PLAY</title>



    <link rel="icon" href="/favicon.png">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    










  <meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            LEE_PLAY
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Post</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tag/">Tag</a>
              </li> 
                   
          
          
            <li class="menu-item search-btn">
              <a href="#">Search</a>
            </li>
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/Network/">
                            Network
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                REST API가 무엇인가 (부제: 그런 REST API로 괜찮은가)
            
            
        </div>
        <span class="post-date">
            Mar 29, 2023
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <p>REST API가 어떤 배경에서 나온건지부터 알아보자</p>
<h2 id="WEB-1991-어떻게-인터넷에서-정보를-공유할-것인가"><a href="#WEB-1991-어떻게-인터넷에서-정보를-공유할-것인가" class="headerlink" title="WEB (1991) - 어떻게 인터넷에서 정보를 공유할 것인가?"></a>WEB (1991) - 어떻게 인터넷에서 정보를 공유할 것인가?</h2><p>정보들을 하이퍼텍스트로 연결한다!</p>
<ul>
<li>표현형식: HTML</li>
<li>식별자: URI</li>
<li>전송방법: HTTP</li>
</ul>
<h2 id="HTTP-x2F-1-0-1994-1996"><a href="#HTTP-x2F-1-0-1994-1996" class="headerlink" title="HTTP&#x2F;1.0 (1994-1996)"></a>HTTP&#x2F;1.0 (1994-1996)</h2><p>이미 HTTP는 W3C의 전송 프로토콜로 이용이 되고 있었고, 웹은 급속도로 성장중인 시점</p>
<p>당시 대학원생이었던 Roy T.Fielding은 HTTP를 정립하고 명서에 기능을 더하고 고쳐야하는 상황에 모이게 됨</p>
<p>💬 기존에 이미 구축되어있는 웹을 망가뜨리지 않고 HTTP를 개선할 수 있을까?</p>
<p>해결책: HTTP Object Model</p>
<h2 id="REST-1998"><a href="#REST-1998" class="headerlink" title="REST (1998)"></a>REST (1998)</h2><p>Roy T.Fielding, Microsoft Research에서 발표</p>
<h2 id="REST-2000"><a href="#REST-2000" class="headerlink" title="REST (2000)"></a>REST (2000)</h2><p>Roy T.Fielding, 2년 뒤에 박사 논문으로 발표</p>
<ul>
<li>우리가 알고 있는 REST를 정의하고 있는 논문</li>
<li>“Architectural Styles and the Design of Network-based Software Architectures”</li>
</ul>
<h3 id="한편-인터넷-상에-API라는-것이-만들어지기-시작했다"><a href="#한편-인터넷-상에-API라는-것이-만들어지기-시작했다" class="headerlink" title="한편.. 인터넷 상에 API라는 것이 만들어지기 시작했다."></a>한편.. 인터넷 상에 API라는 것이 만들어지기 시작했다.</h3><h2 id="XML-RPC-1998"><a href="#XML-RPC-1998" class="headerlink" title="XML-RPC (1998)"></a>XML-RPC (1998)</h2><p>by Microsoft</p>
<p>이후에 SOAP이라는 이름으로 바뀜</p>
<h2 id="Salesforce-API-2000-02"><a href="#Salesforce-API-2000-02" class="headerlink" title="Salesforce API (2000. 02)"></a>Salesforce API (2000. 02)</h2><p>Salesforce라는 회사에서 API를 공개</p>
<ul>
<li>인터넷에서 최초로 공개된 API</li>
<li>당시에 SOAP을 사용해서 API를 만듦</li>
<li>너무 복잡에서 장사가 잘 안됨</li>
</ul>
<h2 id="flickr-API-2004-08"><a href="#flickr-API-2004-08" class="headerlink" title="flickr API (2004. 08)"></a>flickr API (2004. 08)</h2><ul>
<li>다양한 형태로 API를 만듦</li>
<li>SOAP 형태 + REST 형태 <em>(사실 REST는 2000년에 나왔지만 사람들은 새롭게 느낌)</em></li>
</ul>
<p>사람들이 느끼는 SOAP과 REST 형태</p>
<p>SOAP</p>
<ul>
<li>복잡하다</li>
<li>규칙이 많다</li>
<li>어렵다</li>
</ul>
<p>REST</p>
<ul>
<li>단순하다</li>
<li>규칙이 적다</li>
<li>쉽다</li>
</ul>
<h3 id="결국"><a href="#결국" class="headerlink" title="결국"></a>결국</h3><ul>
<li>2006년, AWS가 자사 API 사용량의 85%가 REST임을 밝힘</li>
<li>2010년, Salesforce.com도 REST API 추가</li>
</ul>
<h3 id="REST의-승리로-해피엔딩인줄-알았는데"><a href="#REST의-승리로-해피엔딩인줄-알았는데" class="headerlink" title="REST의 승리로 해피엔딩인줄 알았는데.."></a>REST의 승리로 해피엔딩인줄 알았는데..</h3><h2 id="CMIS-2008"><a href="#CMIS-2008" class="headerlink" title="CMIS (2008)"></a>CMIS (2008)</h2><ul>
<li>CMS를 위한 표준</li>
<li>EMC, IBM, Microsoft 등이 함께 작업</li>
<li>REST 바인딩 지원</li>
</ul>
<p>하지만 Roy T.Fielding은 ‘CMIS에는 REST가 없다’라고 말함</p>
<h2 id="Microsoft-REST-API-Guidlines-2016"><a href="#Microsoft-REST-API-Guidlines-2016" class="headerlink" title="Microsoft REST API Guidlines (2016)"></a>Microsoft REST API Guidlines (2016)</h2><ul>
<li>url은 https:&#x2F;&#x2F;{serviceRoot}&#x2F;{collection}&#x2F;{id} 형식이어야 한다.</li>
<li>GET, PUT, DELETE, POST, PATCH, HEAD, OPTIONS를 지원해야 한다.</li>
<li>API 버저닝은 Major.minor로 하고 uri에 버전 정보를 포함시킨다.</li>
</ul>
<p>사람들이 보기엔 합리적인 이야기처럼 보임.</p>
<p>하지만 Roy T.Fielding은 ‘이건 REST API가 아님, HTTP API라고 해야함’이라고 말함</p>
<h3 id="‘REST-API는-반드시-HyperText-driven이어야-한다’"><a href="#‘REST-API는-반드시-HyperText-driven이어야-한다’" class="headerlink" title="‘REST API는 반드시 HyperText-driven이어야 한다’"></a>‘REST API는 반드시 HyperText-driven이어야 한다’</h3><h3 id="‘REST-API를-위한-최고의-버저닝-전략은-버저닝을-하지-않는-것’"><a href="#‘REST-API를-위한-최고의-버저닝-전략은-버저닝을-하지-않는-것’" class="headerlink" title="‘REST API를 위한 최고의 버저닝 전략은 버저닝을 하지 않는 것’"></a>‘REST API를 위한 최고의 버저닝 전략은 버저닝을 하지 않는 것’</h3><p>사람들이 알고있던 REST하고 REST를 만들었던 Roy T.Fielding이 말하는 REST와의 차이가 점점 생기는 것 같은데? 문제가 무엇일까? REST API를 따져보자</p>
<h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><p>REST 아키텍쳐 스타일을 따른 API</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p>분산 하이퍼미디어 시스템(웹)을 위한 아키텍쳐 스타일</p>
<h2 id="아키텍쳐-스타일"><a href="#아키텍쳐-스타일" class="headerlink" title="아키텍쳐 스타일"></a>아키텍쳐 스타일</h2><p>제약 조건의 집합</p>
<p>(사실 REST는 아키텍쳐 스타일이면서 동시에 하이브리드 아키텍쳐 스타일이라고 말한다. 아키텍쳐 스타일인데 동시에 아키텍쳐 스타일의 집합이기 때문) 👉🏻 무슨말?</p>
<h3 id="REST를-구성하는-스타일"><a href="#REST를-구성하는-스타일" class="headerlink" title="REST를 구성하는 스타일"></a>REST를 구성하는 스타일</h3><ul>
<li>client-server</li>
<li>stateless</li>
<li>cache</li>
<li><strong>uiform interface</strong></li>
<li>layered system</li>
<li>code-on-demand (optional) ➡️ 서버에서 코드를 클라이언트한테 보내서 실행할 수 있어야한다.<em>(자바스크립트)</em></li>
</ul>
<p>HTTP API만 지켜도 대부분의 아키텍쳐 스타일을 지킬 수 있지만 uinform interface를 잘 지키지 못함</p>
<h2 id="Uniform-Interface의-제약-조건"><a href="#Uniform-Interface의-제약-조건" class="headerlink" title="Uniform Interface의 제약 조건"></a>Uniform Interface의 제약 조건</h2><ul>
<li>리소스가 URI로 식별되면 된다.</li>
<li>리소스를 만들거나 업데이트하거나 삭제할 때 HTTP 메세지에 표현을 담아서 전송을 해야한다.</li>
<li><strong>self-descriptive messages</strong></li>
<li><strong>hypermedia as the engine of application state (HATEOAS)</strong></li>
</ul>
<p>👉🏻 나머지 두 개는 거의 지켜지지 못한다.</p>
<h3 id="self-descriptive-messages"><a href="#self-descriptive-messages" class="headerlink" title="self-descriptive messages"></a><strong>self-descriptive messages</strong></h3><p>메세지는 스스로를 설명해야 한다.</p>
<p>이 HTTP 요청 메세지는 뭔가 빠져있어서 self-descriptive하지 못하다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span> / <span class="number">1.1</span>;</span><br></pre></td></tr></table></figure>

<p>목적지가 빠져있음</p>
<p>목적지를 추가하면? self-descriptive 함</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span> / <span class="number">1.1</span>;</span><br><span class="line"><span class="attr">HOST</span>: www.<span class="property">example</span>.<span class="property">org</span>;</span><br></pre></td></tr></table></figure>

<p>아래는 왜 self-descriptive 하지 못할까?</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/a/b/c&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<p>클라이언트가 이 응답을 받고 해석해야하는데 어떤 문법으로 작성되었는지 모르기 때문에 self-descriptive하지 못하다고 말함</p>
<p>우선 Content-Type이 반드시 들어가야 한다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/a/b/c&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json.<span class="property">patch</span>+json</span><br><span class="line"></span><br><span class="line">[ &#123; <span class="string">&quot;op&quot;</span>: <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/a/b/c&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>

<h3 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h3><p>애플리케이션 상태는 Hyperlink를 이용해 전이되어야 한다.</p>
<p>하나의 게시판 애플리케이션을 떠올려보자.</p>
<p>글 목록 보기를 클릭하면 글 목록이 있는 페이지가 보여지고, 글 쓰기 버튼을 누르면 글 쓰기 페이지, 저장 버튼을 누르면 글 저장완료 안내 페이지가 나온다.</p>
<p>이것을 <code>애플리케이션 상태의 전이</code>라고 하는데 이 상태의 전이 마다 해당 페이지에 있던 링크를 따라가기 때문에 HATEOAS가 된다고 말할 수 있다.</p>
<h2 id="왜-Uniform-Interface를-해야하는가"><a href="#왜-Uniform-Interface를-해야하는가" class="headerlink" title="왜 Uniform Interface를 해야하는가?"></a>왜 Uniform Interface를 해야하는가?</h2><h3 id="독립적-진화를-하기-위해서"><a href="#독립적-진화를-하기-위해서" class="headerlink" title="독립적 진화를 하기 위해서"></a>독립적 진화를 하기 위해서</h3><ul>
<li>서버와 클라이언트가 각각 독립적으로 진화한다.</li>
<li>서버의 기능이 변경되어도 클라이언트를 업데이트할 필요가 없다.</li>
<li>이것이 바로 REST를 만들게 된 계기: “How do I imporve HTTP without breaking the Web”</li>
</ul>
<h2 id="실제로-REST가-잘-지켜지고-있는가"><a href="#실제로-REST가-잘-지켜지고-있는가" class="headerlink" title="실제로 REST가 잘 지켜지고 있는가?"></a>실제로 REST가 잘 지켜지고 있는가?</h2><p>잘 지켜지고 있는 사례로는 웹이 있다.</p>
<h3 id="웹"><a href="#웹" class="headerlink" title="웹"></a>웹</h3><ul>
<li>웹페이지를 변경했다고 브라우저를 업데이트할 필요는 없다.</li>
<li>웹 브라우저를 업데이트했다고 웹 페이지를 변경할 필요도 없다.</li>
<li>HTTP 명세가 변경되어도 웹은 잘 동작한다.</li>
<li>HTML 명세가 변경되어도 웹은 잘 동작한다.</li>
</ul>
<h3 id="이건-진짜-피땀흘려-노력한-결과다"><a href="#이건-진짜-피땀흘려-노력한-결과다" class="headerlink" title="이건 진짜 피땀흘려 노력한 결과다."></a>이건 진짜 피땀흘려 노력한 결과다.</h3><ul>
<li>HTML5 첫 초안에서 권고안 나오는데까지 6년</li>
<li>HTTP&#x2F;1.1 명세 개정판 작업하는데 7년</li>
</ul>
<h3 id="왜-이렇게-오래걸림-상호운용성에-대한-집착"><a href="#왜-이렇게-오래걸림-상호운용성에-대한-집착" class="headerlink" title="왜 이렇게 오래걸림? 상호운용성에 대한 집착"></a>왜 이렇게 오래걸림? 상호운용성에 대한 집착</h3><p>하위 호환성을 지키기 위해 수정할 수 없는 것들</p>
<ul>
<li>Referer 오타지만 못 고침</li>
<li>charset 잘못 지은 이름이지만 못 고침</li>
<li>HTTP 상태 코드 416 포기</li>
<li>HTTP&#x2F;0.9 아직도 지원함(크롬, 파이어폭스)</li>
</ul>
<p>그런 노력이 없으면? 웹도 지원하지 않는다는 경고창을 볼 수 있다.</p>
<h3 id="REST가-웹의-독립적-진화에-도움을-주었나"><a href="#REST가-웹의-독립적-진화에-도움을-주었나" class="headerlink" title="REST가 웹의 독립적 진화에 도움을 주었나?"></a>REST가 웹의 독립적 진화에 도움을 주었나?</h3><ul>
<li>HTTP에 지속적으로 영향을 줌</li>
<li>HOST 헤더 추가</li>
<li>길이 제한을 다루는 방법이 명시</li>
<li>URI에서 리소스의 정의가 추상적으로 변경됨: “식별하고자 하는 무언가”</li>
<li>기타 HTTP와 URI에 많은 영향을 줌</li>
</ul>
<h3 id="그럼-REST는-성공했는가"><a href="#그럼-REST는-성공했는가" class="headerlink" title="그럼 REST는 성공했는가"></a>그럼 REST는 성공했는가</h3><ul>
<li>REST는 웹의 독립적 진화를 위해 만들어졌다.</li>
<li>웹은 독립적으로 진화하고 있다.</li>
</ul>
<p>그럼 성공!</p>
<h2 id="그런데-REST-API는"><a href="#그런데-REST-API는" class="headerlink" title="그런데 REST API는?"></a>그런데 REST API는?</h2><ul>
<li>REST API는 REST 아키텍쳐 스타일을 따라야한다.</li>
<li>오늘날 스스로 REST API라고 하는 API들이 REST 아키텍쳐 스타일을 따르지 않는다.</li>
</ul>
<h2 id="REST-API도-제약-조건들을-다-지켜야-하는가"><a href="#REST-API도-제약-조건들을-다-지켜야-하는가" class="headerlink" title="REST API도 제약 조건들을 다 지켜야 하는가?"></a>REST API도 제약 조건들을 다 지켜야 하는가?</h2><p>꼭 다 지켜야 하는건가? 👉🏻 로이 필딩: 지켜야 함 ㅇㅅㅇ</p>
<p>SOAP이 규칙이 어렵고 REST는 쉬운 줄 알았는데 REST도 어려운거였네?</p>
<h3 id="꼭-REST-API여야-하는건가"><a href="#꼭-REST-API여야-하는건가" class="headerlink" title="꼭 REST API여야 하는건가?"></a>꼭 REST API여야 하는건가?</h3><p>로이 필딩: 꼭 지켜야 하는 것은 아님. 시스템 전체를 통제할 수 있다고 생각하거나, 진화에 관심이 없다면 REST에 대해 따지느라 시간을 낭비하지 마라.</p>
<h2 id="그럼-이제-어떻게-할까"><a href="#그럼-이제-어떻게-할까" class="headerlink" title="그럼 이제 어떻게 할까?"></a>그럼 이제 어떻게 할까?</h2><ol>
<li>REST API를 구현하고 REST API라고 부른다.</li>
<li>REST API 구현을 포기하고 HTTP API라고 부른다.</li>
<li>REST API가 아니지만 REST API라고 부른다.</li>
</ol>
<p>당신의 선택은?</p>
<p>현재 상태는 3번이 대부분이다.</p>
<h2 id="도전-REST-API를-구현해보자"><a href="#도전-REST-API를-구현해보자" class="headerlink" title="도전, REST API를 구현해보자."></a>도전, REST API를 구현해보자.</h2><h3 id="일단-왜-API는-REST가-잘-안되는걸까"><a href="#일단-왜-API는-REST가-잘-안되는걸까" class="headerlink" title="일단 왜 API는 REST가 잘 안되는걸까?"></a>일단 왜 API는 REST가 잘 안되는걸까?</h3><p>일반적인 웹과 비교를 해보면 웹은 기계와 사람이 커뮤니케이션하는 것이지만 API는 기계와 기계가 커뮤니케이션을 한다.</p>
<p>그러므로 Media Type 또한 웹 페이지는 HTML을 사용하지만 API는 JSON을 사용한다.</p>
<p><img src="/../img/230329/2023-03-29-14-54-38.png" alt="스크린샷.png"></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="Self-descriptive"><a href="#Self-descriptive" class="headerlink" title="Self-descriptive"></a>Self-descriptive</h3><ol>
<li>응답 메세지의 Content-Type을 보고 media type을 확인</li>
<li>HTTP 명세에 media type은 IANA에 등록되어 있다고 하므로 application&#x2F;json의 설명을 찾음</li>
<li>명세에 json 문서를 파싱하는 방법이 명시되어 있으므로 성공적으로 파싱. <strong>하지만 “id”가 무엇을 의미하고, “title”이 무엇을 의미하는지 알 방법이 없음</strong></li>
</ol>
<h3 id="HATEOAS-1"><a href="#HATEOAS-1" class="headerlink" title="HATEOAS"></a>HATEOAS</h3><p>다음 상태로 전이할 링크가 없다.</p>
<h2 id="Self-decriptive와-HATEOAS가-독립적-진화에-어떻게-도움이-된다는-걸까"><a href="#Self-decriptive와-HATEOAS가-독립적-진화에-어떻게-도움이-된다는-걸까" class="headerlink" title="Self-decriptive와 HATEOAS가 독립적 진화에 어떻게 도움이 된다는 걸까?"></a>Self-decriptive와 HATEOAS가 독립적 진화에 어떻게 도움이 된다는 걸까?</h2><ul>
<li>서버나 클라이언트가 변경되더라도 오고가는 메세지는 언제나 해석이 가능하다.</li>
<li>어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서 전이될 수 있는 상태가 결정된다. 즉, 링크를 마음대로 바꿀 수 있다. ‘</li>
</ul>
<h2 id="그럼-REST-API로-고쳐보자"><a href="#그럼-REST-API로-고쳐보자" class="headerlink" title="그럼 REST API로 고쳐보자"></a>그럼 REST API로 고쳐보자</h2><h2 id="Self-descriptive-1"><a href="#Self-descriptive-1" class="headerlink" title="Self-descriptive"></a>Self-descriptive</h2><h3 id="방법-1-Media-type"><a href="#방법-1-Media-type" class="headerlink" title="방법 1. Media type"></a>방법 1. Media type</h3><ol>
<li>미디어 타입을 하나 정의한다.</li>
<li>미디어 타입 문서를 작성한다. 이 문서에 id가 뭐고 title이 뭔지 의미를 정의한다.</li>
<li>IANA에 미디어 타입을 등록한다. 이 때 만든 문서를 미디어 타입의 명세로 등록한다.</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line">**<span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/vnd.<span class="property">todos</span>+json**</span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>단점: 매번 media type을 정의해야한다.</p>
<h3 id="방법-2-Profile"><a href="#방법-2-Profile" class="headerlink" title="방법 2. Profile"></a>방법 2. Profile</h3><ol>
<li>id가 뭐고 title이 뭔지 의미를 정의한 명세를 작성한다.</li>
<li>Link 헤더에 profile relation으로 해당 명세를 링크한다.</li>
<li>이제 메시지를 보는 사람은 명세를 찾아갈 수 있으므로 이 문서의 의미를 온전히 해석할 수 있다.</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/json</span><br><span class="line"><span class="title class_">Link</span>: <span class="language-xml">&lt;https://example.org/docs/todos&gt;</span> rel=<span class="string">&quot;profile&quot;</span></span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>단점: Content negotiation을 할 수 없다. (링크로 만들어놨기 때문)</p>
<h2 id="HATEOAS-2"><a href="#HATEOAS-2" class="headerlink" title="HATEOAS"></a>HATEOAS</h2><h3 id="방법1-data로"><a href="#방법1-data로" class="headerlink" title="방법1. data로"></a>방법1. data로</h3><p>data에 다양한 방법으로 하이퍼링크를 표현한다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">org</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/json</span><br><span class="line"><span class="title class_">Link</span>: <span class="language-xml">&lt;https://example.org/docs/todos&gt;</span> rel=<span class="string">&quot;profile&quot;</span></span><br><span class="line">[</span><br><span class="line">	&#123;<span class="string">&quot;link&quot;</span> : <span class="string">&quot;https://example.org/todos/&quot;</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;집에 가기&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&quot;id&quot;</span>:<span class="number">2</span>, <span class="string">&quot;title&quot;</span>: <span class="string">&quot;밥 먹기&quot;</span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>단점: 링크를 표현하는 방법을 직접 정의해야한다.</p>
<h3 id="방법2-HTTP-헤더로"><a href="#방법2-HTTP-헤더로" class="headerlink" title="방법2. HTTP 헤더로"></a>방법2. HTTP 헤더로</h3><p>Link, Location을 추가로 넣어준다.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /todos <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: appliacation/json</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;title&quot;</span>: <span class="string">&quot;점심 약속&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">204</span> <span class="title class_">No</span> <span class="title class_">Content</span></span><br><span class="line"><span class="title class_">Location</span>: <span class="regexp">/todos/</span><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>오늘날의 대부분 “REST API”는 사실 REST를 따르고 있지 않다.</li>
<li>REST 제약 조건 중에서 Self-descriptive와 HATEOAS를 잘 만족하지 못한다.</li>
<li>REST는 긴 수년간 진화하는 웹 애플리케이션을 위한 것</li>
<li>REST를 따를 것인지는 API를 설계하는 이들이 스스로 판단하여 결정해야 한다.</li>
<li>REST를 따르겠다면 Self-descriptive와 HATEOAS를 만족시켜야 한다.</li>
<li>따르지 않겠다면 REST API를 뭐라고 부를지 결정하자.</li>
</ul>
<hr>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>5년 전 컨퍼런스 영상이지만 이것만큼 REST API에 대해 잘 설명해주는 영상이 없는 것 같아 영상을 보면서 스스로 정리해보는 시간을 가졌다.</p>
<p>REST가 무엇인지 그래서 오늘날의 REST API는 REST한지에 대해서 다시 한 번 생각해보는 시간을 가지게 되었다.</p>
<h2 id="Referrence"><a href="#Referrence" class="headerlink" title="Referrence"></a>Referrence</h2><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=RP_f5dMoHFc">그런 REST API로 괜찮은가</a></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2023/230330-archive/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2023/230327-archive/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

    
        <div id="disqus_thread"></div>
        <script>
            /**
            *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
            *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
            
            var disqus_config = function () {
                this.page.url = 'https://leejaelll.github.io/2023/230329-archive/';  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = '2023/230329-archive/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                this.language = 'en'
            };
            
            (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://leejaelll.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>   
     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
      <div class="search-popup">
    <div class="search-popup-overlay">  
    </div>
    <div class="search-popup-window" >
        <div class="search-header">
            <div class="search-input-container">
              <input autocomplete="off" autocapitalize="off" maxlength="80"
                     placeholder="Search Anything" spellcheck="false"
                     type="search" class="search-input">
            </div>
            <div class="search-close-btn">
                <div class="icon close-btn"></div>
            </div>
        </div>
        <div class="search-result-container">
        </div>
    </div>
</div>

<script>
    const searchConfig = {
        path             : "/search.xml",
        top_n_per_article: "1",
        unescape         : "false",
        trigger: "auto",
        preload: "false"
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script>
<script src="/js/search.js"></script>
    
    

  </body>
</html>
